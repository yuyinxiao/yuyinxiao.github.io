<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大数据调优</title>
    <url>/2019/12/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h1 id="大数据调优"><a href="#大数据调优" class="headerlink" title="大数据调优"></a>大数据调优</h1><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>不怕数据大，就怕数据斜。报错：<code>reduce.shuffle出错，java heap space造成OOM</code></p>
<p>map读入文件的时候每一个切片对应一个map task；到reduce时shuffle某个key数据太多造成reduce运行缓慢</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ol>
<li>过滤空值；空值可能会造成大量数据进入到一个reduce中造成内存不足</li>
<li>预跑+设定最大；每个Reduce处理的数据默认是256MB<code>hive.exec.reducers.bytes.per.reducer=256000000</code>;每个任务最大的reduce数，默认为1009<code>hive.exec.reducers.max=1009</code>;<code>N=min(参数2，总输入数据量/参数1)</code>设置Reducer的数量<code>set mapreduce.job.reduces=n</code></li>
</ol>
<a id="more"></a>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>RDD窄依赖没有shuffle过程；RDD在遇到宽依赖时shuffle就是一个stage。更多spark内容参考<br><a href="https://mp.weixin.qq.com/s/-nP26zi8B2PLpVmHorfzbA" target="_blank" rel="noopener">30分钟理解Spark的基本原理</a></p>
<h3 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h3><h4 id="提高executor内存"><a href="#提高executor内存" class="headerlink" title="提高executor内存"></a>提高executor内存</h4><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>driverMemory</td>
<td>4</td>
<td>dirver创建sc，初始化DAG和任务调度</td>
</tr>
<tr>
<td>driverCores</td>
<td>2</td>
</tr>
<tr>
<td>numExecutors</td>
<td>64</td>
<td>执行器个数</td>
</tr>
<tr>
<td>executorCores</td>
<td>4</td>
</tr>
<tr>
<td>executorMemory</td>
<td>16</td>
</tr>
</tbody>
</table>
</div>
<h3 id="RDD的分区数"><a href="#RDD的分区数" class="headerlink" title="RDD的分区数"></a>RDD的分区数</h3><p>一个文件多个block，若干个block合并为一个输入分片InputSplit，对应一个task，合并RDD后对应输出RDD的一个partition；<br>InputSplit不跨越文件；<br>map阶段不改变rdd的partition数量，reduce阶段shuffle后改变rdd的partiiton数量<br>task的并行度：executor_num <em> cores /task个数<br>map_task数=读取分片数<br>reduce_task数=executor数量</em>executor_cores核数</p>
<p>序列化Kryo序列<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extraSparkConf	--conf spark.serializer=org.apache.spark.serializer.</span><br><span class="line">KryoSerializer --conf spark.kryoserializer.buffer.max.mb=2000</span><br></pre></td></tr></table></figure></p>
<p>其他参数优化参考<br><a href="https://zhuanlan.zhihu.com/p/108454557" target="_blank" rel="noopener">超全spark性能优化总结</a></p>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>大数据调优</tag>
        <tag>工程</tag>
        <tag>数据倾斜</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/2019/12/19/git-md/</url>
    <content><![CDATA[<h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><h3 id="新建分支以及远程分支"><a href="#新建分支以及远程分支" class="headerlink" title="新建分支以及远程分支"></a>新建分支以及远程分支</h3><p>git branch yyx_nu<br>git checkout yyx_nu<br>git push —set-upstream origin yyx_nu</p>
<a id="more"></a>
<h3 id="新本地分支追溯远程分支"><a href="#新本地分支追溯远程分支" class="headerlink" title="新本地分支追溯远程分支"></a>新本地分支追溯远程分支</h3><p>git checkout -b dev_yyx<br>git branch —set-upstream-to=origin/dev_yyx</p>
<h4 id="删除分支以及远程分支"><a href="#删除分支以及远程分支" class="headerlink" title="删除分支以及远程分支"></a>删除分支以及远程分支</h4><p>git checkout master<br>git push origin —delete dev_yyx<br>git branch -D dev_yyx</p>
<h3 id="拉推"><a href="#拉推" class="headerlink" title="拉推"></a>拉推</h3><p>commit,master,pull,checkout本地,merge master,push</p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><ol>
<li>对于一个任务修改多次，提交多次（amend），一次push；（添加时选中amend即可）</li>
<li>对于一个任务修改多次，提交多次（amend），多次push；（push时使用下句）<code>git push --force-with-lease origin yyx</code></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>revert</td>
<td>修改编辑后，点击revert则撤回修改；commit之前可用</td>
</tr>
<tr>
<td>commit</td>
<td>amend，参考上述commit</td>
</tr>
<tr>
<td>push</td>
<td>多次amend提交用<code>git push --force-with-lease origin yyx</code></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>bd</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell基础</title>
    <url>/2019/11/19/Shell/</url>
    <content><![CDATA[<h1 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h1><h2 id="vim命令"><a href="#vim命令" class="headerlink" title="vim命令"></a>vim命令</h2><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>set nonu</td>
<td>不显示行号</td>
</tr>
<tr>
<td>&lt;-查找-&gt;</td>
<td>&lt;-查找=&gt;</td>
</tr>
<tr>
<td>/</td>
<td>向后搜索</td>
</tr>
<tr>
<td>n</td>
<td>查找下一处</td>
</tr>
<tr>
<td>N</td>
<td>查找上一处</td>
</tr>
<tr>
<td>&lt;-跳转-&gt;</td>
<td>&lt;-跳转=&gt;</td>
</tr>
<tr>
<td>gg</td>
<td>跳转到文件开头</td>
</tr>
<tr>
<td>G</td>
<td>跳转到文件结尾</td>
</tr>
<tr>
<td>b</td>
<td>单词后跳</td>
</tr>
<tr>
<td>e</td>
<td>单词前跳</td>
</tr>
<tr>
<td>0</td>
<td>跳至行首</td>
</tr>
<tr>
<td>$</td>
<td>跳至行尾</td>
</tr>
<tr>
<td>ctrl+f</td>
<td>向下翻页</td>
</tr>
<tr>
<td>ctrl+b</td>
<td>向上翻页</td>
</tr>
<tr>
<td>H</td>
<td>跳转至屏幕头</td>
</tr>
<tr>
<td>M</td>
<td>跳转至屏幕中间</td>
</tr>
<tr>
<td>L</td>
<td>跳转至屏幕底</td>
</tr>
<tr>
<td>&lt;-删除-&gt;</td>
<td>&lt;-删除-&gt;</td>
</tr>
<tr>
<td>r + any</td>
<td>将光标处字符替换</td>
</tr>
<tr>
<td>x</td>
<td>删除光标处字符，右往左缩进</td>
</tr>
<tr>
<td>长按d</td>
<td>滚动删除行</td>
</tr>
<tr>
<td>dd</td>
<td>删除光标所在的行</td>
</tr>
<tr>
<td>d0</td>
<td>删除光标到头</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标到头</td>
</tr>
<tr>
<td>:%d</td>
<td>清空所有</td>
</tr>
</tbody>
</table>
</div>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>本地安装的shell目录：etc/shells</p>
<h3 id="fork-与-source"><a href="#fork-与-source" class="headerlink" title="fork 与 source"></a>fork 与 source</h3><p>fork：执行shell script时，其实是产生一个sub-shell 的子进程，然后sub-shell再去产生命令行的子行程。<br>source：b.sh脚本中有source ./a.sh；就是使a.sh在当前b.sh的shell内执行、而不是再产生一个sub-shell 來執行。但b.sh是fork出来的子进程</p>
<p>$：給一般使用者使用 #：給 root (管理員)使用</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>[command line]</td>
<td>代码块</td>
</tr>
<tr>
<td>echo</td>
<td>-n无换行输出</td>
</tr>
<tr>
<td>date</td>
<td>-d(2019-12-01) -/+ 2 days +%F</td>
</tr>
<tr>
<td>&gt;</td>
<td>输出重导向</td>
</tr>
<tr>
<td>&lt;</td>
<td>输入重导向</td>
</tr>
<tr>
<td>｜</td>
<td>命令管道</td>
</tr>
<tr>
<td>;</td>
<td>忽略其前返回值执行下一個命令</td>
</tr>
<tr>
<td>‘ ‘(单引号)</td>
<td>关键字符转为字符串</td>
</tr>
<tr>
<td>$(command)</td>
<td>将命令替换，类似’’</td>
</tr>
<tr>
<td>$var与${var}</td>
<td>二者相同，${ }精确范围</td>
</tr>
<tr>
<td>“ “(双引号)</td>
<td>大部分为字符串，但某些保留(如$ )参数含空格时用””包裹</td>
</tr>
<tr>
<td>export</td>
<td>将本地变量（.bash_profile）”输出”为环境变量</td>
</tr>
<tr>
<td>unset</td>
<td>取消变量</td>
</tr>
<tr>
<td>$0-9</td>
<td>$0脚本名,$1-9第几个参数，第十个参数${10}</td>
</tr>
<tr>
<td>shift</td>
<td>shift 3取消前3个参数，第4个为第1个</td>
</tr>
<tr>
<td>mkdir -p /a/b/c</td>
<td>父目录不存在时会创建，不会报错。</td>
</tr>
<tr>
<td>hadoop fs -germerge -nl /hdfs_dir  /local_dir/</td>
<td>同名则会覆盖；nl在不同文件之间会空一行</td>
</tr>
<tr>
<td>hadoop fs -du -s -h /hdfs_dir</td>
<td>文件夹下数据大小</td>
</tr>
<tr>
<td>hadoop fs -test</td>
<td>-e：如果路径存在，则返回 0;-s：如果路径不为空，则返回 0。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Mac端shell"><a href="#Mac端shell" class="headerlink" title="Mac端shell"></a>Mac端shell</h3><p>本地bash：/bin: /usr/bin: /usr/local/bin: ${PATH}包含以上的bin目录下命令文件，本地bash可直接执行；<br>.bash_profile：export PATH 添加第三方（maven，idea等）加载到本地bash可直接执行；<br>.zshrc ：文件首先source ~/.bash_profile 将上面新添加命令加载到zsh中（内置可用，新添加到bash_profile也可用）</p>
<a id="more"></a>
<h2 id="source"><a href="#source" class="headerlink" title="source"></a>source</h2><ul>
<li>sh check. sh == ./check.sh</li>
<li>source.check .sh == .check.sh</li>
</ul>
<p>source(或点)命令通常用于重新执行刚修改的初始化文档，如 .bash_profile和 .profile。<br><strong>在check.sh的子shell中source 几个文件，将文件中的变量和函数编译加载，然后子shell使用。</strong></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li>当shell脚本具有可执行权限时，sh check与./check执行脚本一样；</li>
<li>sh check 新建子shell执行脚本，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export；</li>
<li>source check.sh：读取脚本里面的语句依次在当前shell里面首先执行（一般放在shell前面）。没有建立新的子shell。脚本内所有变量的语句都会保存在当前shell里面。当前shell中可以直接用check中定义的变量，函数。</li>
<li>执行脚本是在一个子shell环境运行的，脚本执行完后该子shell自动退出。</li>
<li>执行脚本中的系统环境变量（用export定义的变量）才会被复制到子shell中。</li>
<li>一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）。</li>
<li>不用export定义的变量只对该shell有效，对子shell也是无效的。 直接执行一个脚本文件是在一个子shell中运行的，而source则是在当前shell环境中运行的。source可以让脚本影响它们的父shell环境,这和export去影响子shell环境相反。</li>
</ol>
<h2 id="关于-参数"><a href="#关于-参数" class="headerlink" title="关于$ 参数"></a>关于$ 参数</h2><ul>
<li>$1~9：函数内获取第1-9个参数；</li>
<li>$0：文件名；</li>
<li>$# ：命令行参数个数；</li>
<li>$@ ：所有参数；</li>
<li>$* ：所有命令行参数；</li>
<li>$? ：前一个命令的退出状态，可用于获取函数返回值；</li>
<li>$$ ：执行的进程 ID。</li>
</ul>
<h2 id="工程内部常用shell整理"><a href="#工程内部常用shell整理" class="headerlink" title="工程内部常用shell整理"></a>工程内部常用shell整理</h2><ul>
<li>执行脚本输出：+表示的是Shell调试器的输出日志，不带 + 表示程序内的输出；</li>
<li>‘’单引号严格，双引号“”可以嵌套单引号；</li>
<li>local定义本地变量；输出字符串’$引用变量’；</li>
<li>source /../../**.conf 当作shell脚本获取.conf文件中的变量</li>
<li>basename：取文件名；dirname：取路径名</li>
<li>date -d t1 -range +F :定义时间-d / +F 定义格式</li>
<li>rn -r -skipTrash 删除文件时确定不放入回收站，直接删除</li>
<li>shift 位置参数可以用shift命令左移。默认为1</li>
</ul>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解GBDT与XGB</title>
    <url>/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GBDT%E4%B8%8EXGB/</url>
    <content><![CDATA[<h1 id="GBDT与XGB"><a href="#GBDT与XGB" class="headerlink" title="GBDT与XGB"></a>GBDT与XGB</h1><p>相信看到这篇文章的你对于梯度提升树的推导计算应该有所了解，但是推导公式只是理论理解，工程实现上却有很多细节需要探究。此外因为关于梯度提升树整理得较多，比较杂乱。所以为了更好地理解和向别人介绍梯度提升树，需要系统的掌握。<br><strong>梯度提升思想-&gt;决策树思想-&gt;梯度提升树理论-&gt;代码-&gt;wink</strong></p>
<p><a href="https://blog.csdn.net/program_developer/article/details/102763481" target="_blank" rel="noopener">深入理解GBDT</a></p>
<a id="more"></a>
<h2 id="CART树（分类与回归树）"><a href="#CART树（分类与回归树）" class="headerlink" title="CART树（分类与回归树）"></a>CART树（分类与回归树）</h2><p>目标函数的定义决定了CART树用与回归还是分类，排序任务</p>
<h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><h4 id="GBDT提升树原理"><a href="#GBDT提升树原理" class="headerlink" title="GBDT提升树原理"></a>GBDT提升树原理</h4><p><img src="/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GBDT%E4%B8%8EXGB/1.png" alt="avater"><br><img src="/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GBDT%E4%B8%8EXGB/2.png" alt="avater"><br>无论损失函数是什么形式，每个决策树拟合的都是负梯度。准确的说，不是用负梯度代替残差，而是当损失函数是平方损失时，负梯度刚好是残差，残差只是特例。<br><strong>$\theta$参数空间的优化，方向是$L$对$\theta$的负梯度；提升树作为函数空间的优化，方向是$L$对$F_{m-1}(x)$的负梯度</strong></p>
<p><strong>对于GBDT来说，新的提升树拟合的都是前面m-1棵树对样本造成的损失对前m-1棵树权重的负梯度方向。</strong><br><a href="https://www.zhihu.com/question/63560633/answer/379959040" target="_blank" rel="noopener">参考知乎</a></p>
<h4 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h4><p><img src="/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GBDT%E4%B8%8EXGB/log_fenlei.png" alt="avatar"><br>逻辑回归、FM模型用于分类问题，其实是在用一个线性模型或者包含交叉项的非线性模型，去拟合对数几率$ln{\frac{p}{1-p}}$。而GBDT也是一样，用一系列的梯度提升树去拟合这个对数几率，实际上最终得到的是一系列CART回归树。其分类模型可以表达为：</p>
<script type="math/tex; mode=display">P(y=1|x)=\frac{1}{1+e^{-\sum_{m=0}^{M}h_m(x)}}</script><p>前m棵树相加，然后非线性变换为概率P作为预测概率，$h_m(x)$为学习到的决策树<br>交叉熵损失函数为：</p>
<script type="math/tex; mode=display">l(x_i,y_i)=-y_i\log{\hat{y_i}}-(1-y_i)\log(1-\hat{y_i})</script><p>迭代k步后，模型输出为</p>
<script type="math/tex; mode=display">\hat{y_i}=F(x)=\sum_{k=0}^Kh_m(x)</script><p>，损失函数为</p>
<script type="math/tex; mode=display">L(x_i,y_i|F(x))=y_i\log(1+e^{-F(x_i)})+(1-y_i)[F(x_i)+\log(1+e^{-F(x_i)})]</script><p>求导得到梯度为</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial {F(x)}}|_{x_i,y_i}=P-y_i</script><p>因此对于下一棵决策树的训练样本X，其所需要拟合的<strong>负梯度</strong>为真实标签与预测概率的残差$y_i-P$。<br><img src="/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GBDT%E4%B8%8EXGB/multi_fenlei.png" alt="avatar"><br><a href="https://blog.csdn.net/qq_22238533/article/details/79192579?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考知乎</a></p>
<h4 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h4><p><img src="/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GBDT%E4%B8%8EXGB/ls_huigui.png" alt="avatar"><br>回归预测采用平方误差损失</p>
<script type="math/tex; mode=display">L=\sum_{i=1}^{N}l(y_i,F_{m-1}(x)+h_m(x_i))</script><script type="math/tex; mode=display">L=\sum_{i=1}^{N}(y_i-F_{m-1}(x)-h_m(x_i))^2</script><p>欲使损失最小，很显然则需要满足</p>
<script type="math/tex; mode=display">h_m(x_i)=r=(y_i-F_{m-1}(x))</script><p>拟合残差即可。—<strong>《统计学习方法》</strong><br>或者<strong>通过求取负梯度，使$h_m(x_i)=T(x_i,\theta_m)$拟合</strong>，满足损失最小</p>
<script type="math/tex; mode=display">L=\sum_{i=1}^{N}(y_i-F_{m-1}(x_i))^2</script><p>求导得到</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial {F_{m-1}(x)}}|_{x_i,y_i}=-2\sum_{i=1}^{N}(y_i-F(x_i))</script><p>因此新的一棵树$T(x_i,\theta_m)$应该对于样本$(x_i,y_i)$需要拟合$r=y_i-F_{m-1}(x_i)$<br>两种方法是相似的，对于回归任务，新的一棵树的权重拟合的是负梯度(伪残差）</p>
<blockquote>
<blockquote>
<p>对于第一棵树，作为弱分类器，样本预测值为所有样本真实结果的均值；而后每增加一棵树，使得样本在前面所有的树中得到的损失都小。因此新的树权重的拟合方向，就是所有样本在函数空间得到的损失减小的负梯度方向，构成的合矢量方向，保证所有样本损失减小。</p>
</blockquote>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/46445201" target="_blank" rel="noopener">参考知乎</a><br><a href="https://blog.csdn.net/qq_22238533/article/details/79185969" target="_blank" rel="noopener">参考博客</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>因此对于GBDT来说，使用的是CART树。并且通过定义合适的目标函数实现不同的任务。但总得来说，<strong>GBDT的提升树叶子权重拟合的都是负梯度，实为真实值与预测结果值的残差。</strong></p>
<ol>
<li>回归任务：拟合的是r=真实值-前向累加的结果；$y-\hat{y}$</li>
<li>二分类：拟合的是r=真实值-前向累加后非线性变换的结果；$y-p$</li>
<li>多分类：拟合的是r=真实值-前向累加后非线性变换+softmax的结果。$y-\hat{y_p}$</li>
</ol>
<p>初始化弱分类器时，不同任务对应不同损失函数，对应不同的初始化方式<a href="https://blog.csdn.net/qq_22238533/article/details/79185969" target="_blank" rel="noopener">参考博客</a></p>
<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p><img src="/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GBDT%E4%B8%8EXGB/gbdt.png" alt="avatar"></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&amp;mid=2247485159&amp;idx=1&amp;sn=d429aac8370ca5127e1e786995d4e8ec&amp;chksm=e9d01626dea79f30043ab80652c4a859760c1ebc0d602e58e13490bf525ad7608a9610495b3d&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">XGB精选面试题</a></p>
<h2 id="GBDT-vs-XGB"><a href="#GBDT-vs-XGB" class="headerlink" title="GBDT vs XGB"></a>GBDT vs XGB</h2><p>GBDT：$w^<em>=-G$<br>XGB：$w^</em>=-\frac{G}{H}$</p>
<p>GBDT初始化弱分类器，任务，损失函数不同，初始化方式不同；<br>XGB初始化弱分类器，都归为0，因此训练时略去初始化过程</p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>geo_hash</title>
    <url>/2019/10/29/geo-hash/</url>
    <content><![CDATA[<h1 id="Geohash"><a href="#Geohash" class="headerlink" title="Geohash"></a>Geohash</h1><p>Geohash算法将经纬度二维数据编码为一个字符串，本质是一个降维的过程<br><a href="https://www.cnblogs.com/feiquan/p/11380461.html" target="_blank" rel="noopener">参考网址</a></p>
<h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">地点</th>
<th style="text-align:center">经纬度</th>
<th style="text-align:center">Geohash</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">鸟巢</td>
<td style="text-align:center">116.402843,39.999375</td>
<td style="text-align:center">wx4g8c9v</td>
</tr>
<tr>
<td style="text-align:center">水立方</td>
<td style="text-align:center">116.3967,39.99932</td>
<td style="text-align:center">wx4g89tk</td>
</tr>
<tr>
<td style="text-align:center">故宫</td>
<td style="text-align:center">116.40382,39.918118</td>
<td style="text-align:center">wx4g0ffe</td>
</tr>
</tbody>
</table>
</div>
<p>鸟巢和水立方的前五位是一样的，而鸟巢和故宫只有前4位是一样的。也就是说<strong>Geohash前面相同的越多，两个位置越近，但是反过来说，却不一定</strong></p>
<a id="more"></a>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将经纬度转换为Geohash大体可以分为三步曲：</p>
<ul>
<li>用 39.918118 举例，由于39.918118 属于 (0, 90)，所以编码为1，然后我们继续将(0, 90)分成(0, 45)、(45, 90)两个区间，而39.918118 位于(0, 45)，所以编码是0，依次类推，我们进行20次拆分，最后计算39.918118 的编码是 10111000110001011011；经度的处理也是类似，只是经度的范围是(-180, 180)，116.40382的编码是<strong>11010010110001101010</strong></li>
<li>经纬度的编码合并，从0开始，奇数为是纬度，偶数为是经度，得到的编码是<strong>1110011101001000111100000011100111001101</strong></li>
<li>对经纬度合并后的编码，进行base32编码，最终得到<strong>wx4g0ffe</strong></li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geo_Hash</span><span class="params">(lng,lat,length)</span>:</span></span><br><span class="line">    Min_Lat = <span class="number">-90.00</span></span><br><span class="line">    Max_Lat = <span class="number">90.00</span></span><br><span class="line">    Min_Lng= <span class="number">-180.00</span></span><br><span class="line">    Max_Lng= <span class="number">180.00</span></span><br><span class="line">    geo_length=length*<span class="number">5</span>/<span class="number">2</span></span><br><span class="line">    base32Lookup =[<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>,<span class="string">"j"</span>, <span class="string">"k"</span>, <span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(begin, end, value, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (len(result) &gt; (geo_length - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (end + begin) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; mid):</span><br><span class="line">            result.append(<span class="string">'0'</span>)</span><br><span class="line">            convert(begin, mid, value, result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(<span class="string">'1'</span>)</span><br><span class="line">            convert(mid, end, value, result)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertToIndex</span><span class="params">(unit)</span>:</span></span><br><span class="line">        length =len(unit)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(length):</span><br><span class="line">            <span class="keyword">if</span> unit[index] == <span class="string">'0'</span>:</span><br><span class="line">                num+=<span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num+=(<span class="number">1</span> &lt;&lt; (length - <span class="number">1</span> - index))</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    </span><br><span class="line">    latList = []</span><br><span class="line">    lngList = []</span><br><span class="line">    result=<span class="string">""</span></span><br><span class="line">    convert(Min_Lat, Max_Lat, lat, latList)</span><br><span class="line">    convert(Min_Lng, Max_Lng, lng, lngList)</span><br><span class="line">    code_str=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(latList)):</span><br><span class="line">        code_str+=(lngList[index]+latList[index])</span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>,len(code_str),<span class="number">5</span>):</span><br><span class="line">        unit = code_str[start:start + <span class="number">5</span>]</span><br><span class="line">        result+=base32Lookup[convertToIndex(unit)]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>将经纬度转换为二进制编码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">double</span> min, <span class="keyword">double</span> max, <span class="keyword">double</span> value, List&lt;Character&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; (length - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> mid = (max + min) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; mid) &#123;</span><br><span class="line">        list.add(<span class="string">'0'</span>);</span><br><span class="line">        convert(min, mid, value, list);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list.add(<span class="string">'1'</span>);</span><br><span class="line">        convert(mid, max, value, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>合并经纬度的二进制编码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Character&gt; latList = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">List&lt;Character&gt; lngList = <span class="keyword">new</span> ArrayList&lt;Character&gt;();</span><br><span class="line">convert(Min_Lat, Max_Lat, lat, latList);</span><br><span class="line">convert(Min_Lng, Max_Lng, lng, lngList);</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; latList.size(); index++) &#123;</span><br><span class="line">    sb.append(lngList.get(index)).append(latList.get(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>base32编码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] base32Lookup =&#123;<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>,<span class="string">"j"</span>, <span class="string">"k"</span>,<span class="string">"m"</span>, <span class="string">"n"</span>, <span class="string">"p"</span>, <span class="string">"q"</span>, <span class="string">"r"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">"u"</span>, <span class="string">"v"</span>, <span class="string">"w"</span>, <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">base32Encode</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</span><br><span class="line">    String unit = <span class="string">""</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; str.length(); start = start + <span class="number">5</span>) &#123;</span><br><span class="line">        unit = str.substring(start, start + <span class="number">5</span>);</span><br><span class="line">        sb.append(base32Lookup[convertToIndex(unit.split(<span class="string">""</span>))]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">convertToIndex</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">        result += str.charAt(index) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span> &lt;&lt; (length - <span class="number">1</span> - index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h3><p>两个位置距离得越近是否意味着Geohash前面相同的越多呢？答案是否定的，两个很近的地点[116.3967,44.9999]和[116.3967,45.0009]的Geohash分别是<strong>wxfzbxvr</strong>和<strong>y84b08j2</strong>，这就是Geohash存在的边界问题，这两个地点虽然很近，但是刚好在分界点45两侧，导致Geohash完全不同，单纯依靠Geohash匹配前缀的方式并不能解决这种问题</p>
<p>在一维空间解决不了这个问题，回到二维空间中，将当前Geohash这块区域周围的八块区域的Geohash计算出来<br>[116.3967,44.9999] 周围8块区域的Geohash</p>
<blockquote>
<p><b>y84b08j2</b>, wxfzbxvq, wxfzbxvx, wxfzbxvp, y84b08j8, y84b08j0, wxfzbxvw, wxfzbxvn</p>
</blockquote>
<p>[116.3967,45.0009] 周围8块区域的Geohash</p>
<blockquote>
<p>y84b08j3, <b>wxfzbxvr</b>, y84b08j8, y84b08j0, y84b08j9, y84b08j1, wxfzbxvx, wxfzbxvp</p>
</blockquote>
<p>[116.3967,44.9999]和[116.3967,45.0009]分别出现在各自附近的区域中，周围8个区域的Geohash怎么计算得到呢？很简单，当Geohash长度是8时，对应的每个最小单元<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> latUnit = (Max_Lat - Min_Lat) / (<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"><span class="keyword">double</span> lngUnit = (Max_Lng - Min_Lng) / (<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br></pre></td></tr></table></figure><br>这样可以计算出8个分别分布在周围8个区域的地点，根据地点便可以计算出周围8个区域的Geohash<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[lat + latUnit, lng]</span><br><span class="line">[lat - latUnit, lng]</span><br><span class="line">[lat, lng + lngUnit]</span><br><span class="line">[lat, lng - lngUnit]</span><br><span class="line">[lat + latUnit, lng + lngUnit]</span><br><span class="line">[lat + latUnit, lng - lngUnit]</span><br><span class="line">[lat - latUnit, lng + lngUnit]</span><br><span class="line">[lat - latUnit, lng - lngUnit]</span><br></pre></td></tr></table></figure></p>
<h3 id="距离还是距离"><a href="#距离还是距离" class="headerlink" title="距离还是距离"></a>距离还是距离</h3><p>打开饿了么这样的应用，除了可以看到附近的商家外，还能清晰看到离每个商家的距离，这个距离的怎么计算出呢？这完全是一个数学问题，把地球看着一个球体，先根据经纬度算出空间坐标，进而算出两点直线距离，最后算出弧长，便是两个位置的距离<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="keyword">double</span> lat1, <span class="keyword">double</span> lng1, <span class="keyword">double</span> lat2, <span class="keyword">double</span> lng2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x1 = Math.cos(lat1) * Math.cos(lng1);</span><br><span class="line">    <span class="keyword">double</span> y1 = Math.cos(lat1) * Math.sin(lng1);</span><br><span class="line">    <span class="keyword">double</span> z1 = Math.sin(lat1);</span><br><span class="line">    <span class="keyword">double</span> x2 = Math.cos(lat2) * Math.cos(lng2);</span><br><span class="line">    <span class="keyword">double</span> y2 = Math.cos(lat2) * Math.sin(lng2);</span><br><span class="line">    <span class="keyword">double</span> z2 = Math.sin(lat2);</span><br><span class="line">    <span class="keyword">double</span> lineDistance =</span><br><span class="line">            Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) + (z1 - z2) * (z1 - z2));</span><br><span class="line">    <span class="keyword">double</span> realDistance = EARTH_RADIUS * Math.PI * <span class="number">2</span> * Math.asin(<span class="number">0.5</span> * lineDistance) / <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">return</span> realDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在实际应用中，先根据Geohash筛选出附近的地点，然后再算出距离附近地点的距离</p>
]]></content>
      <categories>
        <category>rec</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>主页</title>
    <url>/2019/10/28/home/</url>
    <content><![CDATA[<p><img src="/2019/10/28/home/main.jpg" alt="home"></p>
]]></content>
      <categories>
        <category>home</category>
      </categories>
  </entry>
  <entry>
    <title>算法导论</title>
    <url>/2019/10/25/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="算法导论"><a href="#算法导论" class="headerlink" title="算法导论"></a>算法导论</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul>
<li>最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的。</li>
<li>无后效性。即子问题的解一旦确定，不受之后和包含它的更大的问题的决策影响。</li>
<li>子问题重叠性质。子问题会被重复计算多次。动态规划对每一个子问题只计算一次保存在表格，简化重复计算时。</li>
</ul>
<a id="more"></a>
<h3 id="钢条切割问题"><a href="#钢条切割问题" class="headerlink" title="钢条切割问题"></a>钢条切割问题</h3><p>长度为n英寸的钢条有$2^{n-1}$种切割方法：因为在距离钢条左端i (i = 1, 2, … , n-1)英寸处，我们总是可以选择切割或不切割。<strong>有重复，可不完全遍历</strong></p>
<p>子问题：</p>
<ol>
<li>左端切下长度为$i$的一段，其中i=1, 2, … , n;有n种切法，左端不再切割，该段的销售收益为$P_i$</li>
<li>右端长度为n-i，对这一段再进行切割，这是一个规模更小的子问题，其收益为$r_{n-i}$。\<br>显然得到最优收益<script type="math/tex; mode=display">r_n=\max_{1≤i≤n}({p_i+r_{n-i}})</script></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> p[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> q=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		q=max(q,p[i]+cut(p,n-i));</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>递归代码的调用树</p>
</blockquote>
</blockquote>
<p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/tree.png" alt="avatar"></p>
<p>复杂度分析：显然重复求解。</p>
<p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/table.png" alt="avatar"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gain[n+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//长度对应的最大收益</span></span><br><span class="line"><span class="keyword">int</span> p[n+<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,,,,&#125;;<span class="comment">//各种长度价位都有</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BottomUpRod</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            gain[i]=max(gain[i],p[j]+gain[i-j]);<span class="comment">//子长度[i-j]最优+价格[j]取最优</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gain[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><ul>
<li>全局排序：O(n*log(n))</li>
<li>局部排序，只排序TopK个数，冒泡等；O(n*k)</li>
<li>堆：TopK个数也不排序了，O(n*log(k))</li>
</ul>
<p><strong>TopK的另一个解法：快排</strong>不同在于对返回的下标判断是否够K个即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = nums[start];</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="comment">//从右找小于key的值，赋给start</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> nums[end] &gt;= key)</span><br><span class="line">            end --;</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        <span class="comment">//从左找大于key的值，赋给end</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> nums[start] &lt;= key)</span><br><span class="line">            start ++;</span><br><span class="line">        nums[end] = nums[start];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key赋给start</span></span><br><span class="line">        nums[start] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//index下标为分割节点，左边index+1个数就是最小的index+1个数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;output;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = input.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(input,start,end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>)&#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(input,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        output.push_back(input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2019/10/25/%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>主要是针对D算法，F算法。</p>
<blockquote>
<blockquote>
<p>G是连通图&lt;&lt;=&gt;&gt;有生成树</p>
</blockquote>
</blockquote>
<ul>
<li>图的表示：<strong>邻接链表，邻接矩阵</strong></li>
<li>BFS：能够正确计算最短路径；</li>
<li>DFS：图的结构；前驱子图构成森林</li>
</ul>
<p>拓扑排序：有向无环图，在一条水平线展示出来，该水平线上的边都是左指向右。<br>计算完成时间，先后排序，然后节点连接。<br><a id="more"></a></p>
<h2 id="图的遍历BFS"><a href="#图的遍历BFS" class="headerlink" title="图的遍历BFS"></a>图的遍历BFS</h2><p>无向图邻接矩阵对称；有向图邻接矩阵非对称；代码一致<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;ss;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">        q.push(v);</span><br><span class="line">        ss.insert(v);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node=q.front();q.pop();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n : G[node])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ss.count(n))</span><br><span class="line">                    ss.insert(n);</span><br><span class="line">                    q.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最小生成树（边权重最小）"><a href="#最小生成树（边权重最小）" class="headerlink" title="最小生成树（边权重最小）"></a>最小生成树（边权重最小）</h2><p>无环子集T，将所有节点连接，边权重最小。这样的图T称为 最小生成树。</p>
<h3 id="K算法-O-ElogE"><a href="#K算法-O-ElogE" class="headerlink" title="K算法-O(ElogE)"></a>K算法-O(ElogE)</h3><p>贪心算法，<strong>选择权重最小边加入森林</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> u,v,cost;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge &amp;e1,<span class="keyword">const</span> edge &amp;e2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line">edge es[MAX_E];  </span><br><span class="line"><span class="keyword">int</span> V,E;   <span class="comment">//顶点数和边数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(es,es+E,cmp);       <span class="comment">//按照edge.cost的顺序从小到大排列</span></span><br><span class="line">    init_union_find(V);      <span class="comment">//并查集的初始化</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;E; i++)&#123;</span><br><span class="line">        edge e=es[i];</span><br><span class="line">        <span class="keyword">if</span>(!same(e.u,e.v))&#123;</span><br><span class="line">            unite(e.u,e.v);</span><br><span class="line">            res+=e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>…………………………………前方高能……………………………………</p>
</blockquote>
</blockquote>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p><a href="https://www.cnblogs.com/alantu2018/p/8464561.html" target="_blank" rel="noopener">图解Prim算法</a></p>
<p>选择最小边<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vis<span class="comment">//标记是否遍历过</span></span><br><span class="line">dis<span class="comment">//节点值</span></span><br><span class="line">mp[i][j]<span class="comment">//节点i,j间的边权重和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis,INF,<span class="keyword">sizeof</span>(dis)); </span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    dis[<span class="number">0</span>]=INF;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//初始化，选择权值最小的边</span></span><br><span class="line">        <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; dis[i]&lt;dis[m])</span><br><span class="line">                m=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        vis[m]=<span class="number">1</span>;        <span class="comment">//选择后标记</span></span><br><span class="line">        ans+=dis[m];     <span class="comment">//累加权重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            dis[i]=min(dis[i],mp[m][i]);<span class="comment">//更新连接的边权，否则INF</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="图-最短路径（变权重最小）"><a href="#图-最短路径（变权重最小）" class="headerlink" title="图-最短路径（变权重最小）"></a>图-最短路径（变权重最小）</h2><h3 id="Dijkstra（迪克斯特拉）算法：带权重单源最短路径问题-单源，非负"><a href="#Dijkstra（迪克斯特拉）算法：带权重单源最短路径问题-单源，非负" class="headerlink" title="Dijkstra（迪克斯特拉）算法：带权重单源最短路径问题  (单源，非负)"></a>Dijkstra（迪克斯特拉）算法：带权重单源最短路径问题  (单源，非负)</h3><p>时间复杂度为O(V^2+E) ; 所有边权重非负。<br><img src="/2019/10/25/%E5%9B%BE/d.gif" alt="avatar"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> cost;<span class="comment">//对节点编号和权值</span></span><br><span class="line">    &#125;;<span class="comment">//图的边</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;<span class="comment">//first为最短距离，second为相应顶点</span></span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;edge&gt;&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> d[MAX_V];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt;&gt; q;<span class="comment">//最小堆</span></span><br><span class="line">    fill(d,d+V,INF);<span class="comment">//各点value全部设为INF</span></span><br><span class="line">    d[s]=<span class="number">0</span>;<span class="comment">//起始点为0</span></span><br><span class="line">    q.push(P(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        P p=q.top(); q.pop();</span><br><span class="line">        <span class="keyword">int</span> v=p.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].size();i++)&#123;</span><br><span class="line">            edge e=G[v][i];</span><br><span class="line">            <span class="comment">//节点v，边e，下一节点e-&gt;to</span></span><br><span class="line">            <span class="keyword">if</span>(d[e.to]&gt;d[v]+e-&gt;cost)&#123;</span><br><span class="line">                d[e.to]=d[v]+e-&gt;cost;</span><br><span class="line">                que.push(P(d[e.to],e-&gt;to));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd算法：图中所有节点的最短路径-全局"><a href="#Floyd算法：图中所有节点的最短路径-全局" class="headerlink" title="Floyd算法：图中所有节点的最短路径 (全局)"></a>Floyd算法：图中所有节点的最短路径 (全局)</h3><p>时间复杂度 O(V^3)；所有边权重可负，但环路不可负；<br>可以用于无向图和有向图中。也可以用于负权的最短路径问题（虽然复杂度会比较高）。Floyd算法的时间复杂度为O（n^3），空间复杂度为O（n^2）。</p>
<p><img src="/2019/10/25/%E5%9B%BE/F.png" alt="avatar"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 弗洛伊德算法实现</span></span><br><span class="line"><span class="comment">//D：用来计算每个相邻点的距离，也就是我们的已知条件；</span></span><br><span class="line"><span class="comment">//P：用来表示中间点k的代数。比如说P中p[i,j]的值就是i与j两点的中间点代数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_Floyd</span><span class="params">(<span class="keyword">int</span>** p, <span class="keyword">int</span>** D)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>, w = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; nVer; ++v)&#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; nVer; ++w)&#123;</span><br><span class="line">            D[v][w] = Edges[v][w];<span class="comment">//v-w间的边</span></span><br><span class="line">            p[v][w] = w;<span class="comment">//v-w路径v的下一节点w</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把K为中间节点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; nVer; ++k)&#123;</span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; nVer; ++v)&#123;</span><br><span class="line">            <span class="keyword">for</span>(w = <span class="number">0</span>; w &lt; nVer; ++w)&#123;</span><br><span class="line">                <span class="keyword">if</span> (D[v][w] &gt; D[v][k] + D[k][w])&#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];</span><br><span class="line">                    p[v][w] = p[v][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><ul>
<li>D算法：单源、权值不可负、有向/无向（自环）</li>
<li>F算法：全局、权值可负但环路不可负、有向/无向（自环）</li>
</ul>
<h2 id="图题目"><a href="#图题目" class="headerlink" title="图题目"></a>图题目</h2><h3 id="最少换乘次数-BFS"><a href="#最少换乘次数-BFS" class="headerlink" title="最少换乘次数 BFS"></a>最少换乘次数 BFS</h3><p>n个城市，部分城市之间有单向航道，给定起始点，得到各个城市的最少换乘次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;     <span class="comment">//城市的id</span></span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//该城市到其他城市的道路数目</span></span><br><span class="line">    <span class="keyword">int</span> des[LEN];<span class="comment">//到的其他城市</span></span><br><span class="line">&#125;City;</span><br><span class="line"></span><br><span class="line">City city[LEN];<span class="built_in">queue</span>&lt;City&gt;q;<span class="keyword">int</span> ans[LEN];<span class="keyword">bool</span> vis[LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    vis[v]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//将起点v指向的第一层目的地压入队列,城市v：city[v]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; city[v].count;i++)&#123;</span><br><span class="line">        vis[city[v]-&gt;des[i]]=<span class="number">1</span>;</span><br><span class="line">        q.push(city[city[v].des[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">int</span> q_size=q.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; q_size;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=q.front().id;q.pop();</span><br><span class="line">            ans[tmp]=num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;city[tmp].count;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[city[tmp]-&gt;des[j]])&#123;</span><br><span class="line">                    vis[city[tmp]-&gt;des[j]]=<span class="number">1</span>;</span><br><span class="line">                    q.push(city[city[tmp]-&gt;des[j]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="克隆图-BFS，Map"><a href="#克隆图-BFS，Map" class="headerlink" title="克隆图 BFS，Map"></a>克隆图 BFS，Map<old,new></old,new></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; m;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q&#123;&#123;node&#125;&#125;;</span><br><span class="line">    Node *clone = <span class="keyword">new</span> Node(node-&gt;val);</span><br><span class="line">    m[node] = clone;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        Node *t = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (Node *neighbor : t-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m.count(neighbor)) &#123;</span><br><span class="line">                m[neighbor] = <span class="keyword">new</span> Node(neighbor-&gt;val);</span><br><span class="line">                q.push(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            m[t]-&gt;neighbors.push_back(m[neighbor]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="课程表：是否可以完成所有课程学完-在有向图中检测是否有环BFS遍历完，所有入度都为0"><a href="#课程表：是否可以完成所有课程学完-在有向图中检测是否有环BFS遍历完，所有入度都为0" class="headerlink" title="课程表：是否可以完成所有课程学完(在有向图中检测是否有环BFS遍历完，所有入度都为0)"></a>课程表：是否可以完成所有课程学完(在有向图中检测是否有环BFS遍历完，所有入度都为0)</h3><p>一系列[0,1]学0前必须先学1-&gt;0；路径题目，是否能够全部学完。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(numCourses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in(numCourses);</span><br><span class="line">	<span class="comment">//统计入度；构造邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : prerequisites) &#123;</span><br><span class="line">        graph[a[<span class="number">1</span>]].push_back(a[<span class="number">0</span>]);</span><br><span class="line">		++in[a[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="comment">//根据入度寻找入口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == <span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.front(); q.pop();</span><br><span class="line">        <span class="comment">//res.push_back(t);//保留课程顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : graph[t]) &#123;</span><br><span class="line">            --in[a];</span><br><span class="line">            <span class="keyword">if</span> (in[a] == <span class="number">0</span>)<span class="comment">//入度为0时入队列，否则重复</span></span><br><span class="line">                q.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回是否能够上完</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回可能的上课顺序</span></span><br><span class="line">    <span class="keyword">if</span> (res.size() != numCourses)</span><br><span class="line">        res.clear();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="图的关键节点"><a href="#图的关键节点" class="headerlink" title="图的关键节点"></a>图的关键节点</h3><p>通过判断下一层节点node的入度是否为0确定node的前驱是否已经全部累加到此节点；如已全部累加则不再入队列，否则重复节点重复往后累加错误<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;BFS(Node* root)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt;res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt;q&#123;root&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        Node* node=q.top();q.pop();</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val==root-&gt;val)&#123;</span><br><span class="line">            res.push_back(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Node* n:node-&gt;next)&#123;</span><br><span class="line">            n-&gt;val+=(node-&gt;val/(node-&gt;next.size()));</span><br><span class="line">            n-&gt;in--;</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;in==<span class="number">0</span>)</span><br><span class="line">                q.push(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &gt; b</span><br><span class="line">  /  |&gt;  \&gt;</span><br><span class="line">a -&gt; d -&gt; e</span><br><span class="line">  \&gt;</span><br><span class="line">    c</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie树</title>
    <url>/2019/10/25/Trie%E6%A0%91/</url>
    <content><![CDATA[<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p><img src="/2019/10/25/Trie%E6%A0%91/trie.jpg" alt="avatar"></p>
<a id="more"></a>
<h2 id="Trie树的search"><a href="#Trie树的search" class="headerlink" title="Trie树的search"></a>Trie树的search</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        TrieNode():isWord(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a:child) </span><br><span class="line">                a=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool search(word,node,i):</span><br><span class="line">    <span class="keyword">if</span> i==word.size:</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isWord</span><br><span class="line">    <span class="keyword">if</span> word[i]!=<span class="string">'.'</span>:  <span class="comment">//正常字符当前存在则判断下一层</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;child[word[i]-<span class="string">'a'</span>] &amp;&amp; search(word,node-&gt;child[word[i]-<span class="string">'a'</span>],i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>：  <span class="comment">//特殊字符时，则遍历当前子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a:node-&gt;child)&#123;</span><br><span class="line">            <span class="keyword">if</span> a <span class="keyword">and</span> search(word,a,i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>字符串匹配，两个字符串的问题，二位数组的最值问题等。故将字符串问题也写入DP</p>
<a id="more"></a>
<h2 id="矩阵问题"><a href="#矩阵问题" class="headerlink" title="矩阵问题"></a>矩阵问题</h2><p>DFS,BFS，$N^2$技巧遍历</p>
<h3 id="最大子数组和，最大子矩阵和——扩增"><a href="#最大子数组和，最大子矩阵和——扩增" class="headerlink" title="最大子数组和，最大子矩阵和——扩增"></a>最大子数组和，最大子矩阵和——扩增</h3><blockquote>
<blockquote>
<p>网易</p>
</blockquote>
</blockquote>
<p><img src="/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/subMat.png" alt="avatar"><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;-1， 4， 6， -3， 7， -3， -3， 9&#125;</span></span><br><span class="line"><span class="keyword">int</span> nums[M+<span class="number">1</span>][N+<span class="number">1</span>],b[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//解决子序列最大和，同时输出得到最大子数组的起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=curSum=nums[j][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> L, R, pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums[j].size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>)</span><br><span class="line">            curSum = nums[j][i], pos = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            curSum += nums[j][i];</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; res)</span><br><span class="line">            res = curSum, L = pos, R = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; L &lt;&lt; <span class="string">','</span> &lt;&lt; R &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//连续下标</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res; <span class="comment">//最大子序列和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;<span class="comment">//从第i行开始累加到最后一行</span></span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=M;j++)<span class="comment">//开始累加</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">                b[j][k]=nums[j][k]+b[j<span class="number">-1</span>][k];</span><br><span class="line">            &#125;</span><br><span class="line">            solve(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="求取子矩阵的和——扩增"><a href="#求取子矩阵的和——扩增" class="headerlink" title="求取子矩阵的和——扩增"></a>求取子矩阵的和——扩增</h3><blockquote>
<blockquote>
<p>给定位置得到和</p>
<ul>
<li>加和</li>
</ul>
</blockquote>
</blockquote>
<p><img src="/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/sumMat.png" alt></p>
<ul>
<li>得到子矩阵的和</li>
</ul>
<p><img src="/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/sumMat2.png" alt><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(nums.size()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums[<span class="number">0</span>].size()+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[<span class="number">0</span>].size(); ++j)&#123;</span><br><span class="line">            <span class="comment">//上+左-到[i-1,j-1]的重复路径+本地元素</span></span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + nums[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[m + <span class="number">1</span>][n + <span class="number">1</span>] - dp[i][n + <span class="number">1</span>] - dp[m + <span class="number">1</span>][j] + dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大正方形——扩增"><a href="#最大正方形——扩增" class="headerlink" title="最大正方形——扩增"></a>最大正方形——扩增</h3><blockquote>
<blockquote>
<p>由0-1构成的矩阵，找到1构成的最大正方形</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[m+<span class="number">1</span>][n+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//以当前为右下角构成的正方形，最小边长</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i][j]==<span class="string">'1'</span>)</span><br><span class="line">            dp[i][j]=min(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">        res=max(res,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res*res;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵的最小（大）路径和——扩增"><a href="#矩阵的最小（大）路径和——扩增" class="headerlink" title="矩阵的最小（大）路径和——扩增"></a>矩阵的最小（大）路径和——扩增</h3><p><img src="/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/mat.png" alt><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空间O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums.size();</span><br><span class="line">    <span class="keyword">int</span> n = nums[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">int</span> res[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">                up = res[j];</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">                left = res[j - <span class="number">1</span>];</span><br><span class="line">            res[j] = min(left, up) + nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h3><blockquote>
<blockquote>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((i != <span class="number">0</span> &amp;&amp; i != m - <span class="number">1</span> &amp;&amp; j != <span class="number">0</span> &amp;&amp; j != n - <span class="number">1</span>) || (board[i][j] != <span class="string">'O'</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        board[i][j]==<span class="string">'$'</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;q&#123;&#123;i,j&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            pair&#123;x,y&#125; = q.front();q.pop();</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">1</span> &amp;&amp; board[x - <span class="number">1</span>][y] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                board[x - <span class="number">1</span>][y] = <span class="string">'$'</span>;</span><br><span class="line">                q.push(&#123;x<span class="number">-1</span>,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; m - <span class="number">1</span> &amp;&amp; board[x + <span class="number">1</span>][y] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                board[x + <span class="number">1</span>][y] = <span class="string">'$'</span>;</span><br><span class="line">                q.push(&#123;x+<span class="number">1</span>,y&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &gt;= <span class="number">1</span> &amp;&amp; board[x][y - <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                board[x][y - <span class="number">1</span>] = <span class="string">'$'</span>;</span><br><span class="line">                q.push(&#123;x,y<span class="number">-1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y &lt; n - <span class="number">1</span> &amp;&amp; board[x][y + <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                board[x][y + <span class="number">1</span>] = <span class="string">'$'</span>;</span><br><span class="line">                q.push(&#123;x,y+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) </span><br><span class="line">            board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'$'</span>) </span><br><span class="line">            board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//'O'-&gt;'X'</span></span><br><span class="line"><span class="comment">//'$'-&gt;'O'</span></span><br></pre></td></tr></table></figure>
<h3 id="最大矩形"><a href="#最大矩形" class="headerlink" title="最大矩形"></a>最大矩形</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到连续1的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) </span><br><span class="line">            h_max[i][j] = h_max[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            h_max[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h_max[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mn = h_max[i][j];</span><br><span class="line">        <span class="comment">//高度为1时是否最大</span></span><br><span class="line">        res = max(res, mn);</span><br><span class="line">        <span class="comment">//往上取各行最小长度再乘以高度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span> &amp;&amp; h_max[k][j] != <span class="number">0</span>; --k) &#123;</span><br><span class="line">            mn = min(mn, h_max[k][j]);</span><br><span class="line">            res = max(res, mn * (i - k + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维矩阵的搜索——剑指offer"><a href="#二维矩阵的搜索——剑指offer" class="headerlink" title="二维矩阵的搜索——剑指offer"></a>二维矩阵的搜索——剑指offer</h3><p>右上角出发：O(M+N)<br>二分：O(logM+logN)<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//列二分，核心判断在哪一行通过mid和mid+1</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">    <span class="keyword">int</span> j, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid][<span class="number">0</span>] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid + <span class="number">1</span>][<span class="number">0</span>] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j = mid;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = nums[<span class="number">0</span>].size();</span><br><span class="line">    <span class="comment">//对j行再进行二分</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[j][mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[j][mid] &gt; target) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="矩阵最小乘次"><a href="#矩阵最小乘次" class="headerlink" title="矩阵最小乘次"></a>矩阵最小乘次</h3><blockquote>
<blockquote>
<p>n^3复杂度：确定长度step；遍历所有可能窗口；在该窗口下找分割点；</p>
</blockquote>
</blockquote>
<ul>
<li>矩阵=AxBxCxDxExFxG</li>
<li>维度列表=d[a,b,c,d,e,f,g]</li>
<li>维度=[a,b]x[b,c]x[c,d]x[d,e]x[f,g]</li>
<li>矩阵相乘mat[i][i+1]</li>
<li>对应维度:d[i]<em>d[i+1] x d[i+1] </em>d[i+2]</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m[i][j];<span class="comment">//第i个矩阵到第j个矩阵的最少乘次</span></span><br><span class="line">p[i][j];<span class="comment">//从i到j中间乘以矩阵k</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    m[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> step=<span class="number">1</span>;step&lt;=n<span class="number">-1</span>;step++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-step;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+step;</span><br><span class="line">        <span class="comment">//确定从矩阵i-&gt;矩阵j；类似F算法从中间找k使得[i,k]*[k,j]最小</span></span><br><span class="line">        <span class="keyword">int</span> minx=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;=j<span class="number">-1</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((m[i][k]+m[k+<span class="number">1</span>][j]+d[i]*d[k+<span class="number">1</span>]*d[j+<span class="number">1</span>])&lt; minx)</span><br><span class="line">                minx=m[i][k]+m[k+<span class="number">1</span>][j]+d[i]*d[k+<span class="number">1</span>]*d[j+<span class="number">1</span>];</span><br><span class="line">                p[i][j]=k;</span><br><span class="line">        &#125;</span><br><span class="line">        m[i][j]=minx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;m[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//最少乘法次数</span></span><br></pre></td></tr></table></figure>
<h2 id="二维动规：字符串"><a href="#二维动规：字符串" class="headerlink" title="二维动规：字符串"></a>二维动规：字符串</h2><h3 id="最长公共子序列——扩增"><a href="#最长公共子序列——扩增" class="headerlink" title="最长公共子序列——扩增"></a>最长公共子序列——扩增</h3><p><img src="/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2DP.png" alt="avatar"></p>
<blockquote>
<blockquote>
<p>dp[i,j]表示前面s1的i个,s2的j个字符的LCS</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>])</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对dp数组回溯得到子序列</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(dp[m][n])</span></span>;</span><br><span class="line">i= res.length()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span> &amp;&amp; dp[m][n] == dp[m][n<span class="number">-1</span>])<span class="comment">//同左</span></span><br><span class="line">        n--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m&gt;<span class="number">0</span> &amp;&amp; dp[m][n] == dp[m<span class="number">-1</span>][n])<span class="comment">//同上</span></span><br><span class="line">        m--;</span><br><span class="line">    <span class="keyword">else</span>&#123;   <span class="comment">//同斜上，则赋值</span></span><br><span class="line">        res[i--] = s1[m];</span><br><span class="line">        m--;n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">匹配<span class="number">0</span>次\</span><br><span class="line">e b c\</span><br><span class="line">e a * b c \</span><br><span class="line">匹配<span class="number">1</span>次\</span><br><span class="line">e a a b c\</span><br><span class="line">e a * b c</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt; <span class="keyword">bool</span> &gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="comment">//从1开始是因为考虑到*的存在会影响j的状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                        <span class="comment">//0次                   多次                                          前面都已匹配</span></span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>] || p[j - <span class="number">2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前值相同且前面都已匹配</span></span><br><span class="line">            dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br></pre></td></tr></table></figure>
<h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = min(strs[<span class="number">0</span>].size(), strs.back().size());</span><br><span class="line"><span class="keyword">while</span> (i &lt; len &amp;&amp; strs[<span class="number">0</span>][i] == strs.back()[i]) </span><br><span class="line">    ++i;</span><br><span class="line"><span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br></pre></td></tr></table></figure>
<h3 id="构造最长回文子串"><a href="#构造最长回文子串" class="headerlink" title="构造最长回文子串"></a>构造最长回文子串</h3><blockquote>
<blockquote>
<p>对于给定字符串构造回文串，返回其最大长度</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt; <span class="keyword">char</span> &gt; t;<span class="comment">//只要set不为空则就有单独存在的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!t.count(c))</span><br><span class="line">            t.insert(c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t.erase(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.size();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.size()-t.size()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证回文子串"><a href="#验证回文子串" class="headerlink" title="验证回文子串"></a>验证回文子串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLetterOrDigit(s[l]])) </span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!isLetterOrDigit(s[r]))</span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (lower(s[l]) != lower(s[r]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出最长回文串"><a href="#找出最长回文串" class="headerlink" title="找出最长回文串"></a>找出最长回文串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index, len;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++)</span><br><span class="line">        helper(s, i, i);</span><br><span class="line">        helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> s.substr(index, index + len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s[l] == s[r])</span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; r - l - <span class="number">1</span>)</span><br><span class="line">        index = l + <span class="number">1</span>;</span><br><span class="line">        len = r - l - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p><img src="/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lcs.png" alt="avatar"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//翻转得到两个字符串然后求LCS，实际上只计算上三角</span></span><br><span class="line"><span class="comment">//dp[i,j]代表[i,j]间最长回文序列长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)&#123;<span class="comment">//从后往前倒序</span></span><br><span class="line">    dp[i][i]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt; n;j++)&#123;<span class="comment">//从当前往后正序</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;<span class="comment">//左斜下位置+2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);<span class="comment">//左和下的最大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>,n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="最小编辑距离——扩增"><a href="#最小编辑距离——扩增" class="headerlink" title="最小编辑距离——扩增"></a>最小编辑距离——扩增</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//空字符到当前w1的某个字符的编辑距离是长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">    dp[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)<span class="comment">//同上</span></span><br><span class="line">    dp[<span class="number">0</span>][i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">//字符相等，则当前编辑距离等于上一位置，也就是左上方</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + <span class="number">1</span>;<span class="comment">//不相等则左，上，左上的最小+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m][n];</span><br></pre></td></tr></table></figure>
<h2 id="一维动规：数组-典型子问题"><a href="#一维动规：数组-典型子问题" class="headerlink" title="一维动规：数组-典型子问题"></a>一维动规：数组-典型子问题</h2><h3 id="循环数字最后"><a href="#循环数字最后" class="headerlink" title="循环数字最后"></a>循环数字最后</h3><p>f(n-1)+m %  n\<br>去除数字后，再次映射0—n-1；p(x)=(x-k-1)%m;逆映射p-1(x)=(x+k+1)%m;k=(m-1)%n;k+1=(m-1)%n+1=m</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//长度为n的圈，删除第m个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        last = (last + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最少加油次数-贪心"><a href="#最少加油次数-贪心" class="headerlink" title="最少加油次数-贪心"></a>最少加油次数-贪心</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">stations.push_back(&#123;target,<span class="number">0</span>&#125;);<span class="comment">//加入终点,station&#123;里程，可加油量&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> station:stations)&#123;</span><br><span class="line">    <span class="keyword">while</span>(cur&lt; station[<span class="number">0</span>])&#123;<span class="comment">//到达不了此处，加油。</span></span><br><span class="line">        <span class="keyword">if</span>(q.empty()):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        cur+=q.top();q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//到达后入堆</span></span><br><span class="line">    q.push(station[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> stations.size()-q.size();</span><br></pre></td></tr></table></figure>
<h3 id="第N个丑数——累加"><a href="#第N个丑数——累加" class="headerlink" title="第N个丑数——累加"></a>第N个丑数——累加</h3><blockquote>
<blockquote>
<p>给定几个数定义为丑数，所有的数都是基于丑数的累乘。<br>brute force：第n个丑数；每个丑数累乘到之前，取大于dp[n-1]的最小的那个值。如果记住了丑数累乘到了第几个数，那么可以从当前累乘去比较，因为之前的一定太小。就略过。<strong>故idx[i]保存第i个ugly丑数，这一次应该要累成到哪个已形成的dp[idx[i]]丑数上</strong><br>2,7,13,19</p>
</blockquote>
</blockquote>
<p><img src="/2019/10/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/ugly.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx(ugly.size(), <span class="number">0</span>);<span class="comment">//该丑数应该乘到哪个丑数上</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt; n;i++)&#123;</span><br><span class="line">    dp[i]=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; ugly.size();j++)</span><br><span class="line">        <span class="comment">//丑数后累乘</span></span><br><span class="line">        dp[i] = min(dp[i], ugly[j] * dp[idx[j]]);</span><br><span class="line">    <span class="comment">//标记基础丑数乘了几次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt; ugly.size();j++)</span><br><span class="line">        <span class="keyword">if</span> dp[i] == dp[idx[j]] * ugly[j]</span><br><span class="line">            idx[j]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="等差递增子区间个数——累加"><a href="#等差递增子区间个数——累加" class="headerlink" title="等差递增子区间个数——累加"></a>等差递增子区间个数——累加</h3><blockquote>
<blockquote>
<p>新的区间个数是之前基础+1，最后再累加</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">dp[<span class="number">3</span>] = dp[<span class="number">2</span>] + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment">// [0, 1, 2] 之后加一个 3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]     <span class="comment">// 新的递增子区间</span></span><br><span class="line">dp[<span class="number">4</span>] = dp[<span class="number">3</span>] + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="comment">// [0, 1, 2, 3] 之后加一个 4</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],    <span class="comment">// [1, 2, 3] 之后加一个 4</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]        <span class="comment">// 新的</span></span><br><span class="line"><span class="keyword">int</span> numberOfArithmeticSlices(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] - nums[i - <span class="number">1</span>] == nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>])</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=sum(dp);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大乘积子序列——累加"><a href="#最大乘积子序列——累加" class="headerlink" title="最大乘积子序列——累加"></a>最大乘积子序列——累加</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = nums[<span class="number">0</span>], mx = res, mn = res;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;<span class="comment">//当前为正，则比较乘之前最大和最小</span></span><br><span class="line">        mx = max(mx * nums[i], nums[i]);</span><br><span class="line">        mn = min(mn * nums[i], nums[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> t = mx;<span class="comment">//当前为负，最大是最小乘和当前相比；最小是当前最大乘和当前相比</span></span><br><span class="line">        mx = max(mn * nums[i], nums[i]);</span><br><span class="line">        mn = min(t * nums[i], nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res = max(res, mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分割整数使得乘积最大——子问题重复"><a href="#分割整数使得乘积最大——子问题重复" class="headerlink" title="分割整数使得乘积最大——子问题重复"></a>分割整数使得乘积最大——子问题重复</h3><blockquote>
<blockquote>
<p>显然子问题重复: dp[i]=max(dp[i],max(j<em>(i-j),j</em>dp[i-j]));10=3+3+4</p>
</blockquote>
</blockquote>
<h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>);</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="comment">//直接分割相乘大 还是 子问题的值更大</span></span><br><span class="line">        dp[i] = max(dp[i], max(j * dp[i - j], j * (i - j)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br></pre></td></tr></table></figure>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//3的个数</span></span><br><span class="line">    <span class="keyword">int</span> timesOf3 = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        timesOf3 -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2的个数</span></span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>, timesOf3)*<span class="built_in">pow</span>(<span class="number">2</span>, timesOf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分割整数为平方数加和——子问题重复"><a href="#分割整数为平方数加和——子问题重复" class="headerlink" title="分割整数为平方数加和——子问题重复"></a>分割整数为平方数加和——子问题重复</h3><blockquote>
<blockquote>
<p>dp[i]代表i可以最少分为多少个平方数加和</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; squareList = generateSquareList(n);<span class="comment">//1,4,9,16,25,,,</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> square : squareList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (square &gt; i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dp[i] = min(dp[i], dp[i - square] + <span class="number">1</span>);<span class="comment">//与已解决子问题比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br></pre></td></tr></table></figure>
<h3 id="26字母编码解码种类数——累加"><a href="#26字母编码解码种类数——累加" class="headerlink" title="26字母编码解码种类数——累加"></a>26字母编码解码种类数——累加</h3><blockquote>
<blockquote>
<p>dp[i]代表[0,i-1]范围内可构成的次数</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = s[<span class="number">0</span>]==<span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先保留之前种类数</span></span><br><span class="line">        <span class="keyword">if</span> (atoi(s.substr(i - <span class="number">1</span>, i)) != <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再判断是否能组成两位数的编码</span></span><br><span class="line">        <span class="keyword">if</span> (s[i<span class="number">-2</span>]== <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果能则加上之前的种类数dp[i-2]</span></span><br><span class="line">        <span class="keyword">if</span> (atoi(s.substr(i<span class="number">-2</span>, i)) &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长摆动子序列-返回摆动次数-——累加"><a href="#最长摆动子序列-返回摆动次数-——累加" class="headerlink" title="最长摆动子序列[返回摆动次数]——累加"></a>最长摆动子序列[返回摆动次数]——累加</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        up = down + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        down = up + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max(up, down);</span><br></pre></td></tr></table></figure>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组元素加正负使其总和为target，返回次数。——累加"><a href="#数组元素加正负使其总和为target，返回次数。——累加" class="headerlink" title="数组元素加正负使其总和为target，返回次数。——累加"></a>数组元素加正负使其总和为target，返回次数。——累加</h3><blockquote>
<blockquote>
<p>dp[value]代表累加到此值的次数</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = sum(nums);</span><br><span class="line"><span class="keyword">int</span> value = (sum + target) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(value + <span class="number">1</span>);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">    <span class="comment">//累加上数值(i-num)加上num到达i的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = value; i &gt;= num; i--)</span><br><span class="line">        dp[i] = dp[i] + dp[i - num];</span><br><span class="line"><span class="keyword">return</span> dp[value];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2019/10/25/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="搜索回溯"><a href="#搜索回溯" class="headerlink" title="搜索回溯"></a>搜索回溯</h1><p>采用DFS：递归+回溯；BFS：队列</p>
<h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS+递归"></a>DFS+递归</h2><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mark[i][j]==<span class="number">0</span> &amp;&amp; grid[i][j]==<span class="string">'1'</span>)</span><br><span class="line">            DFS(mark,grid,i,j);</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(&amp; mark,&amp; grid,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    mark[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x_=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> y_=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(x_&lt;<span class="number">0</span>||x_&gt;=mark.size()||y_&lt;<span class="number">0</span>||y_&gt;=mark[x_].size())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark[x_][y_]==<span class="number">0</span> &amp;&amp; grid[x_][y_]==<span class="string">'1'</span>)&#123;</span><br><span class="line">            DFS(mark,grid,x_,y_);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="BFS-队列"><a href="#BFS-队列" class="headerlink" title="BFS+队列"></a>BFS+队列</h2><h3 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">word_set(wordList.begin(),wordList.end())</span><br><span class="line">q&#123;beginWord&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    word=q.top();q.pop()</span><br><span class="line">    <span class="keyword">if</span>(word==endWord)</span><br><span class="line">        <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(inti i=<span class="number">0</span>;i&lt; word.size();i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> bak=word;</span><br><span class="line">        <span class="comment">//替换26字符，将可能的下一层可替换单词入队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:a~z)&#123;</span><br><span class="line">            bak[i]=ch;</span><br><span class="line">            <span class="keyword">if</span>(word_set.count(bak) &amp;&amp; bak!=word)</span><br><span class="line">                q.push(bak);</span><br><span class="line">                word_set.erase(bak);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="朋友圈"><a href="#朋友圈" class="headerlink" title="朋友圈"></a>朋友圈</h3><p>通过BFS，将相关的人都标记，标记完作为一个朋友圈，res++;如果不标记会有重复，且一个人必定属于某个朋友圈故用一维标记即可<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = M.size(), res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        q.push(i);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = q.front(); q.pop();</span><br><span class="line">            visited[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!M[t][j] || visited[j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="字符串在矩阵的路径"><a href="#字符串在矩阵的路径" class="headerlink" title="字符串在矩阵的路径"></a>字符串在矩阵的路径</h3><p>字符串能够在矩阵中找到一条路径<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(vecctor&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;matrix,<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows=matrix.size(),cols=matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">bool</span> visited[rows][cols];</span><br><span class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(DFS(matrix, i, j, str, pathLength, visited))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(vecctor&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">string</span> str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span> visited[][])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[pathLength] == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows=matrix.size();</span><br><span class="line">    <span class="keyword">int</span> cols=matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; matrix[row][col] == str[pathLength] &amp;&amp; !visited[row][col]&#123;</span><br><span class="line">        ++pathLength;</span><br><span class="line">        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        hasPath = DFS(matrix, row, col - <span class="number">1</span>,str, pathLength, visited)</span><br><span class="line">            || DFS(matrix, row - <span class="number">1</span>, col,str, pathLength, visited)</span><br><span class="line">            || DFS(matrix, row, col + <span class="number">1</span>,str, pathLength, visited)</span><br><span class="line">            || DFS(matrix, row + <span class="number">1</span>, col,str, pathLength, visited);</span><br><span class="line">        <span class="keyword">if</span>(!hasPath)&#123;</span><br><span class="line">            --pathLength;</span><br><span class="line">            visited[row][col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="摆放火柴"><a href="#摆放火柴" class="headerlink" title="摆放火柴"></a>摆放火柴</h3><p>整体遍历的是火柴，但需要回溯故pos为火柴的下标；火柴需要排序，先放大的；还需要判断火柴和是否为4的倍数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; sums, <span class="keyword">int</span> pos, <span class="keyword">int</span> target)</span></span></span><br><span class="line">    如果pos到末尾判断sums数组是否都为target；</span><br><span class="line">    遍历<span class="number">4</span>个边长：</span><br><span class="line">        如果当前边长+当前火柴&gt;target，则继续观察后面的边长；如果&lt;=target，则加上当前火柴；去遍历下一个火柴；</span><br><span class="line">        <span class="keyword">if</span>(helper(pos+<span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        否则回溯当前边长-当前火柴，有可能当前火柴不够</span><br></pre></td></tr></table></figure>
<h3 id="n括号"><a href="#n括号" class="headerlink" title="n括号"></a>n括号</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//括号验证</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c:str)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="string">'('</span>)</span><br><span class="line">        s.push(c);</span><br><span class="line">    <span class="keyword">else</span>(c==<span class="string">')'</span>)</span><br><span class="line">        s.pop();</span><br><span class="line"><span class="keyword">return</span> s.empty();</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n括号可能组合</span></span><br><span class="line">generate(item,left,right,res)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>)</span><br><span class="line">        res.push_back(item);</span><br><span class="line">    <span class="keyword">if</span>(left&gt;<span class="number">0</span>)</span><br><span class="line">        generate(item+<span class="string">'('</span>,left<span class="number">-1</span>,right,res);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(right&gt;<span class="number">0</span>)</span><br><span class="line">        generate(item+<span class="string">')'</span>,left,right<span class="number">-1</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="n皇后"><a href="#n皇后" class="headerlink" title="n皇后"></a>n皇后</h3><p><img src="/2019/10/25/%E6%90%9C%E7%B4%A2/nq1.png" alt="avatat"><br><img src="/2019/10/25/%E6%90%9C%E7%B4%A2/nq2.png" alt="avatat"><br><img src="/2019/10/25/%E6%90%9C%E7%B4%A2/nq3.png" alt="avatat"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2019/10/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>使用二分的前提是给定链表或数组是有序的；在此基础上的变形比如排序树组旋转；两个有序数组的中位数</p>
<hr>
<a id="more"></a>
<h3 id="二分查找实现寻找重复数"><a href="#二分查找实现寻找重复数" class="headerlink" title="二分查找实现寻找重复数"></a>二分查找实现寻找重复数</h3><p>循环排序改变了原数组，O(N)，二分查找O(N*logN)</p>
<blockquote>
<blockquote>
<p>start,middle,end范围在：0、1、2、3、4、5、6.对区间二分</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="keyword">if</span> (numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)</span><br><span class="line">            ++count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *numbers, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &gt;= start) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (end + start)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = countRange(numbers, length, start, middle);</span><br><span class="line">        <span class="keyword">if</span> (end == start) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//该范围有重数</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; (middle - start + <span class="number">1</span>))</span><br><span class="line">            end = middle;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            start = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有序数组某数字的出现次数"><a href="#有序数组某数字的出现次数" class="headerlink" title="有序数组某数字的出现次数"></a>有序数组某数字的出现次数</h2><blockquote>
<blockquote>
<p>两次二分查找下标相减</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">float</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; num)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; num)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> biSearch(nums, target + <span class="number">0.5f</span>) - biSearch(nums, target - <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旋转数组的搜索target"><a href="#旋转数组的搜索target" class="headerlink" title="旋转数组的搜索target"></a>旋转数组的搜索target</h2><blockquote>
<blockquote>
<p>含重复元素</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[mid]==target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num[mid] &gt; num[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[left] &lt;= target &lt; num[mid])</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num[mid] &lt; num[right])&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] &lt; target &lt;= num[right])</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        right--;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h2 id="旋转数组找min"><a href="#旋转数组找min" class="headerlink" title="旋转数组找min"></a>旋转数组找min</h2><blockquote>
<blockquote>
<p>（含重复元素）</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>, res = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">        res = min(res, nums[left]);</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">        res = min(res, nums[right]);</span><br><span class="line">        right = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        ++left;</span><br><span class="line">&#125;</span><br><span class="line">res = min(res, nums[left]，nums[right]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h2 id="寻找两个有序数组中位数"><a href="#寻找两个有序数组中位数" class="headerlink" title="寻找两个有序数组中位数"></a>寻找两个有序数组中位数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">    <span class="keyword">int</span> left = (m + n + <span class="number">1</span>) / <span class="number">2</span>, right = (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= nums1.size()) </span><br><span class="line">        <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= nums2.size()) </span><br><span class="line">        <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> min(nums1[i], nums2[j]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> m1 = (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.size()) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> m2 = (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.size()) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : INT_MAX;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (m1 &lt; m2) &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, i + k / <span class="number">2</span>, nums2, j, k - k / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="number">2</span>, k - k / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><p>3-2-4-1<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对数组nums倒序构造vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Node*&gt;node;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--;)&#123;</span><br><span class="line">    node.push_back(<span class="keyword">new</span> Node(nums[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; node.size();i++;)&#123;</span><br><span class="line">    count_small=<span class="number">0</span>;</span><br><span class="line">    BST_insert(node[<span class="number">0</span>],node[i],count_small); <span class="comment">//递归</span></span><br><span class="line">    tmp.push_back(count_small);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(tmp.rbegin(),tmp.rend());</span><br><span class="line"><span class="comment">/*****************************************************/</span></span><br><span class="line"><span class="comment">//二叉搜索树的插入操作：</span></span><br><span class="line">BST_insert(root,node,count_small)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;val&lt;root-&gt;val)&#123;</span><br><span class="line">        root-&gt;count++;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            BST_insert(root-&gt;left,node,count_small);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;left=node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        count_small+=(root-&gt;count+<span class="number">1</span>);<span class="comment">//count_small记录比待插入节点的小个数，因为是倒序插入的</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            BST_insert(root-&gt;right,node,count_small);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;right=node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="山脉三题"><a href="#山脉三题" class="headerlink" title="山脉三题"></a>山脉三题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断山峰</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == null || A.size() &lt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = A.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[l] &lt; A[l + <span class="number">1</span>])</span><br><span class="line">            l++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[r] &lt; A[r - <span class="number">1</span>])</span><br><span class="line">            r--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l &gt; <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; l == r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找峰顶</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = A.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; A[mid - <span class="number">1</span>] &amp;&amp; A[mid] &lt; A[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最长山脉-上下长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, up = <span class="number">0</span>, down = <span class="number">0</span>, n = A.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((down &amp;&amp; A[i - <span class="number">1</span>] &lt; A[i]) || (A[i - <span class="number">1</span>] == A[i])) &#123;</span><br><span class="line">            up = down = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i]) ++up;</span><br><span class="line">        <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i]) ++down;</span><br><span class="line">        <span class="keyword">if</span> (up &gt; <span class="number">0</span> &amp;&amp; down &gt; <span class="number">0</span>) res = max(res, up + down + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找最长山脉-左右索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, n = A.size();<span class="keyword">int</span> l,r</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i] &amp;&amp; A[i + <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; A[left - <span class="number">1</span>] &lt; A[left]) --left;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; A[right] &gt; A[right + <span class="number">1</span>]) ++right;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span>&gt;res)&#123;</span><br><span class="line">                res=right-left+<span class="number">1</span>;</span><br><span class="line">                l=left;</span><br><span class="line">                r=right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两种方法复杂度分析：上下长度：不能得到左右下标，仅能通过长度相加得到山脉长度；左右索引：通过索引得到长度。</span></span><br></pre></td></tr></table></figure>
<p>上下长度：O(N)时间；<br>左右索引：峰的个数m；平均峰的长度为n/m；所以每个峰在while中循环n/m次。最终复杂度也为O(N)。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2019/10/25/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h1><p>要明确的问题在于，递归+回溯得到所有子集，就是指数级复杂度，等同于brute force。将子集问题变为迭代问题，并且保证结果无重复子集。</p>
<hr>
<h2 id="对数组取子集"><a href="#对数组取子集" class="headerlink" title="对数组取子集"></a>对数组取子集</h2><p>包含重复元素<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">res=&#123;&#123;&#125;&#125;,last=s[<span class="number">0</span>];</span><br><span class="line">sort(nums.begin(),nums.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">    <span class="comment">//保存不重复起始位置，有重复则是之前的长度</span></span><br><span class="line">    <span class="keyword">if</span>(s[i]!=last)</span><br><span class="line">        last=s[i];</span><br><span class="line">        len=res.size();</span><br><span class="line">    <span class="comment">//如果有重复则赋值后一半，再添加元素；无重复则从头赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=res.size()-len;j&lt; res.size();j++) </span><br><span class="line">        res.push_back(s[j]);</span><br><span class="line">        res.back().push_back(s[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h2 id="字符串全排列"><a href="#字符串全排列" class="headerlink" title="字符串全排列"></a>字符串全排列</h2><p><img src="/2019/10/25/%E5%AD%90%E9%9B%86/permutation.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> ss = <span class="string">"abc"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == ss.length()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ss &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ch = i; ch &lt; ss.length(); ++ch) &#123;</span><br><span class="line">            swap(ss[ch], ss[i]);</span><br><span class="line">            generate(i + <span class="number">1</span>);</span><br><span class="line">            swap(ss[ch], ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">generate(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="对字符串取子集"><a href="#对字符串取子集" class="headerlink" title="对字符串取子集"></a>对字符串取子集</h2><p>转变大小写获得新的字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">res=&#123;<span class="string">""</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = res.size();</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> &amp;str : res) </span><br><span class="line">            str.push_back(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            res.push_back(res[i]);<span class="comment">//对当前备份</span></span><br><span class="line">            res[i].push_back(<span class="built_in">tolower</span>(c));<span class="comment">//对当前加小写</span></span><br><span class="line">            res.back().push_back(<span class="built_in">toupper</span>(c));<span class="comment">//对备份加大写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h2 id="移除K个数字使得值更小"><a href="#移除K个数字使得值更小" class="headerlink" title="移除K个数字使得值更小"></a>移除K个数字使得值更小</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">    <span class="comment">//从前往后，有比当前大的就替换。保证排在前面的更小</span></span><br><span class="line">    <span class="keyword">while</span> (k &amp;&amp; res.size() &amp;&amp; res.back() &gt; c)</span><br><span class="line">        res.pop_back();</span><br><span class="line">        --k;</span><br><span class="line">    <span class="keyword">if</span> (res.size()==<span class="number">0</span> &amp;&amp; c== <span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    res.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (res.size() &amp;&amp; k--) </span><br><span class="line">    res.pop_back();</span><br><span class="line"><span class="keyword">return</span> res.empty() ? <span class="string">"0"</span> : res;</span><br></pre></td></tr></table></figure>
<h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span> ss&#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">    <span class="keyword">auto</span> it = lower_bound(ss.begin(), ss.end(),num);<span class="comment">//二分查找该值</span></span><br><span class="line">    <span class="keyword">if</span> (it == ss.end())</span><br><span class="line">        ss.push(num);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        *it = num;<span class="comment">//替换该值</span></span><br><span class="line"><span class="keyword">return</span> ss.size();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2019/10/25/%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>维护一个堆一般是为了使用堆排序，减去反复排序步骤。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; big;  <span class="comment">//默认最大堆。</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vectot&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; small;  <span class="comment">//构造最小堆</span></span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p><img src="/2019/10/25/%E5%A0%86/640_50.gif" alt="avatar"><br>插入时间复杂度O(logN)，排序时间复杂度O(nlogn)<br>典型的问题是topK，免去反复排序的步骤，一直入堆自动完成排序。弹出头部。</p>
<h2 id="合并K个有序列表O-N-logk"><a href="#合并K个有序列表O-N-logk" class="headerlink" title="合并K个有序列表O(N*logk)"></a>合并K个有序列表O(N*logk)</h2><p>维护一个包含各链表头的最小堆<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cmp = [](ListNode*&amp; a, ListNode*&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp) &gt; q(cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> node : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node) q.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.top();q.pop();</span><br><span class="line">        cur-&gt;next = t;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next) </span><br><span class="line">            q.push(cur-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数据流中位数"><a href="#数据流中位数" class="headerlink" title="数据流中位数"></a>数据流中位数</h2><p>数据流或者数组获取中位数不知道有什么区别，感觉可以通用<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;left,right;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    right.push(num)</span><br><span class="line">    left.push(-right.top());right.pop();<span class="comment">//负右入左</span></span><br><span class="line">    <span class="keyword">if</span> right.size &lt; left.size</span><br><span class="line">        right.push(-left.top());left.pop();<span class="comment">//负左入右</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right.size()&gt;left.size())</span><br><span class="line">        <span class="keyword">return</span> right.top();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (right.top-left.top)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终保证，两个最小堆。左堆绝对值递增，但实数值是减小的（符合最小堆的定义）；右堆按照最小堆递减，实数值也是递减。</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2019/10/25/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="移除K个数字"><a href="#移除K个数字" class="headerlink" title="移除K个数字"></a>移除K个数字</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">int</span> n = num.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : num) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; res.size() &amp;&amp; res.back() &gt; c) &#123;</span><br><span class="line">            res.pop_back();</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前导0</span></span><br><span class="line">        <span class="keyword">if</span> (res.size() || c != <span class="string">'0'</span>)</span><br><span class="line">            res.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (res.size() &amp;&amp; k--)</span><br><span class="line">        res.pop_back();</span><br><span class="line">    <span class="keyword">return</span> res.empty() ? <span class="string">"0"</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="字符串翻转"><a href="#字符串翻转" class="headerlink" title="字符串翻转"></a>字符串翻转</h2><h3 id="翻转句子的单词"><a href="#翻转句子的单词" class="headerlink" title="翻转句子的单词"></a>翻转句子的单词</h3><p>整体翻转；分割单词再次翻转</p>
<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p>s1翻转，s2翻转，整体翻转</p>
<h2 id="不固定滑动窗口"><a href="#不固定滑动窗口" class="headerlink" title="不固定滑动窗口"></a>不固定滑动窗口</h2><h3 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h3><p>当有重复的时候左更新；不重复的时候窗口长度累加。所以O(N)的遍历即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">26</span>]=<span class="number">-1</span>,left=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    left=max(c[nums[i]-<span class="string">'a'</span>],left]); <span class="comment">//不是-1则重复</span></span><br><span class="line">    res=max(res,i-left);</span><br><span class="line">    c[nums[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<h3 id="最小包含T的排列的子串"><a href="#最小包含T的排列的子串" class="headerlink" title="最小包含T的排列的子串*"></a>最小包含T的排列的子串*</h3><p>包含其他字符<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s,t</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">126</span>]=<span class="number">0</span>;<span class="comment">//对t遍历统计c各字符次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    c[s[i]]--;</span><br><span class="line">    <span class="keyword">if</span> c[s[i]]&gt;=<span class="number">0</span>：<span class="comment">//说明属于子串t的字符</span></span><br><span class="line">        cnt++;</span><br><span class="line">    <span class="keyword">while</span>(cnt==t.size())&#123; <span class="comment">//子串可构成t；然后左侧右移取最小窗口</span></span><br><span class="line">        minLen=min(minLen,i-left+<span class="number">1</span>);</span><br><span class="line">        res=res.substr(left,minLen);</span><br><span class="line">        c[s[left]]++; <span class="comment">//从左往右不相关加上</span></span><br><span class="line">        <span class="keyword">if</span>(c[s[left]]&gt;<span class="number">0</span>) <span class="comment">//如果加的是相关字符则跳出</span></span><br><span class="line">            cnt--;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<h3 id="字符串包含另一子串的排列"><a href="#字符串包含另一子串的排列" class="headerlink" title="字符串包含另一子串的排列*"></a>字符串包含另一子串的排列*</h3><p>不包含其他字符<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c :t)</span><br><span class="line">    m[c]++;<span class="comment">//保存t中字符次数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; s.length();i++)&#123;</span><br><span class="line">    m[s[i]]--;</span><br><span class="line">    <span class="keyword">if</span>(m[s[i]]&lt;<span class="number">0</span>)&#123; <span class="comment">//说明此时没匹配对</span></span><br><span class="line">        <span class="keyword">while</span>(++m[left]!=<span class="number">0</span>) <span class="comment">//则对之前匹配对的再补上+1</span></span><br><span class="line">            left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (i-left+<span class="number">1</span>==t.size())<span class="comment">//窗口大小==t长度相同</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t.szie()==<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="替换K次字符后最长的重复字符构成的子串长度"><a href="#替换K次字符后最长的重复字符构成的子串长度" class="headerlink" title="替换K次字符后最长的重复字符构成的子串长度"></a>替换K次字符后最长的重复字符构成的子串长度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count,res,left=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; s.length();i++)&#123;</span><br><span class="line">    m[s[i]]++;</span><br><span class="line">    count=max(count,m[s[i]]);</span><br><span class="line">    <span class="keyword">while</span>(i-left+<span class="number">1</span> &gt; (count+k)) <span class="comment">//达到了最大长度，左边界右移</span></span><br><span class="line">        m[s[left]--;</span><br><span class="line">        left++;</span><br><span class="line">    res=max(res,i-left+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重复的DNA序列"><a href="#重复的DNA序列" class="headerlink" title="重复的DNA序列"></a>重复的DNA序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatedDnaSequences</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">    visited = set()</span><br><span class="line">    res = set()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s) - <span class="number">9</span>):</span><br><span class="line">        tmp = s[i:i+<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">in</span> visited:</span><br><span class="line">            res.add(tmp)</span><br><span class="line">        visited.add(tmp)</span><br><span class="line">    <span class="keyword">return</span> list(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2019/10/25/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="平生不识TwoSum，刷尽力扣也枉然"><a href="#平生不识TwoSum，刷尽力扣也枉然" class="headerlink" title="平生不识TwoSum，刷尽力扣也枉然"></a>平生不识TwoSum，刷尽力扣也枉然</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;1, 1, 2, 3, 4, 4, 4, 7, 7, 8, 9, 10&#125;,8</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        m[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[target - nums[i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target / <span class="number">2</span> &amp;&amp; m[nums[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            res.push_back(make_pair(nums[i], target - nums[i]));</span><br><span class="line">            m[target - nums[i]]--;</span><br><span class="line">            m[nums[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="连续子数组最大和"><a href="#连续子数组最大和" class="headerlink" title="连续子数组最大和"></a>连续子数组最大和</h3><blockquote>
<blockquote>
<p>最大和以及下标</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res=curSum=num[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> L, R, pos;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>)</span><br><span class="line">        curSum = nums[i], pos = i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        curSum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (curSum &gt; res)</span><br><span class="line">        res = curSum, L = pos, R = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; L &lt;&lt; <span class="string">','</span> &lt;&lt; R &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//连续下标</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res; <span class="comment">//最大子序列和</span></span><br></pre></td></tr></table></figure>
<h3 id="数组拼接成最小（大）数"><a href="#数组拼接成最小（大）数" class="headerlink" title="数组拼接成最小（大）数"></a>数组拼接成最小（大）数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递增排序，得到最小数；递减排序，得到最大数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> s1, <span class="keyword">int</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> to_string(s1) + to_string(s2) &lt; to_string(s2) + to_string(s1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minNums</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    sort(ss.begin(), ss.end(), compare);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ss[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组编解码"><a href="#数组编解码" class="headerlink" title="数组编解码"></a>数组编解码</h3><blockquote>
<blockquote>
<p>给定0~N-1的N个数，对编码后的数恢复原数据，进行解码<br>原数组B：3,1,2,0,4<br>编码后A：0,0,1,0,4</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mn = <span class="number">0</span>; mn &lt; N; mn++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i]-- == <span class="number">0</span>) &#123;</span><br><span class="line">            B[i] = mn;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缺失的第一个数"><a href="#缺失的第一个数" class="headerlink" title="缺失的第一个数"></a>缺失的第一个数</h3><h4 id="有序数组【二分】"><a href="#有序数组【二分】" class="headerlink" title="有序数组【二分】"></a>有序数组【二分】</h4><p>二分查找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字范围0~N-1和1~N（缺失的第一个正整数），改动</span></span><br><span class="line"><span class="comment">//1、判断条件num[mid]!=mid , num[mid]!=mid+1</span></span><br><span class="line"><span class="comment">//2、最后返回值return mid , return mid+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] != mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] == mid - <span class="number">1</span>)<span class="comment">//左邻是或者右邻，那么返回当前</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == nums.size())</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无序数组【循环排序】"><a href="#无序数组【循环排序】" class="headerlink" title="无序数组【循环排序】"></a>无序数组【循环排序】</h4><p>循环排序+遍历判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0~N-1  nums[i]!=nums[nums[i]]  数字对应位置</span></span><br><span class="line"><span class="comment">//1~N   nums[i]!=nums[nums[i]-1] 数字对应位置-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">            swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h3><h4 id="环的快慢指针实现寻找重复数"><a href="#环的快慢指针实现寻找重复数" class="headerlink" title="环的快慢指针实现寻找重复数"></a>环的快慢指针实现寻找重复数</h4><blockquote>
<blockquote>
<p>在下标范围内，对数值索引会得到一个环，环的起点就是重复数字；同有环链表。查找N+1个数字，范围在[1,N]</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    slow=num[slow];</span><br><span class="line">    fast=num[num[fast]];</span><br><span class="line">    <span class="keyword">if</span>(slow ==falst) <span class="comment">//在环中相遇</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">slow=head;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    slow=num[slow];</span><br><span class="line">    fast=num[fast];</span><br><span class="line">    <span class="keyword">if</span>(slow ==fast)  <span class="comment">//环中继续走，头开始走。走相同距离相遇即为起点</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br></pre></td></tr></table></figure>
<h4 id="循环排序实现寻找重复数"><a href="#循环排序实现寻找重复数" class="headerlink" title="循环排序实现寻找重复数"></a>循环排序实现寻找重复数</h4><blockquote>
<blockquote>
<p>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。N个数字都在[0,N-1]]的范围内。</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">    <span class="keyword">while</span>(nums[i] != i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[nums[i]])</span><br><span class="line">            *duplication = nums[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        swap(nums[i],nums[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分查找实现寻找重复数"><a href="#二分查找实现寻找重复数" class="headerlink" title="二分查找实现寻找重复数"></a>二分查找实现寻找重复数</h4><p><a href="./二分查找.md">二分查找</a></p>
<h3 id="数组中超过一半的数"><a href="#数组中超过一半的数" class="headerlink" title="数组中超过一半的数"></a>数组中超过一半的数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">half</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">            res = nums[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == res)</span><br><span class="line">            times++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            times--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!check(nums,res))</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组只出现一次的两个数"><a href="#数组只出现一次的两个数" class="headerlink" title="数组只出现一次的两个数"></a>数组只出现一次的两个数</h3><p>全异或后根据某位置为1，是1的异或到a；非1的异或到b</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">firstIndexOf1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    num = num &gt;&gt; index;</span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        res ^= nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index = firstIndexOf1(res);</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(nums[j], index))</span><br><span class="line">            num1 ^= nums[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num2 ^= nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="string">','</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组中数字出现n次，有个只出现1次"><a href="#数组中数字出现n次，有个只出现1次" class="headerlink" title="数组中数字出现n次，有个只出现1次"></a>数组中数字出现n次，有个只出现1次</h3><p>将二进制的0,1统计到长度为32的数组中，最后对n求余</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bitSum[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = nums[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span> (bit != <span class="number">0</span>)</span><br><span class="line">                bitSum[j] += <span class="number">1</span>;</span><br><span class="line">            bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h3><blockquote>
<blockquote>
<p>4,5,1,6,2,7,3,8  O(k*n)=O(n)</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = nums[start];</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="comment">//从右找小于key的值，赋给start</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> nums[end] &gt;= key)</span><br><span class="line">            end --;</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        <span class="comment">//从左找大于key的值，赋给end</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end <span class="keyword">and</span> nums[start] &lt;= key)</span><br><span class="line">            start ++;</span><br><span class="line">        nums[end] = nums[start];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key赋给start</span></span><br><span class="line">        nums[start] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;output;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = input.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(input,start,end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>)&#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(input,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input,start,end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">        output.push_back(input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组（数据流）中位数"><a href="#数组（数据流）中位数" class="headerlink" title="数组（数据流）中位数"></a>数组（数据流）中位数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">long</span>&gt; small, large;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    small.push(num);</span><br><span class="line">    large.push(-small.top());</span><br><span class="line">    small.pop();</span><br><span class="line">    <span class="keyword">if</span> (small.size() &lt; large.size()) &#123;</span><br><span class="line">        small.push(-large.top());</span><br><span class="line">        large.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> small.size() &gt; large.size() ? small.top() : <span class="number">0.5</span> * (small.top() - large.top());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h3><blockquote>
<blockquote>
<p>找到超过某个数量的数字</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> base=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]==base);</span><br><span class="line">        times++;</span><br><span class="line">    <span class="keyword">else</span>：</span><br><span class="line">        times--;</span><br><span class="line">    <span class="keyword">if</span>(times==<span class="number">0</span>)</span><br><span class="line">        base=nums[i];</span><br><span class="line">        times=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]==base)</span><br><span class="line">        count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count==num;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><h4 id="子序列和为sum"><a href="#子序列和为sum" class="headerlink" title="子序列和为sum"></a>子序列和为sum</h4><p>假定数字范围：1~sum</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; fun(<span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>,right = <span class="number">2</span>,curSum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="number">1</span> + target) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; mid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curSum == target)</span><br><span class="line">            res.push_back(make_pair(left, right));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (curSum &gt; target &amp;&amp; left &lt; mid) &#123;<span class="comment">//过大左移</span></span><br><span class="line">            curSum -= left;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (curSum == target)</span><br><span class="line">                res.push_back(make_pair(left, right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//过小右移</span></span><br><span class="line">        right++;</span><br><span class="line">        curSum += right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>一般窗口固定的话，就是一次移一个得到某个结果值</p>
<ul>
<li>Q1：何时将结果push到res?i-left&gt;=-1时此刻开始push第一个。</li>
<li>Q2：如何判断窗口后移之前最大值pop?保留的是下标，下标top()=i-k时pop掉。</li>
<li>Q3：期间有大的还要替换前面比它小的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双向队列保存当前最大值下标</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; nums.size();i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q.empty() &amp;&amp; q.front()&lt;=i-k)<span class="comment">//较大值窗口之外</span></span><br><span class="line">        q.pop_front();</span><br><span class="line">    <span class="keyword">while</span>(!q.empty() &amp;&amp; nums[i]&gt;q.back())</span><br><span class="line">        q.pop_back();</span><br><span class="line">    q.push(i);</span><br><span class="line">    <span class="keyword">if</span>(i-k&gt;=<span class="number">-1</span>)</span><br><span class="line">        res.push(q.front());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="滑动窗口中位数："><a href="#滑动窗口中位数：" class="headerlink" title="滑动窗口中位数："></a>滑动窗口中位数：</h4><p>直观的解法就是每个窗口排序取中位数。借用multiset，可重复的有序集合，mid指针始终指向中间位置；而且中间位置的元素也有技巧去唯一获取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms(nums.begin(), nums.begin() + k);<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">auto</span> mid = next(ms.begin(), k / <span class="number">2</span>);<span class="comment">//取当前中间或偏右位置</span></span><br><span class="line">res.push((*mid+*prev(mid,<span class="number">1</span>-k%<span class="number">2</span>))/<span class="number">2</span>);<span class="comment">//取当前中位数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = k;i&lt;nums.size(); ++i) &#123;</span><br><span class="line">    ms.insert(nums[i]);</span><br><span class="line">    <span class="comment">//新插入元素在左边</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; *mid)</span><br><span class="line">        --mid;</span><br><span class="line">    <span class="comment">//新删除元素在左边</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i - k] &lt;= *mid)</span><br><span class="line">        ++mid;</span><br><span class="line">    <span class="comment">//二分查找删除元素</span></span><br><span class="line">    ms.erase(ms.lower_bound(nums[i - k]));</span><br><span class="line">    res.push_back((*mid + *prev(mid,  <span class="number">1</span> - k % <span class="number">2</span>)) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两个索引满足下标差和数值差"><a href="#两个索引满足下标差和数值差" class="headerlink" title="两个索引满足下标差和数值差"></a>两个索引满足下标差和数值差</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span> <span class="keyword">int</span>&gt; m;<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i - j &gt; k)</span><br><span class="line">        m.erase(nums[j]);</span><br><span class="line">        j++;</span><br><span class="line">    <span class="comment">//寻找第一个大于等于(nums[i]-t)的数,小于的nums[i]的差的绝对值会大于t </span></span><br><span class="line">    <span class="keyword">auto</span> a = m.lower_bound((<span class="keyword">long</span> <span class="keyword">long</span>)nums[i] - t);</span><br><span class="line">    <span class="keyword">if</span> (a != m.end() &amp;&amp; <span class="built_in">abs</span>(a-&gt;first - nums[i]) &lt;= t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    m[nums[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="长度最小的子数组。和相同（双指针）"><a href="#长度最小的子数组。和相同（双指针）" class="headerlink" title="长度最小的子数组。和相同（双指针）"></a>长度最小的子数组。和相同（双指针）</h4><p>一直累加，当超过目标值时左边移动</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum,res,left;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">    sum+=nums[i];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=i &amp;&amp; sum&gt;=Target)&#123;</span><br><span class="line">        res=min(res,i-left+<span class="number">1</span>);</span><br><span class="line">        sum-=num[left];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res==INT_MAX?<span class="number">0</span>:res;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="行列递增数组的查找-最最最优"><a href="#行列递增数组的查找-最最最优" class="headerlink" title="行列递增数组的查找-最最最优"></a>行列递增数组的查找-最最最优</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()==<span class="number">0</span> || nums[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//列二分，核心判断在哪一行通过mid和mid+1</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">    <span class="keyword">int</span> j, mid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid][<span class="number">0</span>] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid+<span class="number">1</span> &lt; nums.size() &amp;&amp; nums[mid + <span class="number">1</span>][<span class="number">0</span>] &gt; target)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    j = mid;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = nums[<span class="number">0</span>].size();</span><br><span class="line">    <span class="comment">//对j行再进行二分</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[j][mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[j][mid] &gt; target) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2019/10/25/%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>对于树的问题，<strong>涉及两个或多个问题则考虑最终使用哪一种遍历方式解决</strong><br>默认对树的层数定义为： 1,2,3,4……k……h  总结点数N；度为0：n0，度为1：n1，度为2：n2</p>
<ul>
<li>性质1: 树的第 k 层至多有$2^{k-1}$个节点</li>
<li>性质2: 树深度为 n ，总结点数至多$2^{n}-1$</li>
<li>性质3: 叶节点数$n_0$，度数为2的结点树$n_2$ 则有${n_0}={n_2}+1$ 如果一棵完全二叉树的结点总数为N，那么叶子结点${n_0}=\frac{N}{2}$</li>
<li>性质4: 结点总数为N，则树深为${log_2(N+1)}$</li>
</ul>
<p><strong>对于树的删除和增加操作改变树结构时</strong><br>递归定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">root-&gt;left=<span class="keyword">delete</span>(root-&gt;left,key);</span><br><span class="line">root-&gt;right=<span class="keyword">delete</span>(root-&gt;right,key);</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>不同题目应用遍历方式是不同的。有的公司面试会问你非递归实现。树的所有题目最后都是基于这几种遍历方式实现的。</p>
<h3 id="前中后遍历"><a href="#前中后遍历" class="headerlink" title="前中后遍历"></a>前中后遍历</h3><blockquote>
<blockquote>
<p>写出先序，然后反向写即后序，结果写在出栈时</p>
</blockquote>
</blockquote>
<p><img src="/2019/10/25/%E6%A0%91/traversal.png" alt></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>使用队列取出弹出加入左右；之字形用两个栈交替加入左右，右左。</p>
<h3 id="二叉树的下一个节点【中序】"><a href="#二叉树的下一个节点【中序】" class="headerlink" title="二叉树的下一个节点【中序】"></a>二叉树的下一个节点【中序】</h3><p>下一个为右结点，或者父节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">getNext</span><span class="params">(TreeNode* pNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode* pNext;</span><br><span class="line">    <span class="comment">//其一、有右结点，右至左</span></span><br><span class="line">    <span class="keyword">if</span>(pNode-&gt;right)&#123;</span><br><span class="line">        TreeNode* p = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;left)</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        pNext = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其二、有父节点，追溯到节点是父树的左子树时，父就是下一个结点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;parent)&#123;</span><br><span class="line">        TreeNode* cur = pNode;</span><br><span class="line">        TreeNode* up= pNode-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(up &amp;&amp; cur == up-&gt;right)&#123;</span><br><span class="line">            cur = up;</span><br><span class="line">            up = up-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        pNext = up;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="路径和：只能是先序遍历"><a href="#路径和：只能是先序遍历" class="headerlink" title="路径和：只能是先序遍历"></a>路径和：只能是先序遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(node*,curSum,out,res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node || cur_Sum &lt; node-&gt;val)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    out.push_back(node-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; curSum==node-&gt;val)</span><br><span class="line">        res.push_back(out);</span><br><span class="line">    generate(node-&gt;left,curSum-node-&gt;val,out,res);</span><br><span class="line">    generate(node-&gt;right,curSum-node-&gt;val,out,res);</span><br><span class="line">    out.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树横向连接"><a href="#二叉树横向连接" class="headerlink" title="二叉树横向连接"></a>二叉树横向连接</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode* dummy=cur;</span><br><span class="line"><span class="keyword">while</span>(root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">        cur-&gt;next=root-&gt;left;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">        cur-&gt;next=root-&gt;right;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    <span class="comment">//平移</span></span><br><span class="line">    root=root-&gt;next;</span><br><span class="line">    <span class="comment">//是否换层</span></span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        root=dummy-&gt;next;<span class="comment">//本层头节点作为下一层的父节点</span></span><br><span class="line">        cur=dummy;<span class="comment">//从辅助节点开始</span></span><br><span class="line">        dummy-&gt;next=<span class="literal">NULL</span>;<span class="comment">//断开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树右视图-层序遍历"><a href="#二叉树右视图-层序遍历" class="headerlink" title="二叉树右视图-层序遍历"></a>二叉树右视图-层序遍历</h2><p>左视图类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;TreeNode*&gt;q&#123;root&#125;;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    res.push_back(q.back());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; q_size();i++)&#123;</span><br><span class="line">        TreeNode* node=q.front();q.pop_front();</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            q.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            q.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode *tmp = root-&gt;left;<span class="comment">//保留左指针</span></span><br><span class="line">    root-&gt;left = invertTree(root-&gt;right);</span><br><span class="line">    root-&gt;right = invertTree(tmp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>判断二叉树是否是对称的<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(TreeNode *p1, TreeNode *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span> &amp;&amp; p2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span> || p2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;val != p2-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> fun(p1-&gt;left, p2-&gt;right) &amp;&amp; fun(p1-&gt;right, p2-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="子树"><a href="#子树" class="headerlink" title="子树"></a>子树</h2><h3 id="判断t是s的子树"><a href="#判断t是s的子树" class="headerlink" title="判断t是s的子树"></a>判断t是s的子树</h3><blockquote>
<blockquote>
<p>先序判断：先对根和t去比较；再对左和右对t去比较</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(s,t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s &amp;&amp; !t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!s || !t) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;val!=t-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSame(s-&gt;left,t-&gt;left) &amp;&amp; isSame(s-&gt;right,t-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(s,t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">isSame</span><span class="params">(s,t)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> <span class="literal">true</span></span>;</span><br><span class="line">    <span class="keyword">return</span> func(s-&gt;left,t) || func(s-&gt;right,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树内部找重复子树"><a href="#二叉树内部找重复子树" class="headerlink" title="二叉树内部找重复子树"></a>二叉树内部找重复子树</h3><blockquote>
<blockquote>
<p>二叉树先序遍历序列化为字符串，后序得到str结果；用map<str,int>来存储分支的次数</str,int></p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str = to_string(node-&gt;val) + &quot;,&quot; + helper(node-&gt;left, m, res) + &quot;,&quot; + helper(node-&gt;right, m, res);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; m, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">    <span class="built_in">string</span> str = to_string(node-&gt;val) + <span class="string">","</span> + helper(node-&gt;left, m, res) + <span class="string">","</span> + helper(node-&gt;right, m, res);</span><br><span class="line">    <span class="keyword">if</span> (m[str] == <span class="number">1</span>) </span><br><span class="line">        res.push_back(node);</span><br><span class="line">    ++m[str];</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最低公共祖先"><a href="#最低公共祖先" class="headerlink" title="最低公共祖先"></a>最低公共祖先</h2><h3 id="二叉搜索树的最低公共祖先"><a href="#二叉搜索树的最低公共祖先" class="headerlink" title="二叉搜索树的最低公共祖先"></a>二叉搜索树的最低公共祖先</h3><blockquote>
<blockquote>
<p>O(h)</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前大于较大值：两节点在左子树上；</span></span><br><span class="line"><span class="comment">//当前小于较小值：两节点在右子树上。</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">generate</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; max(p-&gt;val, q-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> generate(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; min(p-&gt;val, q-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> generate(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">//p,q之间则找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一般二叉树的最低公共祖先"><a href="#一般二叉树的最低公共祖先" class="headerlink" title="一般二叉树的最低公共祖先"></a>一般二叉树的最低公共祖先</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">fun</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || p == root || q == root) </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode *left = fun(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *right = fun(root-&gt;right, p , q);</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的打家劫舍"><a href="#二叉树的打家劫舍" class="headerlink" title="二叉树的打家劫舍"></a>二叉树的打家劫舍</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root, l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">int</span>&amp; l, <span class="keyword">int</span>&amp; r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ll = <span class="number">0</span>, lr = <span class="number">0</span>, rl = <span class="number">0</span>, rr = <span class="number">0</span>;</span><br><span class="line">    l = helper(node-&gt;left, ll, lr);</span><br><span class="line">    r = helper(node-&gt;right, rl, rr);</span><br><span class="line">    <span class="keyword">return</span> max(node-&gt;val + ll + lr + rl + rr, l + r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树（二叉排序树）"><a href="#二叉搜索树（二叉排序树）" class="headerlink" title="二叉搜索树（二叉排序树）"></a>二叉搜索树（二叉排序树）</h2><p>左子树的值 &lt; 当前节点值 &lt; 右子树的值<br>优点在于，最坏的情况下，搜索插入删除的复杂度为$O(h)=O({log_2N})$。<br>可构造树的种数：<img src="/2019/10/25/%E6%A0%91/cart.jpg" alt="avatar"></p>
<script type="math/tex; mode=display">n个节点可构成的二叉排序树种类：C_{2n}^{n}-C_{2n}^{n-1}</script><h3 id="构造二叉搜索树"><a href="#构造二叉搜索树" class="headerlink" title="构造二叉搜索树"></a>构造二叉搜索树</h3><p>遍历start~end选择中间节点，然后(start,i-1),(i+1,end);非平衡的二叉搜索树;如果需要平衡的则需要i取中间值；截止条件就是如果相等则返回该值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;TreeNode*&gt; helper(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) </span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; ++i) &#123;   </span><br><span class="line">        TreeNode* left = helper(start, i - <span class="number">1</span>);</span><br><span class="line">        TreeNode* right = helper(i + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode* a : left) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode* b : right) &#123;</span><br><span class="line">                TreeNode *node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                node-&gt;left = a;</span><br><span class="line">                node-&gt;right = b;</span><br><span class="line">                res.push_back(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证二叉排序树"><a href="#验证二叉排序树" class="headerlink" title="验证二叉排序树"></a>验证二叉排序树</h3><p>返回bool、先序遍历<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义递归 fun(root,INT_MAX,INT_MIN);</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(TreeNode* root,<span class="keyword">int</span> mx,<span class="keyword">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt;= mx || root-&gt;val &lt;= mn)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fun(root-&gt;left,mn,node-&gt;val) &amp;&amp; fun(root-&gt;right,node-&gt;val,mx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="搜索第k小的值"><a href="#搜索第k小的值" class="headerlink" title="搜索第k小的值"></a>搜索第k小的值</h3><p>中序遍历：判断；k—；再判断<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(TreeNode* root, <span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> val = DFS(root-&gt;left, k);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="comment">//判断之前是否已找到</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="comment">//判断现在是否已找到</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> DFS(root-&gt;right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="插入-更改树结构需要指针重新指向"><a href="#插入-更改树结构需要指针重新指向" class="headerlink" title="插入[更改树结构需要指针重新指向]"></a>插入[更改树结构需要指针重新指向]</h3><p>二分搜索<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```cpp</span><br><span class="line">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;</span><br><span class="line">    if (!root) //查找到位置</span><br><span class="line">        return new TreeNode(val);</span><br><span class="line">    if (root-&gt;val &gt; val) </span><br><span class="line">        root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">    else</span><br><span class="line">        root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="删除-更改树结构需要指针重新指向"><a href="#删除-更改树结构需要指针重新指向" class="headerlink" title="删除[更改树结构需要指针重新指向]"></a>删除[更改树结构需要指针重新指向]</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```cpp</span><br><span class="line">TreeNode* deleteNode(TreeNode* root, int key) &#123;</span><br><span class="line">    if (!root) </span><br><span class="line">        return NULL;</span><br><span class="line">    if (key &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">    &#125; else if (key &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //找到；若仅一个子节点，则将较小的左给当前删除节点</span><br><span class="line">        if (!root-&gt;left || !root-&gt;right) &#123;</span><br><span class="line">            root = (root-&gt;left) ? root-&gt;left : root-&gt;right;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            TreeNode *cur = root-&gt;right;</span><br><span class="line">            while (cur-&gt;left) </span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            root-&gt;val = cur-&gt;val;</span><br><span class="line">            //覆盖删除，从此子树开始继续将右重复节点删除</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, cur-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现二叉搜索树迭代器"><a href="#实现二叉搜索树迭代器" class="headerlink" title="实现二叉搜索树迭代器"></a>实现二叉搜索树迭代器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器首先将左入栈</span></span><br><span class="line">BSTIterator(TreeNode *root) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        s.push(root);</span><br><span class="line">        root = root-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Core code</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    t=s.back();pop_back();</span><br><span class="line">    <span class="keyword">int</span> res=t-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;right)&#123;</span><br><span class="line">        t=t-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(t)</span><br><span class="line">            s.push(t);</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><h3 id="验证是否平衡"><a href="#验证是否平衡" class="headerlink" title="验证是否平衡"></a>验证是否平衡</h3><p>后序遍历<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证平衡树</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">balance</span><span class="params">(node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    l=balance(node-&gt;left)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    r=balance(node-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span>?<span class="number">-1</span>:max(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//验证排序树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!fun(root-&gt;left) || !fun(root-&gt;right))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((node-&gt;left &amp;&amp; node-&gt;val &lt;= node-&gt;left-&gt;val) || (node-&gt;right &amp;&amp; node-&gt;val &gt;= node-&gt;right-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉平衡且排序的树"><a href="#二叉平衡且排序的树" class="headerlink" title="二叉平衡且排序的树"></a>二叉平衡且排序的树</h3><p>两个子树的深度不想差超过1. 简单测试过可以。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* node,<span class="keyword">int</span> mx,<span class="keyword">int</span> mn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l=helper(node-&gt;left,mn,node-&gt;val)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r=helper(node-&gt;right,node-&gt;val,mx)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span> || l==<span class="number">0</span> || r==<span class="number">0</span> ||(node-&gt;left &amp;&amp; node-&gt;val&lt;=node-&gt;left-&gt;val) || (node-&gt;right &amp;&amp; node-&gt;val&gt;=node-&gt;right-&gt;val))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉树与链表"><a href="#二叉树与链表" class="headerlink" title="二叉树与链表"></a>二叉树与链表</h2><h3 id="先序遍历将二叉树转单向链表"><a href="#先序遍历将二叉树转单向链表" class="headerlink" title="先序遍历将二叉树转单向链表"></a>先序遍历将二叉树转单向链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cur)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">        <span class="comment">//到达左的最右</span></span><br><span class="line">        pre=root-&gt;left;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;right)</span><br><span class="line">            pre=pre-&gt;right;</span><br><span class="line"></span><br><span class="line">        pre-&gt;right=cur-&gt;right;<span class="comment">//连接右</span></span><br><span class="line">        cur-&gt;right=cur-&gt;left;<span class="comment">//right指针实现next</span></span><br><span class="line">        cur-&gt;left=<span class="literal">NULL</span>;<span class="comment">//左置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur=cur-&gt;right;  <span class="comment">//其实是进入原树的左子树</span></span><br></pre></td></tr></table></figure>
<h3 id="二叉树转双向链表"><a href="#二叉树转双向链表" class="headerlink" title="二叉树转双向链表"></a>二叉树转双向链表</h3><p>定义全局变量，仅对root中序递归，tail为前，root为后</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode *head,*tail = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    fun(root-&gt;left);<span class="comment">//至左</span></span><br><span class="line"></span><br><span class="line">    root-&gt;left = tail;</span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) <span class="comment">//左右连接</span></span><br><span class="line">        tail = head = root;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tail-&gt;right = root;</span><br><span class="line"></span><br><span class="line">    tail = root;</span><br><span class="line">    fun(root-&gt;right);<span class="comment">//至右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表转平衡树"><a href="#链表转平衡树" class="headerlink" title="链表转平衡树"></a>链表转平衡树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tail=NUll;</span><br><span class="line"><span class="function">TreeNode* <span class="title">fun</span><span class="params">(head,tail)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fast!=tail &amp;&amp; fast-&gt;next!=tail)&#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    t=TreeNode(slow);</span><br><span class="line">    t-&gt;left=fun(head,slow);</span><br><span class="line">    t-&gt;right=fun(slow-&gt;next,tail);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全二叉树的节点数"><a href="#完全二叉树的节点数" class="headerlink" title="完全二叉树的节点数"></a>完全二叉树的节点数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r=<span class="number">0</span>;</span><br><span class="line">    TreeNode* m,n=node;</span><br><span class="line">    <span class="keyword">while</span>(m-&gt;left)</span><br><span class="line">        node=node-&gt;left;l++;</span><br><span class="line">    <span class="keyword">while</span>(n-&gt;right)</span><br><span class="line">        node=node-&gt;right;r++;  <span class="comment">//计算左右深度</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,l)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(node-&gt;left)+f(node-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2019/10/25/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>较复杂的为链表的重排，排序<br>重排的链表：有的需要dummy辅助头指针，返回dummy-&gt;next</p>
<hr>
<h2 id="链表交换"><a href="#链表交换" class="headerlink" title="链表交换"></a>链表交换</h2><h3 id="链表两两逆序"><a href="#链表两两逆序" class="headerlink" title="链表两两逆序"></a>链表两两逆序</h3><blockquote>
<blockquote>
<p>从前往后两个交换，两个交换</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* Pn = head-&gt;next;</span><br><span class="line">    head-&gt;next=fun(head-&gt;next-&gt;next);</span><br><span class="line">    Pn-&gt;next=head;</span><br><span class="line">    <span class="keyword">return</span> Pn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表逆序，K个一组"><a href="#链表逆序，K个一组" class="headerlink" title="链表逆序，K个一组"></a>链表逆序，K个一组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(head,tail)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = tail;</span><br><span class="line">    <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">        ListNode *t = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *new_head = reverse(head, cur);</span><br><span class="line">    head-&gt;next = reverseKGroup(cur, k);</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表重排"><a href="#链表重排" class="headerlink" title="链表重排"></a>链表重排</h3><p>1-&gt;2-&gt;3-&gt;4-&gt;5<br>1-&gt;5-&gt;2-&gt;4-&gt;3 将后一半翻转交替插入<br>method_1：快慢指针将后面断开，且翻转，然后依次连接插入；<br>method_2<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历节点入栈ss</span></span><br><span class="line">cnt=(ss.size()<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">ListNode* cur=head;</span><br><span class="line"><span class="keyword">while</span>(cnt-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">    t=s.top();s.pop();</span><br><span class="line">    Pn=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=t;t-&gt;next=Pn;  <span class="comment">//完成插入节点操作</span></span><br><span class="line">    cur=Pn;  <span class="comment">//指向原来的下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line">s.top()-&gt;next=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h2 id="复杂链表深拷贝"><a href="#复杂链表深拷贝" class="headerlink" title="复杂链表深拷贝"></a>复杂链表深拷贝</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//节点入列表</span></span><br><span class="line"><span class="comment">//map保存节点位置,同列表索引</span></span><br><span class="line"><span class="comment">//列表前后连接并且连接随机指针</span></span><br></pre></td></tr></table></figure>
<h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><h3 id="链表插入排序"><a href="#链表插入排序" class="headerlink" title="链表插入排序"></a>链表插入排序</h3><blockquote>
<blockquote>
<p>遍历head链表，在cur中找到比当前较大节点插入到dummy中</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cur=dummy=node(<span class="number">-1</span>); <span class="comment">//辅助接点方便从头插入</span></span><br><span class="line"><span class="keyword">while</span>(head):</span><br><span class="line">    Pn=head-&gt;next;<span class="comment">//保存下一节点</span></span><br><span class="line"></span><br><span class="line">    cur=dummy;<span class="comment">//从头寻找head值的插入位置</span></span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt; head-&gt;val):</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    head-&gt;next=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=head;<span class="comment">//插入</span></span><br><span class="line"></span><br><span class="line">    head=Pn;<span class="comment">//更新head</span></span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br></pre></td></tr></table></figure>
<h3 id="链表归并排序"><a href="#链表归并排序" class="headerlink" title="链表归并排序"></a>链表归并排序</h3><p>快慢指针分两半，各自归并排序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个有序链表</span></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        l1-&gt;next = merge(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = merge(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中分head和slow链表至节点，再自底向上去merge</span></span><br><span class="line"><span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        pre=slow;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(sortList(head), sortList(slow));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链表删除某个节点"><a href="#链表删除某个节点" class="headerlink" title="链表删除某个节点"></a>链表删除某个节点</h2><p>多个判断：尾节点，仅单节点，<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode **head, ListNode *target)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (target-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode *pn = target-&gt;next;</span><br><span class="line">        target-&gt;val = pn-&gt;val;</span><br><span class="line">        target-&gt;next = pn-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pn;</span><br><span class="line">        pn = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (head == target) &#123;</span><br><span class="line">        <span class="keyword">delete</span> target;</span><br><span class="line">        taret = <span class="literal">NULL</span>;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ListNode *pn = head;</span><br><span class="line">        <span class="keyword">while</span> (pn-&gt;next != target) &#123;</span><br><span class="line">            pn = pn-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pn-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">delete</span> target;</span><br><span class="line">        target = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="链表删除连续重复元素"><a href="#链表删除连续重复元素" class="headerlink" title="链表删除连续重复元素"></a>链表删除连续重复元素</h2><blockquote>
<blockquote>
<p>快慢指针，快指针负责相同则继续后移；判断二者是否为前后关系即可</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dummy=pre=Node(<span class="number">-1</span>);</span><br><span class="line">pre-&gt;next=head <span class="comment">//辅助指针</span></span><br><span class="line"><span class="keyword">while</span>(head)&#123;</span><br><span class="line">    cur=pre-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val==cur-&gt;next-&gt;val)</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur=pre-&gt;next)<span class="comment">//如果无重复，则后移；否则前后连接</span></span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;next=cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br></pre></td></tr></table></figure>
<h2 id="大招：树与链表"><a href="#大招：树与链表" class="headerlink" title="大招：树与链表"></a>大招：树与链表</h2><ol>
<li>链表转二叉树：一般需要转换，则就是唯一的结果，此时就需要树是高度平衡的，链表也好数组也好（线性表即可）。就需要<strong>快慢指针分成两段，中间为根节点</strong></li>
<li>二叉树转链表：先序中序后续遍历连接链表即可</li>
<li>较为容易的二叉搜索树与有序链表。树转链表：中序遍历（非递归）；链表转树：快慢指针中间为根。</li>
</ol>
<h3 id="链表转二叉平衡树（特殊：有序链表转二叉平衡排序树）"><a href="#链表转二叉平衡树（特殊：有序链表转二叉平衡排序树）" class="headerlink" title="链表转二叉平衡树（特殊：有序链表转二叉平衡排序树）"></a>链表转二叉平衡树（特殊：有序链表转二叉平衡排序树）</h3><blockquote>
<blockquote>
<p>移动到中间，构建节点，左右分别继续递归构建</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tail=<span class="literal">NULL</span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">fun</span><span class="params">(head,tail)</span></span>&#123;</span><br><span class="line">    TreeNode* slow,fast=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=tail &amp;&amp; fast-&gt;next!=tail)&#123;</span><br><span class="line">        slow=slow-&gt;next;</span><br><span class="line">        fast=fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    t=TreeNode(slow);</span><br><span class="line">    t-&gt;left=fun(head,slow);</span><br><span class="line">    t-&gt;right=fun(slow-&gt;next,tail);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树转链表（特殊：二叉排序树转有序链表-中序实现-）"><a href="#二叉树转链表（特殊：二叉排序树转有序链表-中序实现-）" class="headerlink" title="二叉树转链表（特殊：二叉排序树转有序链表[中序实现]）"></a>二叉树转链表（特殊：二叉排序树转有序链表[中序实现]）</h3><blockquote>
<blockquote>
<p>右指针实现</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TreeNode *head,*tail = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    fun(root-&gt;left);<span class="comment">//至左</span></span><br><span class="line">    root-&gt;left = tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="literal">NULL</span>) <span class="comment">//左右连接</span></span><br><span class="line">        tail = head = root;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tail-&gt;right = root;</span><br><span class="line"></span><br><span class="line">    tail = root;</span><br><span class="line">    fun(root-&gt;right);<span class="comment">//至右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>有的一面会问数据结构与算法的基础：线性表，堆，栈，队列，树，图定义，最短路径算法等等</p>
<hr>
<h2 id="常用STL函数与数据结构"><a href="#常用STL函数与数据结构" class="headerlink" title="常用STL函数与数据结构"></a>常用STL函数与数据结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">getline(is,t,<span class="string">' '</span>);<span class="comment">//迭代返回单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符与数字</span></span><br><span class="line">val=atoi(s.substr(<span class="number">0</span>, k))</span><br><span class="line">str=to_string(val)</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据结构</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">double</span>&gt; ms(nums.begin(), nums.begin() + k);<span class="comment">//维护一个可重复有序集合。</span></span><br><span class="line"><span class="comment">//堆 empty();pop();push();top();size()</span></span><br><span class="line">priority <span class="built_in">queue</span>&lt;<span class="keyword">int</span>,vectot&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;small_heap;  <span class="comment">//构造最小堆</span></span><br><span class="line">priority <span class="built_in">queue</span>&lt;<span class="keyword">int</span>,vectot&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt;big_heap;  <span class="comment">//构造最大堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;p;<span class="comment">//默认最大堆。</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q; <span class="comment">//队列</span></span><br><span class="line">dequeue&lt;<span class="keyword">int</span>&gt;q; <span class="comment">//双向队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分函数</span></span><br><span class="line">lower_bound(num.begin(),num.end(),num)：<span class="comment">//二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line">upper_bound(num.begin(),num.end(),num)：<span class="comment">//从数组的begin位置到end-1位置二分查找第一个大于num的数字，</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/pointer.gif" alt="pointer"></p>
<h2 id="好几大排序"><a href="#好几大排序" class="headerlink" title="好几大排序"></a>好几大排序</h2><p><a href="https://zhuanlan.zhihu.com/p/34894768" target="_blank" rel="noopener">排序算法整理</a></p>
<p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/sort.png" alt><br>排序算法的稳定性：<strong>保证排序前后两个相等的数的相对顺序不变</strong>，只有<strong>冒泡，插入，归并</strong>是稳定的。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/冒泡.webp" alt></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/选择.webp" alt></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/插入.webp" alt></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/归并.webp" alt></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/快排.webp" alt></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/希尔.webp" alt></p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/计数.webp" alt></p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/基数.webp" alt></p>
<h2 id="复杂数据结构构造器"><a href="#复杂数据结构构造器" class="headerlink" title="复杂数据结构构造器"></a>复杂数据结构构造器</h2><h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        TrieNode():isWord(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a:child) </span><br><span class="line">                a=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="LRU缓存实现"><a href="#LRU缓存实现" class="headerlink" title="LRU缓存实现"></a>LRU缓存实现</h3><blockquote>
<blockquote>
<p>构造List存储pair<k,v>;//构造Map存储<k,List->pointer&gt;</k,List-></k,v></p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m.end())<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        l.splice(l.begin(), l, it-&gt;second);<span class="comment">//找到则拼接到l的前端</span></span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新放到头部，如果有则删除；如果空间满则移除尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m.end()) <span class="comment">//找到了</span></span><br><span class="line">            l.erase(it-&gt;second);</span><br><span class="line">        l.push_front(make_pair(key, value));</span><br><span class="line">        m[key] = l.begin();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m.size() &gt; cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = l.rbegin()-&gt;first;</span><br><span class="line">            l.pop_back();</span><br><span class="line">            m.erase(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; l;<span class="comment">//可左右端操作</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="基本算法题"><a href="#基本算法题" class="headerlink" title="基本算法题"></a>基本算法题</h2><h3 id="两个数加和"><a href="#两个数加和" class="headerlink" title="两个数加和"></a>两个数加和</h3><p>异或结果为num1，相与左移1位结果为num2.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum = num1 ^ num2;</span><br><span class="line">        carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        num1 = sum;</span><br><span class="line">        num2 = carry;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快排-传说中的实习面试必考"><a href="#快排-传说中的实习面试必考" class="headerlink" title="快排-传说中的实习面试必考"></a>快排-传说中的实习面试必考</h3><blockquote>
<blockquote>
<p>O(N^2)：对已排序数组，用最后一个数字为base进行排序时；</p>
</blockquote>
</blockquote>
<p>O(N)的排序，使用计数。额外辅助空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = nums[start];</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] &gt;= key)</span><br><span class="line">            end --;</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] &lt;= key)</span><br><span class="line">            start ++;</span><br><span class="line">        nums[end] = nums[start];</span><br><span class="line">        nums[start] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start== end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> k = partition(nums, start, end);</span><br><span class="line">    quick_sort(nums, start, index<span class="number">-1</span>);</span><br><span class="line">    quick_sort(nums, index+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MR实现矩阵相乘"><a href="#MR实现矩阵相乘" class="headerlink" title="MR实现矩阵相乘"></a>MR实现矩阵相乘</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/MRMatrix.png" alt="avatar"></p>
<h3 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h3><p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/rand.png" alt></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    x = a*rand_a()+rand_a();</span><br><span class="line">    <span class="keyword">if</span> x &lt; N&#123;  <span class="comment">//N=max(N%b==0,N&lt;-[0,a^2+a])</span></span><br><span class="line">        <span class="keyword">return</span> x%b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><p>初始op为+，保存连续的两个运算符op,c：先结算op；然后判断当c是+-时将中间结果累加到res。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//25x4x3+20x3</span></span><br><span class="line"><span class="keyword">char</span> op = <span class="string">'+'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="keyword">char</span> c=s[i];</span><br><span class="line">    <span class="comment">//当前数</span></span><br><span class="line">    <span class="keyword">if</span>(c&gt;=<span class="string">'0'</span> &amp;&amp; c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">        num=num*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span> || c == <span class="string">'/'</span> || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//当前乘除的子结果</span></span><br><span class="line">        <span class="keyword">switch</span>(op):&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: curRes += num; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: curRes -= num; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>: curRes *= num; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>: curRes /= num; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子表达式结果累加到res</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">            res += curRes;</span><br><span class="line">            curRes = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保留本次运算符</span></span><br><span class="line">        op = c;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure></p>
<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">        n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><blockquote>
<blockquote>
<p>字符串匹配算法</p>
</blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> ss, <span class="built_in">string</span> tmp, <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = ss.size(), m = tmp.size();</span><br><span class="line">    process(temp, f); <span class="comment">//预处理得到失配表</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//j表示当前模版串的待匹配位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; ss[i] != tmp[j]) </span><br><span class="line">            j = f[j]; <span class="comment">//不停的转移，直到可以匹配或者走到0</span></span><br><span class="line">        <span class="keyword">if</span>(ss[i] == tmp[j])</span><br><span class="line">            j++; <span class="comment">//如果相等，模版串中待匹配位置可以移一位了。</span></span><br><span class="line">        <span class="keyword">if</span>(j == m)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i - m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算失配表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">string</span>* tmp, <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tmp.size();</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = f[i];</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; tmp[i] != tmp[j])</span><br><span class="line">            j = f[j]; <span class="comment">//一旦回到1，表明窗口大小为0了，只能回到最初的字符</span></span><br><span class="line">        f[i + <span class="number">1</span>] = tmp[i] == tmp[j] ? j + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="智力题"><a href="#智力题" class="headerlink" title="智力题"></a>智力题</h2><h3 id="海量数据topK问题"><a href="#海量数据topK问题" class="headerlink" title="海量数据topK问题"></a>海量数据topK问题</h3><ul>
<li>Top K问题：分治+Trie树/Hash_map+小顶堆。采用Hash(x)%M将原文件分割成小文件，如果小文件太大则继续Hash分割，直至可以放入内存。</li>
<li>重复问题：BitMap位图 或 Bloom Filter布隆过滤器 或 Hash_set集合。每个元素对应一个bit处理。</li>
<li>排序问题：外排序 或 BitMap位图。分割文件+文件内排序+文件之间归并。</li>
</ul>
<h3 id="64匹马8赛道，求top4的问题"><a href="#64匹马8赛道，求top4的问题" class="headerlink" title="64匹马8赛道，求top4的问题"></a>64匹马8赛道，求top4的问题</h3><ol>
<li>分8场全部赛一遍，得到各分组排名<br><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/horse1.png" alt></li>
<li>各组头名赛1场，得到<strong>top1</strong><br><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/horse2.png" alt></li>
<li>分析仅有9个中会出现<strong>top2,3,4</strong><br><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/horse3.png" alt></li>
<li>故取8个赛一场,得到前三名1=<strong>top2</strong>,2=<strong>top3</strong>,3；</li>
<li>第三名和剩下那一只赛一次得到<strong>top4</strong></li>
</ol>
<h3 id="N瓶药log2N个白鼠问题"><a href="#N瓶药log2N个白鼠问题" class="headerlink" title="N瓶药log2N个白鼠问题"></a>N瓶药log2N个白鼠问题</h3><p>问题描述：有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？</p>
<hr>
<p>根据2^10=1024，所以10个老鼠可以确定1000个瓶子具体哪个瓶子有毒。具体实现跟3个老鼠确定8个瓶子原理一样。</p>
<p><img src="/2019/10/25/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/mouse.png" alt></p>
<h3 id="算法面试中的趣味题总结"><a href="#算法面试中的趣味题总结" class="headerlink" title="算法面试中的趣味题总结"></a>算法面试中的趣味题总结</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MzY0MzE4Mg==&amp;mid=2247485018&amp;idx=1&amp;sn=c803466f48ba64919495f9a7d89473fb&amp;chksm=e9d0169bdea79f8dc97b35b5892d176b0fb51de5554aaf08eba920a45e782355dea8b81bbfd0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">智力题补充</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>优化算法</title>
    <url>/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>梯度下降是一种<strong>优化算法</strong>，通过<strong>迭代</strong>的方式寻找模型的<strong>最优参数</strong>；当目标函数是<strong>凸函数</strong>时，梯度下降的解是全局最优解；但在一般情况下，<strong>梯度下降无法保证全局最优</strong>。<strong>负梯度</strong>中的每一项可以认为传达了<strong>两个信息</strong>:</p>
<ul>
<li>正负号在告诉输入向量应该调大还是调小（正调大，负调小）；</li>
<li>每一项的相对大小表明每个参数对函数值达到最值的<strong>影响程度</strong></li>
</ul>
<a id="more"></a>
<h3 id="批梯度下降（Batch-SGD）-VS-随机梯度下降"><a href="#批梯度下降（Batch-SGD）-VS-随机梯度下降" class="headerlink" title="批梯度下降（Batch SGD） VS  随机梯度下降"></a>批梯度下降（Batch SGD） VS  随机梯度下降</h3><ul>
<li><strong>批梯度下降</strong>在每次对模型参数进行更新时，需要遍历所有数据，得到平均损失<br><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/e1.png" alt></li>
<li><strong>随机梯度下降</strong>每次使用单个样本的损失来近似平均损失<br><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/e2.png" alt><h3 id="小批量随机梯度下降（mini-batch-SGD）"><a href="#小批量随机梯度下降（mini-batch-SGD）" class="headerlink" title="小批量随机梯度下降（mini batch SGD）"></a>小批量随机梯度下降（mini batch SGD）</h3></li>
<li>为了降低随机梯度的<strong>方差</strong>，使模型迭代更加稳定，实践中会使用<strong>一批</strong>随机数据的损失来近似平均损失。</li>
<li>使用批训练的另一个主要目的，是为了利用高度优化的<strong>矩阵运算</strong>以及<strong>并行计算框架</strong>。</li>
</ul>
<h3 id="“批”的大小对优化效果的影响"><a href="#“批”的大小对优化效果的影响" class="headerlink" title="“批”的大小对优化效果的影响"></a>“批”的大小对优化效果的影响</h3><ul>
<li>批越小：则泛化误差更好，学习更加充分，引入噪声正则化效果，学习率小保证稳定性故收敛慢；</li>
<li>批越大则梯度估计更加精确，训练加速</li>
</ul>
<blockquote>
<blockquote>
<p>当批的大小为 <strong>2 的幂</strong>时能充分利用矩阵运算操作，所以批的大小一般取 32、64、128、256 等。</p>
</blockquote>
</blockquote>
<h3 id="随机梯度下降存在的问题"><a href="#随机梯度下降存在的问题" class="headerlink" title="随机梯度下降存在的问题"></a>随机梯度下降存在的问题</h3><ul>
<li>梯度下降陷入<strong>局部极值点</strong>，以及遇到“<strong>峡谷</strong>”和“<strong>鞍点</strong>”两种情况</li>
<li><strong>峡谷</strong>：准确的梯度方向应该沿着坡的方向向下，但粗糙的梯度估计导致在两个峭壁间来回震荡。</li>
<li><strong>鞍点</strong>：落入鞍点导致优化很可能就会停滞下来。</li>
</ul>
<p><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/an.png" alt="avatar"></p>
<h2 id="改进的随机梯度下降"><a href="#改进的随机梯度下降" class="headerlink" title="改进的随机梯度下降"></a>改进的随机梯度下降</h2><p>SGD 的改进遵循两个方向：<strong>惯性保持</strong>和<strong>环境感知</strong></p>
<ul>
<li><strong>惯性保持</strong>指的是加入动量SGD 算法；针对鞍点</li>
<li><strong>环境感知</strong>指的是<strong>自适应</strong>地确定<strong>每个参数的学习速率</strong>；针对峡谷</li>
</ul>
<h3 id="动量算法"><a href="#动量算法" class="headerlink" title="动量算法"></a>动量算法</h3><h4 id="Momentum动量"><a href="#Momentum动量" class="headerlink" title="Momentum动量"></a>Momentum动量</h4><p>引入<strong>动量</strong>方法一方面是为了解决“峡谷”和“鞍点”问题；一方面也可以用于SGD 加速，特别是针对<strong>高曲率</strong>、小幅但是方向一致的梯度。在鞍点处因为<strong>惯性</strong>的作用，更有可能离开平地。<br><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/line.png" alt="avatar"></p>
<blockquote>
<blockquote>
<p>将过去时间steps的梯度矢量累加到当前去更新梯度，致使梯度相同的方向的维度，动量项增加，加快SGD的正确方向，并抑制震荡。</p>
<script type="math/tex; mode=display">v_t = \gamma v_{t-1} + \eta \nabla_\theta J(\theta) \\
\theta = \theta-v_t</script><p>缺点：梯度太大，略过最小值，在最小值附近震荡。</p>
<h4 id="NAG-动量"><a href="#NAG-动量" class="headerlink" title="NAG 动量"></a>NAG 动量</h4><script type="math/tex; mode=display">v_t = \gamma v_{t-1} + \eta \nabla_\theta J(\theta - \gamma v_{t-1}) \\
\theta = \theta-v_t</script><p><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/mn.png" alt><br>具有前瞻性，前瞻位置估计梯度</p>
</blockquote>
</blockquote>
<h4 id="Momentum和NAG动量的区别"><a href="#Momentum和NAG动量的区别" class="headerlink" title="Momentum和NAG动量的区别"></a>Momentum和NAG动量的区别</h4><ul>
<li>momentum：计算梯度-&gt;加上动量加速$\gamma * v$-&gt;更新参数；</li>
<li>nesterov：加上动量加速$\gamma <em> v$去计算梯度-&gt;加上动量加速$\gamma </em> v$-&gt;更新参数。</li>
</ul>
<h3 id="自适应学习率的优化算法"><a href="#自适应学习率的优化算法" class="headerlink" title="自适应学习率的优化算法"></a>自适应学习率的优化算法</h3><h4 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h4><ul>
<li>该算法的思想是独立地适应模型的每个参数：具有较大偏导的参数相应有一个较大的学习率，而具有小偏导的参数则对应一个较小的学习率。学习率会反比于其<strong>历史梯度平方值总和的平方根</strong></li>
</ul>
<h5 id="AdaGrad-算法描述"><a href="#AdaGrad-算法描述" class="headerlink" title="AdaGrad 算法描述"></a>AdaGrad 算法描述</h5><script type="math/tex; mode=display">r=r+g*g</script><script type="math/tex; mode=display">\Delta\theta=-\frac{\eta}{\sqrt{r+\delta}}*g</script><p>注意：全局学习率$\eta$并没有更新，而是每次应用时被缩放</p>
<h5 id="AdaGrad-存在的问题"><a href="#AdaGrad-存在的问题" class="headerlink" title="AdaGrad 存在的问题"></a>AdaGrad 存在的问题</h5><p>学习率是一直递减的，训练后期学习率过小会导致训练困难，甚至提前结束。</p>
<h4 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h4><p>AdaGrad 根据平方梯度的<strong>整个历史</strong>来收缩学习率，可能使得学习率在达到局部最小值之前就变得太小而难以继续训练;RMSProp 主要是为了解决 AdaGrad 方法中<strong>学习率过度衰减</strong>的问题</p>
<hr>
<p>RMSProp 使用<strong>指数衰减平均</strong>（递归定义）以丢弃遥远的历史，使其能够在找到某个“凸”结构后快速收敛；此外，RMSProp 还加入了一个超参数 <code>ρ</code> 用于控制衰减速率。</p>
<h5 id="RMSProp-算法描述"><a href="#RMSProp-算法描述" class="headerlink" title="RMSProp 算法描述"></a>RMSProp 算法描述</h5><script type="math/tex; mode=display">r=\rho r+ (1-\rho)g*g</script><script type="math/tex; mode=display">\Delta\theta=-\frac{\eta}{\sqrt{r+\delta}}*g</script><h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><ul>
<li>加入<strong>历史梯度平方的指数衰减平均</strong>（<code>r</code>）</li>
<li>保留了<strong>历史梯度的指数衰减平均</strong>（<code>s</code>），相当于<strong>动量</strong>。<br>Adam=Momentum（一阶）+RMSProp（二阶）<h5 id="Adam-算法描述"><a href="#Adam-算法描述" class="headerlink" title="Adam 算法描述"></a>Adam 算法描述</h5><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/adam.png" alt="avatar"><script type="math/tex; mode=display">m_t=\gamma m_{t-1}+(1-\gamma)g_t\\
v_t=\rho v_{t-1}+(1-\rho)g_t^2\\
\hat{m_t}=\frac{m_t}{1-\gamma}\\
\hat{n_t}=\frac{n_t}{1-\rho}\\
\theta:=\theta-\frac{\eta}{\sqrt{\hat{v_t}}+\epsilon}\hat{m_t}</script></li>
</ul>
<h2 id="如何选择这些优化算法"><a href="#如何选择这些优化算法" class="headerlink" title="如何选择这些优化算法"></a>如何选择这些优化算法</h2><ul>
<li>各自适应学习率的优化算法表现不分伯仲，没有哪个算法能在所有任务上脱颖而出；</li>
<li>目前，最流行并且使用很高的优化算法包括 SGD、带动量的 SGD、RMSProp、带动量的 RMSProp、AdaDelta 和 Adam。</li>
</ul>
<h3 id="各优化算法的可视化"><a href="#各优化算法的可视化" class="headerlink" title="各优化算法的可视化"></a>各优化算法的可视化</h3><ul>
<li><p>SGD 各优化方法在损失曲面上的表现<br><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/com.gif" alt="avatar"></p>
</li>
<li><p>SGD 各优化方法在<strong>鞍点</strong>处上的表现<br><img src="/2019/10/25/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/comp.gif" alt="avatar"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>深度学习面试</title>
    <url>/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><h3 id="如何使用激活函数"><a href="#如何使用激活函数" class="headerlink" title="如何使用激活函数"></a>如何使用激活函数</h3><ul>
<li>回归，则将sigmoid或tanh用作最后一层的非线性和平方误差作为成本函数。</li>
<li>分类，隐层relu+尾层sigmoid+softmax归一化输出+结果交叉熵作损失</li>
</ul>
<h3 id="为什么非线性激活函数"><a href="#为什么非线性激活函数" class="headerlink" title="为什么非线性激活函数"></a>为什么非线性激活函数</h3><ul>
<li><strong>神经网络万能近似定理</strong>认为神经网络具有至少一个非线性隐藏层，那么只要给予网络足够数量的隐藏单元，<strong>隐层就可以以任意的精度来拟合函数：完成任何一个有限维空间到另一个有限维空间的函数。</strong></li>
<li>如果不使用非线性激活函数，那么每一层输出都是上层输入的线性组合，整体也是线性的，失去万能近似的性质。</li>
<li>部分层是纯线性是可以接受的，这有助于减少网络中的参数。<a id="more"></a>
<h3 id="各种激活函数优缺点"><a href="#各种激活函数优缺点" class="headerlink" title="各种激活函数优缺点"></a>各种激活函数优缺点</h3></li>
<li>$sigmoid$<ol>
<li>优点：较好的解释性；</li>
<li>缺点：函数饱和梯度消失；非0中心，梯度恒为正或负；指数运算慢；</li>
</ol>
</li>
<li>$tanh$<ol>
<li>优点：0中心；</li>
<li>缺点：饱和梯度消失，计算慢；</li>
</ol>
</li>
<li>$ReLu$<ol>
<li>优点：加速梯度下降收敛；线性非饱和；特别适用DNN；</li>
<li>缺点：负半区失活；稀疏；</li>
</ol>
</li>
</ul>
<h2 id="二、正则化"><a href="#二、正则化" class="headerlink" title="二、正则化"></a>二、正则化</h2><h3 id="1、批归一化"><a href="#1、批归一化" class="headerlink" title="1、批归一化"></a>1、批归一化</h3><ul>
<li>什么是批归一化<ul>
<li>每一批数据层层传播，致使网络在每次迭代中都需要拟合不同的数据分布，增大了网络的训练难度与过拟合的风险。对某层的神经元进行归一化（标准正态）处理，使其限制在统一分布下。相当于<strong>对数据分布进行额外的约束，降低拟合能力，破坏已学到的特征分布，从而增强模型的泛化能力。</strong></li>
</ul>
</li>
<li>批归一化的作用<ol>
<li>加速网络的训练（缓解梯度消失，支持更大的学习率）</li>
<li>防止过拟合</li>
<li>降低了参数初始化的要求。</li>
</ol>
</li>
</ul>
<h3 id="2、L1和L2正则"><a href="#2、L1和L2正则" class="headerlink" title="2、L1和L2正则"></a>2、L1和L2正则</h3><h4 id="L1、L2区别"><a href="#L1、L2区别" class="headerlink" title="L1、L2区别"></a>L1、L2区别</h4><ul>
<li>相同点：通过限制参数的规模，使模型偏好于权值较小的目标函数，防止过拟合。</li>
<li>不同点<ol>
<li>L1 正则化可以产生更稀疏的权值矩阵，可以用于特征选择，同时一定程度上防止过拟合；L1 正则化适用于特征之间有关联的情况。</li>
<li>L2 正则化整体降低模型权重，模型复杂度更低，模型对于噪声与异常点的抗干扰性的能力增强，从而提高模型的泛化能力。</li>
</ol>
</li>
</ul>
<h3 id="3、Dropout"><a href="#3、Dropout" class="headerlink" title="3、Dropout"></a>3、Dropout</h3><blockquote>
<blockquote>
<p>训练时丢失，预测时都加上</p>
</blockquote>
</blockquote>
<p>隐藏层的采样概率为 0.5，输入的采样概率为 0.8；<br><img src="/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95/bn.png" alt="avatar"></p>
<h3 id="4、参数初始化"><a href="#4、参数初始化" class="headerlink" title="4、参数初始化"></a>4、参数初始化</h3><ol>
<li>一般使用服从的高斯分布（mean=0, stddev=1）或均匀分布的随机值作为权重的初始化参数；使用 0 作为偏置的初始化参数</li>
<li>一些启发式方法会根据输入与输出的单元数来决定初始值的范围；比如<br><img src="/2019/10/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9D%A2%E8%AF%95/1.png" alt="avatar"><br>Keras 全连接层默认的权重初始化方法</li>
</ol>
<h2 id="神经网络的偏置项b"><a href="#神经网络的偏置项b" class="headerlink" title="神经网络的偏置项b"></a>神经网络的偏置项b</h2><script type="math/tex; mode=display">\hat y=\sum_i w_i x_i</script><script type="math/tex; mode=display">y=1,if\hat{y}>= threshold</script><script type="math/tex; mode=display">y=0,if\hat{y}<= threshold</script><p>$threshold$度量神经元正负激励的难易程度，$threshold$越大产生正向激励难度越大。通过移项作为$-b$加入最终的值中判断是否大于0即可。所以<strong>$b$的大小，度量了神经元产生正（负）激励的难易程度</strong></p>
<h2 id="NN的参数初始化"><a href="#NN的参数初始化" class="headerlink" title="NN的参数初始化"></a>NN的参数初始化</h2><p>如果无隐层则参数可以都初始化为0；其他不会使用0初始化；</p>
<h2 id="交叉熵损失与平方差损失"><a href="#交叉熵损失与平方差损失" class="headerlink" title="交叉熵损失与平方差损失"></a>交叉熵损失与平方差损失</h2><p>对分类问题</p>
<ul>
<li>交叉熵度量两个分布的相似性；平方差损失度量两个数据距离；</li>
<li>交叉熵对概率更为敏感；平方差对数值敏感；</li>
<li>分类问题最后是sigmoid的输出，交叉熵可以使误差越大时学习率越大收敛快；平方差损失学习则慢；</li>
</ul>
<p>平方损失用在输出连续，最后一层无sigmoid和softmax层的NN中。</p>
<h2 id="神经网络和SVM的区别"><a href="#神经网络和SVM的区别" class="headerlink" title="神经网络和SVM的区别"></a>神经网络和SVM的区别</h2><p>SVM和NN都可实现非线性分类模型。</p>
<ul>
<li>NN通过多个隐层实现非线性函数-<strong>神经网络万能近似定理</strong>。设计灵活，但可解释性较差；</li>
<li>VM使用核函数的方法，实现一个泛函线性空间。核函数设计复杂；可解释性较强，理论完备；</li>
</ul>
<h2 id="神经网络的宽度和深度"><a href="#神经网络的宽度和深度" class="headerlink" title="神经网络的宽度和深度"></a>神经网络的宽度和深度</h2><p>宽度设计：参数过多；<br>深度设计：参数较少。</p>
<h2 id="神经网络万能近似定理"><a href="#神经网络万能近似定理" class="headerlink" title="神经网络万能近似定理"></a>神经网络万能近似定理</h2><p>一个前馈神经网络如果具有线性层和至少一个“挤压”性质的激活函数，给定网络足够的隐层，它可以以任意精度近似一个函数，实现一个有限维空间到另一个有限维空间的映射。</p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2019/10/25/Transformer/</url>
    <content><![CDATA[<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p><img src="/2019/10/25/Transformer/trm.jpg" alt="avatar"><br><img src="/2019/10/25/Transformer/trm.gif" alt="avatar"></p>
<hr>
<a id="more"></a>
<h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p><img src="/2019/10/25/Transformer/encoder.jpg" alt="avatar"></p>
<p>Transformer的encoder中，数据首先会经过一个叫做‘self-attention’的模块得到一个加权之后的特征向量$Z$，这个$Z$便是论文公式1中的 $\text{Attention}(Q,K,V)$</p>
<script type="math/tex; mode=display">\text{Attention}(Q,K,V)=\text{softmax}(\frac{QK^T}{\sqrt{d_k}})V \tag1</script><p><strong>得到$Z$之后，加上残差网络结构然后被送到encoder的下一个模块，即Feed Forward Neural Network</strong>。这个全连接有两层，第一层的激活函数是ReLU，第二层是一个线性激活函数，可以表示为：</p>
<script type="math/tex; mode=display">\text{FFN}(Z) = max(0, ZW_1 +b_1)W_2 + b_2 \tag2</script><p><strong>FFN输出后加上残差网络结构输出到下一层</strong></p>
<h3 id="1-1、从self-Attention到MultiHead-Attention"><a href="#1-1、从self-Attention到MultiHead-Attention" class="headerlink" title="1.1、从self-Attention到MultiHead-Attention"></a>1.1、从self-Attention到MultiHead-Attention</h3><p>在self-attention中，每个单词有3个不同的向量，它们分别是Query向量（ Q ），Key向量（ K ）和Value向量（ V ），长度均是64。它们是通过3个不同的权值矩阵由嵌入向量 X 乘以三个不同的权值矩阵$W^Q$，$W^K$,$W^V$ 得到，其中三个矩阵的尺寸也是相同的。均是$512\times 64$.</p>
<ul>
<li>图解<img src="/2019/10/25/Transformer/attention.jpg" alt="avatar"></li>
</ul>
<ol>
<li>根据嵌入向量得到 q ， k ， v 三个向量;</li>
<li>为每个向量计算一个score：$\text{score} = q \cdot k$;</li>
<li>为了梯度的稳定，Transformer使用了score归一化，即除以$\sqrt{d_k}$;</li>
<li>对score施以softmax激活函数，归一化权重</li>
<li>softmax点乘Value值 v，得到加权的每个输入向量的评分 v</li>
<li>对每个词的emb相加之后得到最终的输出结果$z ： z=\sum v$.</li>
</ol>
<ul>
<li>图解<br><img src="/2019/10/25/Transformer/attention2.png" alt><br>以上为self-Attention，MultiHead-Attention如下<br><img src="/2019/10/25/Transformer/mattention.jpg" alt="avatar"><br>将各路self-Attention结果拼接得到MultiHead-Attention</li>
</ul>
<h2 id="残差网络"><a href="#残差网络" class="headerlink" title="残差网络"></a>残差网络</h2><ul>
<li>为什么使用残差网络<ol>
<li>实际上随着网络深度的加深，训练错误会先减少，然后增多；</li>
<li>深度越深越难训练，冗余的网络层不是恒等映射；<strong>DNN(x)!=x不是恒等映射后面就会学偏</strong>。</li>
</ol>
</li>
<li>解决：引入残差网络希望这些冗余层能够完成恒等映射，保证DNN(x)=x。有助于解决梯度消失和梯度爆炸问题，让我们在训练更深网络的同时，又能保证良好的性能。</li>
</ul>
<h2 id="Position-encoding"><a href="#Position-encoding" class="headerlink" title="Position encoding"></a>Position encoding</h2><p>至此无论句子的结构怎么打乱，Transformer都会得到类似的结果。换句话说，Transformer只是一个功能更强大的词袋模型而已。引入位置信息的方式是对位置进行编码论文给出的编码公式如下：</p>
<script type="math/tex; mode=display">PE(pos, 2i) = sin(\frac{pos}{10000^{\frac{2i}{d_{model}}}}) \tag3</script><script type="math/tex; mode=display">PE(pos, 2i+1) = cos(\frac{pos}{10000^{\frac{2i}{d_{model}}}}) \tag4</script><p>在上式中， pos 表示单词的位置， i 表示单词的维度。在NLP任务重，除了单词的绝对位中，单词的相对位置也非常重要。根据公式$sin(\alpha+\beta) = sin \alpha cos \beta + cos \alpha sin\beta$以及$cos(\alpha + \beta) = cos \alpha cos \beta - sin \alpha sin\beta$这表明位置 k+p 的位置向量可以表示为位置 k 的特征向量的线性变化，这为模型捕捉单词之间的相对位置关系提供了非常大的便利。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>虽然Transformer最终也没有逃脱传统学习的套路，Transformer也只是一个全连接（或者是一维卷积）加Attention的结合体。抛弃了在NLP中最根本的RNN或者CNN并且取得了非常不错的效果;</li>
<li>Transformer的设计最大的带来性能提升的关键是self_attention将任意两个单词的求取权重，解决文本处理中的长期依赖问题;</li>
<li>Transformer可以应用更广;</li>
<li>算法可并行，支持GPU加速。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>位置信息不够重复</li>
</ol>
<h3 id="LSTM与RNN，Transformer比较"><a href="#LSTM与RNN，Transformer比较" class="headerlink" title="LSTM与RNN，Transformer比较"></a>LSTM与RNN，Transformer比较</h3><ul>
<li>RNN：易梯度消失；（梯度小于1，反向传播越乘越小）</li>
<li>LSTM：缓解梯度消失；缓解长期依赖；但路径复杂，模型训练复杂</li>
<li>Transformer：可并行计算，解决长期依赖</li>
</ul>
<h3 id="为何出现梯度消失和梯度爆炸，LSTM又是如何解决（改善）的"><a href="#为何出现梯度消失和梯度爆炸，LSTM又是如何解决（改善）的" class="headerlink" title="为何出现梯度消失和梯度爆炸，LSTM又是如何解决（改善）的"></a>为何出现梯度消失和梯度爆炸，LSTM又是如何解决（改善）的</h3><p>原因：链式求导法则导致梯度表示为连乘积的形式，梯度过大或者过小会造成梯度消失和爆炸<br>忘记门：通过相乘加和形式保证梯度流传播稳定；<br>输入门：与普通RNN类似仍然是连乘形式，依旧会可能发生梯度问题。<br><strong>通过改善一条路径的梯度缓解总体的远距离梯度太弱的问题。</strong></p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>语言模型</title>
    <url>/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="语言模型简要整理"><a href="#语言模型简要整理" class="headerlink" title="语言模型简要整理"></a>语言模型简要整理</h1><h2 id="万物皆可Embedding"><a href="#万物皆可Embedding" class="headerlink" title="万物皆可Embedding"></a>万物皆可Embedding</h2><blockquote>
<blockquote>
<p>将one-hot映射为embedding，能够很好挖掘嵌入实体间的内部关联</p>
</blockquote>
</blockquote>
<p>1、高维-&gt;低维<br>2、稀疏-&gt;稠密<br>3、离散-&gt;连续<br>4、整数-&gt;实数</p>
<h3 id="高维稀疏"><a href="#高维稀疏" class="headerlink" title="高维稀疏"></a>高维稀疏</h3><p>不利于机器学习参数学习和相关计算；维度灾难；复杂度增加，过拟合；稀疏造成梯度消失；</p>
<h3 id="向量化好处"><a href="#向量化好处" class="headerlink" title="向量化好处"></a>向量化好处</h3><ul>
<li>不丢失信息降维</li>
<li>矩阵运算便于并行</li>
<li>向量空间比较相似性</li>
</ul>
<h2 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h2><p><a href="http://www.hankcs.com/nlp/word2vec.html" target="_blank" rel="noopener">网页版笔记在线看</a></p>
<h3 id="层序与负采样"><a href="#层序与负采样" class="headerlink" title="层序与负采样"></a>层序与负采样</h3><h4 id="层序"><a href="#层序" class="headerlink" title="层序"></a>层序</h4><p>层序模型：用哈夫曼树词频高的路径短，更易被搜索，对于生僻词路径更长，搜索树深更深；多个LR二分类；<br>将原来的softmax层拆解，将N分类问题转化成$log_2N$个二分类问题。<strong>用哈夫曼树代替隐藏层到softmax层的映射，左为1，右为0，且左子树权重&gt;=右子树权重</strong>哈夫曼树叶子节点起到输出层神经元的作用，内部节点起到隐层神经元的作用。</p>
<h4 id="负采样"><a href="#负采样" class="headerlink" title="负采样"></a>负采样</h4><p>原理：将softmax多分类问题转化成多次二分类问题，使得LR让一个训练样本每次仅更新一小部分的权重。<br>输入到输出，输出V中某个词对应节点输出1，其他V-1个节点输出0（负词）.随机选择5个来更新权重。<br>负采样：词频越大更被定为负样本，所以对生僻词更有优势<br><strong>提高训练速度，改善词向量质量</strong></p>
<h4 id="补充Huffman树"><a href="#补充Huffman树" class="headerlink" title="补充Huffman树"></a>补充Huffman树</h4><p>Huffman树只是二叉树中具体的一种，word2vec训练的时候按照词频将每个词语Huffman编码，由于Huffman编码中词频越高的词语对应的编码越短。所以越高频的词语在Hierarchical Softmax过程中经过的二分类节点就越少，整体计算量就更少了。</p>
<a id="more"></a>
<h4 id="负采样算法"><a href="#负采样算法" class="headerlink" title="负采样算法"></a>负采样算法</h4><p>任何采样算法都应该保证频次越高的样本越容易被采样出来。基本的思路是对于长度为1的线段，根据词语的词频将其公平地分配给每个词语：</p>
<script type="math/tex; mode=display">len(w)=\frac{counter(w)}{\sum _{u\epsilon D} counter(u)}</script><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/35.jpg" alt="avatat"><br>counter就是w的词频。word2vec用的是一种查表的方式，将上述线段标上M个“刻度”，刻度之间的间隔是相等的，即1/M：接着生成0-M之间的整数，去这个刻度尺上一查就能抽中一个单词了。对于机器学习中的分类任务，在训练的时候不但要给正例，还要给负例。对于Hierarchical Softmax，负例是二叉树的其他路径。对于Negative Sampling，负例是随机挑选出来的。Negative Sampling能<strong>提高速度、改进模型质量。</strong></p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/w2v.jpg" alt="avatar"><br><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/sg.jpg" alt="avatar"><br>Word2Vec模型是一个很大的神经网络；10000个单词的词汇表，如果嵌入300维的词向量，那么输入-隐层权重矩阵=隐层-输出层的权重矩阵都会有 10000 x 300 = 300万个权重。<strong>在如此庞大的神经网络中进行梯度下降是相当慢的，所以通过负采样仅对K+1个词的损失反向更新</strong>。中间隐层embedding拿出来做词向量，输入索引，U的输出就是embedding，然后再进行3.1，3.2的公式仅对K+1个词计算二分类的损失，再反向传播。而且隐层没有使用任何非线性激活函数，更简单。</p>
<h3 id="CBOW与Skip-gram"><a href="#CBOW与Skip-gram" class="headerlink" title="CBOW与Skip-gram"></a>CBOW与Skip-gram</h3><ul>
<li>CBOW：输入上下文，输出中心词；训练次数等同于样本次数V(词典大小)；效率高，训练质量不够充分；梯度值会同样的作用到每个周围词的词向量当中去； 相当于该生僻词没有收到专门的训练，生僻词不太友好</li>
<li>SKip-gram：输入中心词，输出上下文；训练次数为KV,即每个样本训练K次(窗口大小)；效率较低，训练质量充分；梯度不断的调整中心词的词向量；每个词在作为中心词的时候，都要进行K次的预测、调整，生僻词更友好</li>
<li>Skip-grem 处理少量数据时效果很好，对低频词更加友好，CBOW学习速度更快，高频词友好。</li>
</ul>
<h4 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h4><p>给定训练样本，即一个词w和它的上下文Context(w)，Context(w)是输入，w是输出。那么w就是正例，词汇表中其他的词语的就是负例。假设我们通过某种采样方法获得了负例子集NEG(w)。对于正负样本，分别定义一个标签：正样本为1，负样本为0。</p>
<script type="math/tex; mode=display">L^w(\tilde{w})=\left \{ 
\begin{array}{ll} 
1 & \tilde{w}=w;\\ 
0 & \tilde{w} \neq w;
\end{array}
\right.</script><p>对于给定正样本（Context(w),w）我们希望最大化</p>
<script type="math/tex; mode=display">g(w)=\prod _{
    u{\epsilon {\left \{ w \right \}} \cup NEG(w)}}
    p(u|Context(w))</script><p>其中，</p>
<script type="math/tex; mode=display">p(u|Context(w))=[\sigma (X_w^T\theta ^u)]^{L^w(u)}\cdot [1-\sigma(X_w^T\theta ^u)]^{1-L^w(u))}</script><p>也就是说，当u是正例时，$\sigma (X_w^T\theta ^u)$越大越好，当u是负例时，$\sigma (X_w^T\theta ^u)$越小越好。因为$\sigma (X_w^T\theta ^u)$ 等于模型预测样本为正例的概率，当答案就是正的时候，我们希望这个概率越大越好，当答案是负的时候，我们希望它越小越好，模型也符合极大似然估计。</p>
<script type="math/tex; mode=display">\log\prod _{w\epsilon C} g(w)=\sum _{w\epsilon C}\log g(w)</script><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/28.jpg" alt="avatat"><br>每个词都是如此，语料库有多个词，我们将g累积得到优化目标。因为对数方便计算，我们对其取对数得到目标函数：<br>训练伪码为：<img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/30.jpg" alt="avatat"></p>
<h4 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h4><p>对于(w,Context(w))我们希望最大化：</p>
<script type="math/tex; mode=display">g(w)=\prod _{\tilde{w}\epsilon Context(w)} \prod _{u\epsilon \left \{ w \right \}\cup NEG^{\tilde{w}}(w)}p(u|\tilde w)</script><p>其中，</p>
<script type="math/tex; mode=display">L =\sum _{w\epsilon C} \sum _{\tilde{w}\epsilon Context(w)} \sum _{u\epsilon \left \{ w \right  \}\cup NEG^{\tilde w }(w)} L(w,\tilde w,u)</script><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/34.jpg" alt="avatat"><br><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/33.jpg" alt="avatat"><br>训练伪码为：<img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/31.jpg" alt="avatat"></p>
<h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/LSTM.jpg" alt></p>
<ul>
<li>每个cell作为前馈网络层，num_units隐层神经元数；多值向量；不同时刻共享</li>
<li>$h_{t-1}$和$x(t)$横向拼接输入；</li>
<li>上面路径代表长时记忆；下面路径代表短时记忆。</li>
</ul>
<ol>
<li>输入和输出都用tanh而非sigmoid？<ol>
<li>输出保证0均值；</li>
<li>线性部分多；</li>
</ol>
</li>
</ol>
<h3 id="真实的物理结构"><a href="#真实的物理结构" class="headerlink" title="真实的物理结构"></a>真实的物理结构</h3><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/LSTM2.jpg" alt></p>
<h2 id="TextCNN"><a href="#TextCNN" class="headerlink" title="TextCNN"></a>TextCNN</h2><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/27.png" alt="avatar"></p>
<script type="math/tex; mode=display">W^*=\frac{(W-f+2p)}{s}+1</script><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><h3 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h3><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/17.png" alt="avatar"><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/16.png" alt="avatar"></p>
<p>各层结构相同，权重不共享</p>
<h3 id="编码器结构细节"><a href="#编码器结构细节" class="headerlink" title="编码器结构细节"></a>编码器结构细节</h3><p>we+pos_en，词向量+位置编码<br><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/25.png" alt="avatar"></p>
<h3 id="计算任意两词的注意力加权后的向量表示"><a href="#计算任意两词的注意力加权后的向量表示" class="headerlink" title="计算任意两词的注意力加权后的向量表示"></a>计算任意两词的注意力加权后的向量表示</h3><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/25.png" alt="avatar"><br><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/22.png" alt="avatar"></p>
<h4 id="补充soft-attention"><a href="#补充soft-attention" class="headerlink" title="补充soft-attention"></a>补充soft-attention</h4><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/soft.webp" alt></p>
<h3 id="单词的矩阵运算，获取注意力加权后的向量表示"><a href="#单词的矩阵运算，获取注意力加权后的向量表示" class="headerlink" title="单词的矩阵运算，获取注意力加权后的向量表示"></a>单词的矩阵运算，获取注意力加权后的向量表示</h3><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/24.png" alt="avatar"></p>
<h4 id="解码器端动态展示"><a href="#解码器端动态展示" class="headerlink" title="解码器端动态展示"></a>解码器端动态展示</h4><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/23.gif" alt="avatar"></p>
<hr>
<h2 id="EMLO——特征融合"><a href="#EMLO——特征融合" class="headerlink" title="EMLO——特征融合"></a>EMLO——特征融合</h2><p>word embedding：无法解决多义词问题；<br>elmo：we训练后获得上下文语义了，根据这个语义调整单词的we表示；we适配语义，完成多义词问题。<br>两阶段：语言模型预训练+下游任务。<br>语言模型预训练：we输入到双层双向LSTM网络；最终得到句子每个单词对应的(单词we，单词的句法信息，单词的语义信息)。每一个we对应一个权重a，累加求和整合成一个。<br><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/14.jpg" alt="avatar"></p>
<hr>
<h2 id="GPT——预训练-fine-tune"><a href="#GPT——预训练-fine-tune" class="headerlink" title="GPT——预训练+fine tune"></a>GPT——预训练+fine tune</h2><p>重点是Transformer，特征抽取的能力强于RNN，只有单向的特征提取能力。<br><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/20.jpg" alt="avatar"></p>
<hr>
<h2 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h2><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/21.jpg" alt="avatar"></p>
<h3 id="Mask-LM"><a href="#Mask-LM" class="headerlink" title="Mask LM"></a>Mask LM</h3><p>随机选择预料15%单词，用掩码覆盖，然后要求模型去正确预测被抠掉的单词。实际上80%真正被mask标记，10%替换成另外的词，10%未改。</p>
<h3 id="Next-Sentence-Prediction"><a href="#Next-Sentence-Prediction" class="headerlink" title="Next Sentence Prediction"></a>Next Sentence Prediction</h3><p>多任务训练，增加句子关系推断。（选择两个句子：语料中真正顺序相连的两个句子；或者选择随机取两个句子）判断第二个是否是第一个句子的后续句子。考虑到单词预测粒度到不了句子关系层级。</p>
<hr>
<h2 id="QA系统基本框架"><a href="#QA系统基本框架" class="headerlink" title="QA系统基本框架"></a>QA系统基本框架</h2><p><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/18.png" alt="avatar"><br><img src="/2019/10/25/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/19.png" alt="avatar"></p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow基础</title>
    <url>/2019/10/25/Tensorflow%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h1><ul>
<li>首先通过将程序分为两个独立的部分，包括计算图的定义及其执行。</li>
<li>图定义和执行的分开设计让 TensorFlow 能够多平台工作以及并行执行。</li>
<li>计算图：是包含节点和边的网络。定义所有要使用的数据，也就是张量（tensor）对象（常量、变量和占位符），同时定义要执行的所有计算，即运算操作对象（Operation Object，简称 OP）。</li>
<li>每个节点可以有零个或多个输入，但只有一个输出。网络中的节点表示对象（张量和运算操作），边表示运算操作之间流动的张量。</li>
</ul>
<hr>
<h2 id="一、数据类型：常量、变量、占位符"><a href="#一、数据类型：常量、变量、占位符" class="headerlink" title="一、数据类型：常量、变量、占位符"></a>一、数据类型：常量、变量、占位符</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量是其值不能改变的张量；常量存储在计算图的定义中<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.constant(<span class="number">4</span>);</span><br><span class="line">tf.constant([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">tf.zeros([M,N],tf.dtype)</span><br><span class="line">tf.zeros([<span class="number">2</span>,<span class="number">3</span>],tf.int32)</span><br><span class="line">tf.ones([M,N],tf,dtype)</span><br><span class="line">range_t = tf.linspace(<span class="number">2.0</span>,<span class="number">5.0</span>,<span class="number">4</span>)  <span class="comment">#等差数列，差值=(5-2)/(4-1)</span></span><br><span class="line">range_t = tf.range(<span class="number">10</span>) <span class="comment">#同python range</span></span><br><span class="line">tf.random_normal([shape],mean=<span class="number">2.0</span>,stddev=<span class="number">4</span>,seed=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在神经网络中的权重声明为变量来实现，变量在使用前需要被显示初始化。另外需要注意的是，每次加载图时都会加载相关变量。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常量初始变量</span></span><br><span class="line">weights=tf.Variable(tf.random_normal([m,n],stddev=<span class="number">2</span>))</span><br><span class="line">bias=tf.Variable(tf.zeros[<span class="number">100</span>],name=<span class="string">'bias'</span>)</span><br><span class="line">tf.Variable(tf.random_normal([self.feature_size,self.embedding_size],<span class="number">0.0</span>,<span class="number">0.01</span>),name=<span class="string">'feature_embeddings'</span>)</span><br><span class="line">tf.Variable(np.random.normal(loc=<span class="number">0</span>,scale=glorot,size(input_size,self.deep_layers[<span class="number">0</span>])),dtype=np.float32)</span><br><span class="line"><span class="comment">#变量初始变量</span></span><br><span class="line">weights_2=tf.Variable(weights.initialized_value,name=<span class="string">'w2'</span>)</span><br><span class="line">intial_op=tf.global_variables_initializer()</span><br></pre></td></tr></table></figure></p>
<h3 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h3><p>和 feed_dict 一起使用于将训练数据输入TensorFlow图中。在session运行计算图时，为占位符赋值。占位符不包含任何数据，只是数据的入口；<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=tf.placeholder(dtype,shape=<span class="literal">None</span>,name=<span class="literal">None</span>)</span><br><span class="line">y=<span class="number">2</span>*x</span><br><span class="line">data=tf.random_uniform([<span class="number">4</span>,<span class="number">5</span>],<span class="number">10</span>);</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    x_data=sess.run(data)</span><br><span class="line">    print(sess.run(y,feed_dict=&#123;x:x_data&#125;))</span><br></pre></td></tr></table></figure></p>
<h2 id="二、Tensorflow的重要API"><a href="#二、Tensorflow的重要API" class="headerlink" title="二、Tensorflow的重要API"></a>二、Tensorflow的重要API</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##输入输出 占位符</span></span><br><span class="line">tf.placeholder(tf.int32,shape=[<span class="literal">None</span>,<span class="literal">None</span>],name=<span class="string">'feat_index'</span>)</span><br><span class="line"><span class="comment">##embedding_lookup</span></span><br><span class="line">tf.nn.embedding_lookup(self.weights[<span class="string">'feature_embeddings'</span>],self.feat_index)</span><br><span class="line"><span class="comment">##改变维度</span></span><br><span class="line">tf.reshape(self.feat_value,shape=[<span class="number">-1</span>,self.field_size,<span class="number">1</span>])</span><br><span class="line"><span class="comment">##矩阵点乘</span></span><br><span class="line">tf.multiply(self.embeddings,feat_value)</span><br><span class="line"><span class="comment">##矩阵乘法</span></span><br><span class="line">tf.matmul(self.y_deep,self.weights[<span class="string">"layer_%d"</span> %i])</span><br><span class="line"><span class="comment">##矩阵加法</span></span><br><span class="line">tf.add(self.weights[<span class="string">"aa"</span>], self.weights[<span class="string">"bias_%d"</span>%i])</span><br><span class="line"><span class="comment">##dropout</span></span><br><span class="line">tf.nn.dropout(self.y_deep,self.dropout_keep_deep[i+<span class="number">1</span>])</span><br><span class="line"><span class="comment">##激活函数</span></span><br><span class="line">tf.sigmoid(x)  <span class="comment">#梯度消失严重</span></span><br><span class="line">tf.tanh(x)  <span class="comment">#会出现梯度消失</span></span><br><span class="line">tf.nn.relu(x)  <span class="comment">#神经元稀疏失活，leakrelu</span></span><br><span class="line">tf.nn.softmax(x)    <span class="comment">#多分类中表示一个类的概率</span></span><br><span class="line"><span class="comment">##损失函数</span></span><br><span class="line">self.loss = tf.losses.log_loss(self.label, self.out)</span><br><span class="line">self.loss = tf.nn.l2_loss(tf.subtract(self.label, self.out))</span><br><span class="line"><span class="comment">##优化器</span></span><br><span class="line">self.optimizer = tf.train.AdamOptimizer(learning_rate=self.learning_rate, beta1=<span class="number">0.9</span>, beta2=<span class="number">0.999</span>,epsilon=<span class="number">1e-8</span>).minimize(self.loss)</span><br><span class="line">self.optimizer = tf.train.AdagradOptimizer(learning_rate=self.learning_rate，initial_accumulator_value=<span class="number">1e-8</span>).minimize(self.loss)</span><br><span class="line"><span class="comment">##运行</span></span><br><span class="line">feed_dict = &#123;</span><br><span class="line">    self.feat_index: Xi,</span><br><span class="line">    self.feat_value: Xv,</span><br><span class="line">    self.label: y,</span><br><span class="line">    self.dropout_keep_deep: [<span class="number">1.0</span>] * len(self.dropout_dep),</span><br><span class="line">    self.train_phase: <span class="literal">True</span>&#125;</span><br><span class="line">loss,opt = self.sess.run([self.loss,self.optimizer],feed_dict=feed_dict)</span><br></pre></td></tr></table></figure>
<h2 id="三、Tenforflow实现线性回归"><a href="#三、Tenforflow实现线性回归" class="headerlink" title="三、Tenforflow实现线性回归"></a>三、Tenforflow实现线性回归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#使用numpy生成200个随机点</span></span><br><span class="line">x_data=np.linspace(<span class="number">-0.5</span>,<span class="number">0.5</span>,<span class="number">200</span>)[:,np.newaxis]</span><br><span class="line">noise=np.random.normal(<span class="number">0</span>,<span class="number">0.02</span>,x_data.shape)</span><br><span class="line">y_data=np.square(x_data)+noise</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义两个placeholder存放输入数据</span></span><br><span class="line">x=tf.placeholder(tf.float32,[<span class="literal">None</span>,<span class="number">1</span>])</span><br><span class="line">y=tf.placeholder(tf.float32,[<span class="literal">None</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义神经网络中间层</span></span><br><span class="line">Weights_L1=tf.Variable(tf.random_normal([<span class="number">1</span>,<span class="number">10</span>]))</span><br><span class="line">biases_L1=tf.Variable(tf.zeros([<span class="number">1</span>,<span class="number">10</span>]))    <span class="comment">#加入偏置项</span></span><br><span class="line">Wx_plus_b_L1=tf.matmul(x,Weights_L1)+biases_L1</span><br><span class="line">L1=tf.nn.tanh(Wx_plus_b_L1)   <span class="comment">#加入激活函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义神经网络输出层</span></span><br><span class="line">Weights_L2=tf.Variable(tf.random_normal([<span class="number">10</span>,<span class="number">1</span>]))</span><br><span class="line">biases_L2=tf.Variable(tf.zeros([<span class="number">1</span>,<span class="number">1</span>]))  <span class="comment">#加入偏置项</span></span><br><span class="line">Wx_plus_b_L2=tf.matmul(L1,Weights_L2)+biases_L2</span><br><span class="line">prediction=tf.nn.tanh(Wx_plus_b_L2)   <span class="comment">#加入激活函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数（均方差函数）</span></span><br><span class="line">loss=tf.reduce_mean(tf.square(y-prediction))</span><br><span class="line"><span class="comment">#定义反向传播算法（使用梯度下降算法训练）</span></span><br><span class="line">train_step=tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment">#变量初始化</span></span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="comment">#训练2000次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2000</span>):</span><br><span class="line">        sess.run(train_step,feed_dict=&#123;x:x_data,y:y_data&#125;)</span><br><span class="line">    <span class="comment">#获得预测值</span></span><br><span class="line">    prediction_value=sess.run(prediction,feed_dict=&#123;x:x_data&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>算法推导整理</title>
    <url>/2019/10/25/%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="公式推导整理"><a href="#公式推导整理" class="headerlink" title="公式推导整理"></a>公式推导整理</h1><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>当已知每一个样本数据$x^{(i)}$都对应一个类别变量$z^{(i)}$时，即$z=(z^{(1)},z^{(2)},\dots,z^{(m)})$，此时的极大化模型的对数似然函数可以通过全概率公式展开为</p>
<script type="math/tex; mode=display">
\begin{aligned}
\hat{\theta}&= \mathop{\arg\max}_{\theta} \sum\limits_{i=1}^m\log p(x^{(i)};\theta)\\
&= \mathop{\arg\max}_{\theta} \sum\limits_{i=1}^m\log \sum\limits_{z^{(i)}}p(x^{(i)},z^{(i)};\theta)
\end{aligned}</script><p>因为含有隐变量$z$故极大似然估计并不能够求解上述模型。</p>
<a id="more"></a>
<h3 id="求解含有隐变量的概率模型"><a href="#求解含有隐变量的概率模型" class="headerlink" title="求解含有隐变量的概率模型"></a>求解含有隐变量的概率模型</h3><p>通过引入隐变量$z^{(i)}$的概率分布为$Q_i(z^{(i)})$，因为$\log (x)$是凹函数故结合凹函数形式下的詹森不等式进行放缩处理</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum\limits_{i=1}^m\log \sum\limits_{z^{(i)}}p(x^{(i)},z^{(i)};\theta)&=\sum\limits_{i=1}^m\log \sum\limits_{z^{(i)}} Q_i(z^{(i)})\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}\\
&=\sum\limits_{i=1}^m\log \mathbb{E}(\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})})\\
&\ge\sum\limits_{i=1}^m\mathbb{E}[\log\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})})]\\
&=\sum\limits_{i=1}^m\sum\limits_{z^{(i)}}Q_i(z^{(i)})\log\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}
\end{aligned}</script><p>当不等式变成等式时说明调整后的概率能够等价于$\mathcal{L}(\theta)$，所以必须找到使得等式成立的条件，即寻找</p>
<script type="math/tex; mode=display">
\mathbb{E}[\log\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})})]=\log \mathbb{E}[\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}]</script><p>由期望得性质可知当</p>
<script type="math/tex; mode=display">
\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}=C,C \in R  (*)</script><p>等式成立，对上述等式进行变形处理可得</p>
<script type="math/tex; mode=display">
\begin{aligned}
&p(x^{(i)},z^{(i)};\theta)=CQ_i(z^{(i)})\\
&\Leftrightarrow
\sum\limits_{z^{(i)}}p(x^{(i)},z^{(i)};\theta)=C\sum\limits_{z^{(i)}}Q_i(z^{(i)})=C\\
&\Leftrightarrow
\sum\limits_{z^{(i)}}p(x^{(i)},z^{(i)};\theta)=C \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   (**)
\end{aligned}</script><p>把$<em>*​$式带入$</em>​$化简可知</p>
<script type="math/tex; mode=display">
\begin{aligned}
Q_i(z^{(i)})&=\dfrac{p(x^{(i)},z^{(i)};\theta)}{\sum\limits_{z^{(i)}}p(x^{(i)},z^{(i)};\theta)}\\
&=\dfrac{p(x^{(i)},z^{(i)};\theta)}{p(x^{(i)};\theta)}\\
&=p(z^{(i)}|x^{(i)};\theta)
\end{aligned}</script><p>至此$Q_i(z^{(i)})$的计算公式就是后验概率，解决了$Q_i(z^{(i)})$如何选择得问题。这一步称为$E$步，建立 $\mathcal{L}(\theta)$得下界；接下来得$M$步，就是在给定$Q_i(z^{(i)})$后，调整$\theta$去极大化$\mathcal{L}(\theta)$的下界即</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\mathop{\arg\max}_{\theta}\sum\limits_{i=1}^m\log p(x^{(i)};\theta)\\
&\Leftrightarrow
\mathop{\arg\max}_{\theta}\sum\limits_{i=1}^m\sum\limits_{z^{(i)}}Q_i(z^{(i)})\log\dfrac{p(x^{(i)},z^{(i)};\theta)}{Q_i(z^{(i)})}\\
&\Leftrightarrow
\mathop{\arg\max}_{\theta}\sum\limits_{i=1}^m\sum\limits_{z^{(i)}}Q_i(z^{(i)})\left[\log p(x^{(i)},z^{(i)};\theta)-\log Q_i(z^{(i)})\right]\\
&\Leftrightarrow
\mathop{\arg\max}_{\theta}\sum\limits_{i=1}^m\sum\limits_{z^{(i)}}Q_i(z^{(i)})\log p(x^{(i)},z^{(i)};\theta)
\end{aligned}</script><p>因此EM算法的迭代形式为<br>Repeats until it converges{<br>$E$ step：for every  $x^{(i)}$ calculate<br>$Q_i(z^{(i)})=p(z^{(i)}|x^{(i)};\theta)$<br>$M$ step：update  $\theta$<br>$\begin{aligned} \theta:=\mathop{\arg\max}_{\theta}\sum\limits_{i=1}^m\sum\limits_{z^{(i)}}Q_i(z^{(i)})\log p(x^{(i)},z^{(i)};\theta) \end{aligned}$<br>}</p>
<h3 id="收敛性证明"><a href="#收敛性证明" class="headerlink" title="收敛性证明"></a>收敛性证明</h3><script type="math/tex; mode=display">
\begin{aligned}
\mathcal{L}(\theta^{(k)})&=\sum\limits_{i=1}^m\sum\limits_{z^{(i)}}Q_i^{(k)}(z^{(i)})\log \dfrac{p(x^{(i)},z^{(i)};\theta^{(k)})}{Q_i(z^{(i)})} \ \ \ \ \ \ \ \ \ \ (a)\\
&\le \sum\limits_{i=1}^m\sum\limits_{z^{(i)}}Q_i^{(k)}(z^{(i)})\log \dfrac{p(x^{(i)},z^{(i)};\theta^{(k)})}{Q_i(z^{(i)})}\ \ \ \ \ \ \ \ \ \ (b)\\
&\le\mathcal{L}(\theta^{(k+1)})\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \  (c)
\end{aligned}</script><p>首先$(a)$式是前面$E$步所保证詹森不等式中的等式成立的条件，$(a)$到$(b)$是M步的定义，$(b)$到$(c)$对任意参数都成立，而其等式的条件是固定$\theta$并调整好$Q$时成立，$(b)$到$(c)$只是固定$Q$调整$\theta$，在得到$\theta^{(k+1)}$时，只是最大化$\mathcal{L}(\theta^{(k)})$，也就是$\mathcal{L}(\theta^{(k+1)})$的一个下界而没有使等式成立。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>EM算法可以保证收敛到一个稳定点，但是却不能保证收敛到全局的极大值点，因此它是局部最优的算法，当然，如果我们的优化目标L(θ,θj)是凸的，则EM算法可以保证收敛到全局最大值，这点和梯度下降法这样的迭代算法相同。</p>
<h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><script type="math/tex; mode=display">P(Y=c_k|X=x^{(i)}) = \dfrac{P(X=x^{(i)}|Y=c_k)P(Y=c_k)}{\sum\limits_{k=1}^K P(X=x^{(i)}|Y=c_k)P(Y=c_k)} \ \ \ \ \ \ \ \ \ \ \ (*)</script><p>由于朴素贝叶斯算法对条件概率分布作了条件独立性假设，故</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X=x^{(i)}|Y=c_k)&=P(X_1^{(i)}=x_1^{(i)},\cdots,X_n^{(i)}=x_n^{(i)}|Y=c_k)\\
&=\prod_{j=1}^n P(X_j^{(i)}=x_j^{(i)}|Y=c_k)
\end{aligned} \ \ \ \ \    (**)</script><p>将$<em> </em>$式带入$*$式中得到朴素贝叶斯算法的基本形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(Y=c_k|X=x^{(i)}) =\dfrac{\prod\limits_{j=1}^n P(X_j^{(i)}=x_j^{(i)}|Y=c_k)}{\sum\limits_{k=1}^K P(Y=c_k)\prod\limits_{j=1}^n P(X_j^{(i)}=x_j^{(i)}|Y=c_k)}P(Y=c_k)
\end{aligned}</script><p>因此朴素贝叶斯算法的优化模型为</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathop{\arg\max}_{c_k}\ P(Y=c_k|X=x^{(i)})&=\mathop{\arg\max}_{c_k}\ \dfrac{\prod\limits_{j=1}^n P(X_j^{(i)}=x_j^{(i)}|Y=c_k)}{\sum\limits_{k=1}^t P(Y=c_k)\prod\limits_{j=1}^n P(X_j^{(i)}=x_j^{(i)}|Y=c_k)}P(Y=c_k)\\
&=\mathop{\arg\max}_{c_k}\ P(Y=c_k)\prod\limits_{j=1}^n P(X_j^{(i)}=x_j^{(i)}|Y=c_k)
\end{aligned}</script><p>因为对于每一个类别$c_k$，分母$\sum\limits_{k=1}^t P(Y=c_k)\prod\limits_{j=1}^n P(X_j^{(i)}=x_j^{(i)}|Y=c_k)$的值都是相同的。</p>
<h4 id="朴素贝叶斯模型的求解"><a href="#朴素贝叶斯模型的求解" class="headerlink" title="朴素贝叶斯模型的求解"></a>朴素贝叶斯模型的求解</h4><p>​求解朴素贝叶斯模型相当于求解几个概率值，对于样本数据集可以求出先验概率</p>
<ul>
<li>$p(Y=c_k)$<script type="math/tex; mode=display">
p(Y=c_k)=\dfrac{\sum\limits_{i=1}^mI(y^{(i)}=c_k)}{t}\ \ \ \ \ k=1,2,\cdots,t</script>其中$I(x)$表示当$x$为真时函数值为$1$否则为$0$。</li>
<li>条件概率<script type="math/tex; mode=display">
\begin{aligned}
P(X_j^{(i)}=x_j^{(i)}|Y&=c_k)=\dfrac{\sum\limits_{i=1}^mI(x_j^{(i)}=a_{jl},y^{(i)}=c_k)}{\sum\limits_{i=1}^m I(y^{(i)}=c_k)}\\
&j=1,2,\cdots,n\\
&l=1,2,\cdots,S_j
\end{aligned}</script>其中$x_j^{(i)}$代表第$i$个样本的第$j$个特征$x_j^{(i)}\in\{a_{j1},a_{j2},\cdots,a_{jS_j}\}$，$a_{jl}$表示第$j$个特征取得第$l$个值。</li>
</ul>
<h2 id="GBDT-vs-XGBDT"><a href="#GBDT-vs-XGBDT" class="headerlink" title="GBDT vs XGBDT"></a>GBDT vs XGBDT</h2><p>GBDT目标函数最终形式为：</p>
<script type="math/tex; mode=display">Obj^{(k)}=\sum\limits_{i=1}^m L(y^{(i)},\hat{y}^{(i)}_{k-1})+g_if_k(x^{(i)})</script><p>XGBDT目标函数最终形式为：</p>
<script type="math/tex; mode=display">\begin{aligned} Obj^{(k)}&==\sum\limits_{i=1}^mL(y^{(i)},\hat{y}^{(i)}_{k-1}+f_k(x^{(i)}))+\Omega(f_k)+C \end{aligned}</script><hr>
<h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>为了求损失函数$L(y^{(i)},\hat{y}^{(i)}_{k-1}+f_k(x^{(i)}))​$在$\ \hat{y}^{(i)}_{k-1} \ ​$处的二阶展开，且记$\nabla_{\hat{y}^{(i)}_{k-1}}L\left(y^{(i)},\hat{y}^{(i)}_{k-1}\right)$为$g_i$、$\nabla^2_{\hat{y}^{(i)}_{k-1}}L\left(y^{(i)},\hat{y}^{(i)}_{k-1}\right)$为$h_i​$则有：</p>
<script type="math/tex; mode=display">
L\left(y^{(i)},\hat{y}^{(i)}_{k-1}+f_k(x^{(i)})\right)\simeq L(y^{(i)},\hat{y}^{(i)}_{k-1})+g_if_k(x^{(i)})+\dfrac{1}{2}h_if^2_k(x^{(i)})</script><p>又因为在第$k$步$\hat{y}^{(i)}_{k-1}$其实是已知的，所以$l(y^{(i)},\hat{y}^{(i)}_{k-1})$是一个常数函数，故对优化目标函数不会产生影响，将上述结论带入目标函数$Obj^{(k)}$可得：</p>
<script type="math/tex; mode=display">Obj^{(k)}\simeq\sum\limits_{i=1}^m\bigg[ g_if_k(x^{(i)})+\dfrac{1}{2}h_if^2_k(x^{(i)})\bigg]+\Omega(f_k)</script><h4 id="决策树函数-f-k"><a href="#决策树函数-f-k" class="headerlink" title="决策树函数$f_k$"></a>决策树函数$f_k$</h4><p>对于任意决策树$f_k$，假设其叶子结点个数$T​$，该决策树是由所有结点对应的值组成的向量$\ w\in\mathbb{R}^T\ ​$，以及能够把特征向量映射到叶子结点的函数$\ q(*):\mathbb{R}^d\rightarrow \{1,2,\cdots,T \} \ ​$构造而成的，且每个样本数据都存在唯一的叶子结点上。因此决策树$\ f_k\ ​$可以定义为$\ f_k(x)=w_{q(x)} \ ​$。</p>
<h4 id="决策树的复杂度"><a href="#决策树的复杂度" class="headerlink" title="决策树的复杂度"></a>决策树的复杂度</h4><p>由正则项$\ \Omega(f_k)=\gamma T+\dfrac{1}{2}\lambda\sum\limits_{j=1}^Tw_j^2 \ ​$来定义，该正则项表明决策树模型的复杂度可以由叶子结点的数量和叶子结点对应值向量$\ w \ ​$的$\ L2\ ​$范数决定。定义集合$\ I_j=\{i|q(x^{(i)})=j \}\ ​$为划分到叶子结点$\ j \ ​$的所有训练样本的集合，即之前训练样本的集合，现在都改写成叶子结点的集合。</p>
<h4 id="XGBoost的目标函数"><a href="#XGBoost的目标函数" class="headerlink" title="XGBoost的目标函数"></a>XGBoost的目标函数</h4><p>因此$\ XGBoost\ ​$算法的目标函数可以改写为：</p>
<script type="math/tex; mode=display">\begin{aligned}
Obj^{(k)}&\simeq\sum\limits_{i=1}^m\bigg[ g_if_k(x^{(i)})+\dfrac{1}{2}h_if^2_k(x^{(i)})\bigg]+\Omega(f_k)\\
&=\sum\limits_{i=1}^m\bigg[g_iw_{q(x^{(i)})}+\dfrac{1}{2}h_jw^2_{q(x^{(i)})} \bigg]+\gamma T+\dfrac{1}{2}\lambda\sum\limits_{j=1}^Tw_j^2\\
&=\sum\limits_{j=1}^T\bigg[(\sum\limits_{i\in I_j}g_i)w_j+\dfrac{1}{2}(\sum\limits_{i\in I_j}h_i+\lambda)w_j^2 \bigg]+\gamma T
\end{aligned}</script><p>令$G_j=\sum\limits_{i\in I_j}g_i ,\ H_j=\sum\limits_{i\in I_j}h_i$则有：</p>
<script type="math/tex; mode=display">Obj^{(k)}\simeq\sum\limits_{j=1}^T\bigg[G_jw_j+\dfrac{1}{2}(H_j+\lambda)w_j^2 \bigg]</script><p>分析可知当更新到第$\ k\ ​$步时，此时<strong>决策树结构固定的情况下</strong>，每个叶子结点有哪些样本是已知的，那么$\ q(*)\ ​$和$\ I_j\ ​$也是已知的；又因为$\ g_i\ ​$和$\ h_i\ ​$是第$\ k-1\ ​$步的导数，那么也是已知的，因此$\ G_j\ ​$和$\ H_j\ ​$都是已知的。令目标函数$\ Obj^{(k)}\ ​$的一阶导数为$\ 0\ ​$，即可求得叶子结点$\ j\ ​$对应的值为：</p>
<script type="math/tex; mode=display">w^*_j=-\dfrac{G_j}{H_j+\lambda}</script><p>因此针对于结构固定的决策树，最优的目标函数$Obj$为：</p>
<script type="math/tex; mode=display">Obj=-\dfrac{1}{2}\sum\limits_{j=1}^T\dfrac{G_j^2}{H_j+\lambda}+\gamma T</script><h3 id="决策树构造"><a href="#决策树构造" class="headerlink" title="决策树构造"></a>决策树构造</h3><p>通常使用贪心策略来生成决策树的每个结点，$XGBoost$算法的在决策树的生成阶段就对过拟合的问题进行了处理，因此无需独立的剪枝阶段，具体步骤可以归纳为：</p>
<ol>
<li>从深度为$0$的树开始对每个叶子结点穷举所有的可用特征；</li>
<li>针对每一个特征，把属于该结点的训练样本的该特征升序排列，通过线性扫描的方式来决定该特征的<strong>最佳分裂点</strong>，并采用最佳分裂点时的<strong>收益</strong>；</li>
<li>选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，把该结点生成出左右两个新的叶子结点，并为每个新结点关联新的样本集；</li>
<li>退回到第一步，继续递归操作直到满足特定条件。</li>
</ol>
<p>因为对某个结点采取的是二分策略，分别对应左子结点和右子结点，除了当前待处理的结点，其他结点对应的$\ Obj \ ​$值都不变，所以对于收益的计算只需要考虑当前结点的$\ Obj \ ​$值即可，分裂前针对该结点的最优目标函数为：</p>
<script type="math/tex; mode=display">Obj^{(before)}=-\dfrac{1}{2}\dfrac{(G_L+G_R)^2}{(H_L+H_R)+\lambda}+\gamma</script><p>分裂后的最优目标函数为：</p>
<script type="math/tex; mode=display">Obj^{(later)}=-\dfrac{1}{2}\bigg[\dfrac{G_L^2}{H_L+\lambda}+\dfrac{G_R^2}{H_R+\lambda} \bigg]+2\gamma</script><p>那么对于该目标函数来说，分裂后的收益为：</p>
<script type="math/tex; mode=display">\begin{aligned}
Gain&=Obj^{(before)}-Obj^{(later)}\\
&=\dfrac{1}{2}\bigg[\dfrac{G_L^2}{H_L+\lambda}+\dfrac{G_R^2}{H_R+\lambda}-\dfrac{(G_L+G_R)^2}{(H_L+H_R)+\lambda} \bigg]-\gamma
\end{aligned}</script><p>故可以用上述公式来决定最有分裂特征和最优特征分裂点。</p>
<h2 id="FM算法"><a href="#FM算法" class="headerlink" title="$FM算法$"></a>$FM算法$</h2><script type="math/tex; mode=display">LR：
y=w_0+\sum\limits_{i=1}^nw_ix_i</script><p><strong>在数据非常稀疏的情况下很难满足$x_i、x_j$都不为$0$，这样将会导致$w_{ij}$不能够通过训练得到</strong>，引入辅助向量$V$用$w_{ij}=\mathbf{v}_i\mathbf{v}_j^T$对$w$进行分解</p>
<script type="math/tex; mode=display">
w=VV^T=
\begin{bmatrix}
\mathbf{v}_1\\
\mathbf{v}_2\\
\vdots\\
\mathbf{v}_n
\end{bmatrix}
\begin{bmatrix}
\mathbf{v}_1^T &
\mathbf{v}_2^T &
\cdots &
\mathbf{v}_n^T
\end{bmatrix}</script><p>综上可以发现原始模型的二项式参数为$\frac{n(n-1)}{2}$个，现在减少为$kn(k\ll n)$个。引入辅助向量$V$最为重要的一点是使得$x_tx_i$和$x_ix_j$的参数不再相互独立，这样就能够在样本数据稀疏的情况下合理的估计模型交叉项的参数</p>
<script type="math/tex; mode=display">
\begin{aligned}
\langle\mathbf{v}_t,\mathbf{v}_i\rangle&=\sum\limits_{f=1}^k\mathbf{v}_{tf}\cdot\mathbf{v}_{if}\\
\langle\mathbf{v}_i,\mathbf{v}_j\rangle&=\sum\limits_{f=1}^k\mathbf{v}_{if}\cdot\mathbf{v}_{jf}
\end{aligned}</script><p><strong>$x_tx_i$和$x_ix_j$的参数分别为$\langle\mathbf{v}_{t},\mathbf{v}_i \rangle$和$\langle\mathbf{v}_{i},\mathbf{v}_j \rangle$，它们之间拥有共同项$\mathbf{v}_i$，即所有包含$\mathbf{v}_i$的非零组合特征的样本都可以用来学习隐向量$\mathbf{v}_i$，而原始模型中$w_{ti}$和$w_{ij}$却是相互独立的，这在很大程度上避免了数据稀疏造成的参数估计不准确的影响。因此原始模型可以改写为最终的$FM$算法</strong></p>
<script type="math/tex; mode=display">
y=w_0+\sum\limits_{i=1}^nw_ix_i+\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^n \langle\mathbf{v}_i,\mathbf{v}_j \rangle x_ix_j</script><p>由于求解上述式子的时间复杂度为$\mathcal{O}(n^2)$，可以看出主要是最后一项计算比较复杂，因此从数学上对该式最后一项进行一些改写可以把时间复杂度降为$\mathcal{O}(kn)$</p>
<script type="math/tex; mode=display">
\begin{aligned} & \sum_{i=1}^{n-1} \sum_{j=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j} \\=& \frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{j}\right\rangle x_{i} x_{j}-\frac{1}{2} \sum_{i=1}^{n}\left\langle\mathbf{v}_{i}, \mathbf{v}_{i}\right\rangle x_{i} x_{i} \\=& \frac{1}{2}\left(\sum_{i=1}^{n} \sum_{j=1}^{n} \sum_{f=1}^{k} \mathbf{v}_{if} \mathbf{v}_{jf} x_{i} x_{j}-\sum_{i=1}^{n} \sum_{f=1}^{k} \mathbf{v}_{if} \mathbf{v}_{if} x_{i} x_{i}\right) \\=& \frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} \mathbf{v}_{if} x_{i}\right)\left(\sum_{j=1}^{n} \mathbf{v}_{jf} x_{j}\right)-\sum_{i=1}^{n} \mathbf{v}_{if}^{2} x_{i}^{2}\right) \\=& \frac{1}{2} \sum_{f=1}^{k}\left(\left(\sum_{i=1}^{n} \mathbf{v}_{if} x_{i}\right)^{2}-\sum_{i=1}^{n} \mathbf{v}_{if}^{2} x_{i}^{2}\right) \end{aligned}</script><h3 id="FM-算法小结"><a href="#FM-算法小结" class="headerlink" title="$FM$算法小结"></a>$FM$算法小结</h3><ul>
<li>$FM$算法降低了因数据稀疏，导致特征交叉项参数学习不充分的影响；</li>
<li>$FM$算法提升了参数学习效率和模型预估的能力。</li>
</ul>
<h2 id="L1，L2正则"><a href="#L1，L2正则" class="headerlink" title="L1，L2正则"></a>L1，L2正则</h2><p>L1正则加上L1范数；L2正则加上L2范数<br>$L1$正则化和$L2$正则化的符号化描述假设待优化函数为$f(\theta)$，其中$\theta\in R^n$，那么优化问题可以转化为求</p>
<script type="math/tex; mode=display">\mathop{\arg\min}_{\theta}\ f(\theta)</script><p>$L1$正则化，即对参数$\theta$加上$L1$范数约束</p>
<script type="math/tex; mode=display">\mathop{\arg\min}_{\theta}\ J_1(\theta)=f(\theta)+\color{magenta}\lambda\Vert\theta\Vert_1</script><p>$L2$正则化，即对参数$\theta$加上$L2$范数的平方约束</p>
<script type="math/tex; mode=display">\mathop{\arg\min}_{\theta}\ J_2(\theta)=f(\theta)+\color{magenta}\lambda\Vert\theta\Vert_2^2</script><h3 id="从贝叶斯先验概率看正则化"><a href="#从贝叶斯先验概率看正则化" class="headerlink" title="从贝叶斯先验概率看正则化"></a>从贝叶斯先验概率看正则化</h3><p>假设输入空间是$X\in R^{n}$,输出空间是$Y$，不妨假设含有$m$个样本数据($x^{(1)}$,$y^{(1)}$)、($x^{(2)}$,$y^{(2)}$)、$\cdots$、($x^{(m)}$,$y^{(m)}$)，其中$x^{(i)}\in X、y^{(i)}\in Y$。贝叶斯学派认为参数$\theta$也是服从某种概率分布的，即先给定$\theta$的先验分布为$p(\theta)$，然后根据贝叶斯定理$\color{Red}P(\theta|(X, Y))= \dfrac{P((Y,X);\theta)\times P(\theta)}{P(X,Y)}\sim P(Y|X;\theta)\times P(\theta)$（这里的$Y|X$仅仅是一种记号，代表给定的$X$对应相关的$Y$），因此通过极大似然估计可求参数$\theta$。</p>
<script type="math/tex; mode=display">
\mathop{\arg\max}_{\theta}\ L(\theta)=\prod_{i=1}^{m}p(y^{(i)}|x^{(i)};\theta)p(\theta)</script><p>等价于求解对数化极大似然函数$L(\theta)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathop{\arg\max}_{\theta}\ L(\theta)&=\log L(\theta)\\
&=\sum\limits_{i=1}^m\log p(y^{(i)}|x^{(i)};\theta)+\sum\limits_{i=1}^m\log p(\theta)\\ \\
\Leftrightarrow \mathop{\arg\min}_{\theta}\ -L(\theta)&=-\log L(\theta) \\
&=-\sum\limits_{i=1}^m\log p(y^{(i)}|x^{(i)};\theta)-\sum\limits_{i=1}^m\log p(\theta)\\
&=f(\theta)\color{magenta}-\sum\limits_{i=1}^m\log p(\theta)
\end{aligned}</script><h3 id="L1-正则化的概率解释"><a href="#L1-正则化的概率解释" class="headerlink" title="$L1$正则化的概率解释"></a>$L1$正则化的概率解释</h3><p>假设$\theta$服从的先验分布为均值为$0$参数为$\lambda$的拉普拉斯分布，即$\theta\sim La(0, \lambda)$其中，$p(\theta)= \frac{1}{2\lambda}e^{- \frac{|\theta|}{\lambda}}$。因此，上述优化函数可转换为：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathop{\arg\min}_{\theta}\ f(\theta)\color{magenta}-\sum\limits_{i=1}^m\log p(\theta)\\
&=f(\theta)-\sum\limits_{i=1}^m\log \frac{1}{2\lambda}e^{-\frac{|\theta_i|}{\lambda}}\\
&=f(\theta)-\sum\limits_{i=1}^m \log\frac{1}{2\lambda} + \frac{1}{\lambda}\sum\limits_{i=1}^m|\theta_i|\\
&\Leftrightarrow \mathop{\arg\min}_{\theta}\ f(\theta) + \color{magenta}\lambda\Vert\theta\Vert_1
\end{aligned}</script><p><strong>从上面的数学推导可以看出，$L1$正则化可以看成是：通过假设权重参数$\theta​$的先验分布为拉普拉斯分布，由最大后验概率估计导出。</strong>​</p>
<h3 id="L2-正则化的概率解释"><a href="#L2-正则化的概率解释" class="headerlink" title="$L2$正则化的概率解释"></a>$L2$正则化的概率解释</h3><p>假设$\theta$服从的先验分布为均值为$0$方差为$\sigma^2$的正态分布，即$\theta\sim \mathcal{N} (0, \sigma^2)$其中，$p(\theta)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{\theta^2}{2\sigma^2}}$。因此，上述优化函数可转换为：</p>
<script type="math/tex; mode=display">\begin{aligned}
&\mathop{\arg\min}_{\theta}\ f(\theta)\color{magenta}-\sum\limits_{i=1}^m\log p(\theta)\\
&=f(\theta)-\sum\limits_{i=1}^m\log \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{\theta_i^2}{2\sigma^2}}\\
&=f(\theta)-\sum\limits_{i=1}^m \log \frac{1}{\sqrt{2\pi}\sigma} + \frac{1}{2\sigma^2}\sum\limits_{i=1}^m \theta_i^2\\
&\Leftrightarrow\mathop{\arg\min}_{\theta} f(\theta) + \color{magenta}\lambda\Vert\theta\Vert_2^2
\end{aligned}</script><p><strong>从上面的数学推导可以看出，$L2$正则化可以看成是：通过假设权重参数$\theta$的先验分布为正态分布，由最大后验概率估计导出。</strong></p>
<h2 id="LSTM与GRU"><a href="#LSTM与GRU" class="headerlink" title="LSTM与GRU"></a>LSTM与GRU</h2><p>LSTM：忘记门+输入门+输出门<br>GRU：重置门+更新门</p>
<h2 id="PCA降维"><a href="#PCA降维" class="headerlink" title="PCA降维"></a>PCA降维</h2><p>最大方差原理：</p>
<ol>
<li>对m*n数据按列组成n*m；</li>
<li>对数据，按行进行0均值化；</li>
<li>求协方差矩阵<script type="math/tex; mode=display">C=\dfrac{1}{m}XX^T</script></li>
<li>对C求特征值，特征向量；按大小排列，取前K行</li>
<li>Y=P*X 为X降维后的K维数据</li>
</ol>
<h2 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h2><script type="math/tex; mode=display">\begin{aligned} sign(x) =
\begin{cases}
+1, & ifx \geqslant 0  \\
-1, &{otherwise}
\end{cases}
\end{aligned}</script><p>因此可知感知机的假设函数为$\psi (x)$,通过输入特征向量$x$即可判断其所属类别。</p>
<p>误分类点集$M$中所有点到超平面$S$的距离之和为</p>
<script type="math/tex; mode=display">-\dfrac{1}{\Vert \omega\Vert_2}\sum\limits_{(x^{(i)},y^{(i)})\in M}y^{(i)}(w^Tx^{(i)}+b)</script><p>所以求解最小化距离之和可知</p>
<script type="math/tex; mode=display">\begin{aligned} \mathop{\arg\min}_{\omega, b} L(\omega,b) & \Leftrightarrow \mathop{\arg\min}_{\omega, b} -\dfrac{1}{\Vert \omega\Vert_2}\sum\limits_{(x^{(i)},y^{(i)})\in M}y^{(i)}(w^Tx^{(i)}+b)\ & \Leftrightarrow \mathop{\arg\min}_{\omega, b} -\sum\limits_{(x^{(i)},y^{(i)})\in M}y^{(i)}(w^Tx^{(i)}+b)\ \end{aligned}</script><p>综上可知，感知机算法的损失函数为</p>
<script type="math/tex; mode=display">L(\omega,b)=-\sum\limits_{(x^{(i)},y^{(i)})\in M}y^{(i)}(w^Tx^{(i)}+b)</script><h2 id="BP反向传播算法"><a href="#BP反向传播算法" class="headerlink" title="BP反向传播算法"></a>BP反向传播算法</h2><h3 id="函数与输出"><a href="#函数与输出" class="headerlink" title="函数与输出"></a>函数与输出</h3><script type="math/tex; mode=display">E_d\equiv\frac{1}{2}\sum_{i\in outputs}(t_i-y_i)^2</script><ul>
<li>隐层输出<script type="math/tex; mode=display">net_{j}=\vec{w_j}·\vec{x_j}=\sum_{i}{w_{ji}}x_{ji}</script></li>
<li>梯度下降<script type="math/tex; mode=display">w_{ji}\gets w_{ji}-\eta\frac{\partial{E_d}}{\partial{w_{ji}}}</script></li>
<li>激活函数<script type="math/tex; mode=display">a_j=\sigma(net_j)</script></li>
<li>反向传播<script type="math/tex; mode=display">\frac{\partial{E_d}}{\partial{w_{ji}}}=\frac{\partial{E_d}}{\partial{net_j}}·\frac{\partial{net_j}}{\partial{w_{ji}}}\\
=\frac{\partial{E_d}}{\partial{net_j}}·\frac{\partial{\sum_{i}{w_{ji}}x_{ji}}}{\partial{w_{ji}}}\\
=\frac{\partial{E_d}}{\partial{net_j}}·x_{ji}</script>对于$\frac{\partial{E_d}}{\partial{net_j}}$的推导，需要区分输出层和隐藏层两种情况:</li>
</ul>
<h3 id="输出层-i-gt-j"><a href="#输出层-i-gt-j" class="headerlink" title="输出层$i-&gt;j$"></a>输出层$i-&gt;j$</h3><script type="math/tex; mode=display">\frac{\partial{E_d}}{\partial{net_j}}=\frac{\partial{E_d}}{\partial{y_j}}·\frac{\partial{y_j}}{\partial{net_j}}\\</script><script type="math/tex; mode=display">\frac{\partial{E_d}}{\partial{y_j}}=\frac{\partial}{\partial{y_j}}\frac{1}{2}\sum_{i\in outputs}(t_i-y_i)^2
=\frac{\partial}{\partial{y_j}}\frac{1}{2}(t_j-y_j)^2
=-(t_j-y_j)</script><script type="math/tex; mode=display">\frac{\partial{y_j}}{\partial{net_j}}=\frac{\partial sigmoid(net_j)}{\partial{net_j}}
=y_j(1-y_j)</script><p>故</p>
<script type="math/tex; mode=display">\frac{\partial{E_d}}{\partial{net_j}}=-(t_j-y_j)y_j(1-y_j)</script><p>同时令</p>
<script type="math/tex; mode=display">\delta_j=(t_j-y_j)y_j(1-y_j)</script><h3 id="隐藏层-j-gt-k"><a href="#隐藏层-j-gt-k" class="headerlink" title="隐藏层$j-&gt;k$"></a>隐藏层$j-&gt;k$</h3><script type="math/tex; mode=display">\frac{\partial{E_d}}{\partial{net_j}}=\sum_{k\in Downstream(j)}\frac{\partial{E_d}}{\partial{net_k}}·\frac{\partial{net_k}}{\partial{net_j}}\\
=\sum_{k\in Downstream(j)}-\delta_k·\frac{\partial{net_k}}{\partial{net_j}}\\
=\sum_{k\in Downstream(j)}-\delta_k·\frac{\partial{net_k}}{\partial{a_j}}·\frac{\partial{a_j}}{\partial{net_j}}\\
=\sum_{k\in Downstream(j)}-\delta_k·w_{kj}·\frac{\partial{a_j}}{\partial{net_j}}\\
=\sum_{k\in Downstream(j)}-\delta_k·w_{kj}·a_j(1-a_j)\\
=-a_j(1-a_j)\sum_{k\in Downstream(j)}\delta_kw_{kj}</script><p>因为$\delta_j=-\frac{\partial{E_d}}{\partial{net_j}}$，带入上式得到：</p>
<script type="math/tex; mode=display">\delta_j=a_j(1-a_j)\sum_{k\in Downstream(j)}\delta_kw_{kj}</script><h2 id="回归算法与最小二乘"><a href="#回归算法与最小二乘" class="headerlink" title="回归算法与最小二乘"></a>回归算法与最小二乘</h2><p>对于二次函数梯度下降算法最终会收敛到全局最小值。下面使用梯度下降算法求解上面推导出的线性回归模型的损失函数$\ J(\theta)=\dfrac{1}{2}\sum\limits_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2$，为了实现该算法首先要求出损失函数$J(\theta)$对参数$\theta_j$的梯度：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\nabla_{\theta_j} J(\theta) &=\nabla_{\theta_j} \dfrac{1}{2} \sum\limits_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2\\
&=2\cdot\dfrac{1}{2}\sum\limits_{i=1}^m(h_\theta(x^{(i)})-y^{(i)}) \nabla_{\theta_j}(h_\theta(x^{(i)})-y^{(i)})\\
&=\sum\limits_{i=1}^m(h_\theta(x^{(i)})-y^{(i)}) \nabla_{\theta_j}\theta^Tx^{(i)}\\
&=\sum\limits_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}
\end{aligned}</script><p>因此在线性回归模型中利用所有的样本数据，训练梯度下降算法的完整迭代格式为</p>
<script type="math/tex; mode=display">
\theta_j:=\theta_j-\alpha \sum\limits_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} \ \ \ ( j\ \  for \ \ 0 \ \sim \ n)</script><p>上述迭代过程每次迭代都会使用所有的样本数据，数学上已经证明线性回归模型的损失函数通过梯度下降算法求解一定会全局收敛，所以如果要编程实现该算法只需要控制迭代次数即可，不过对于线性回归模型的求解一般不用梯度下降算法，还有更容易实现且更快捷的形式—正规方程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般情况下对于求解线性回归模型通常采用正规方程的方式，回过头来对于文章开头的求解一元线性回归方程系数的问题可以大大化简，具体参数形式为</p>
<script type="math/tex; mode=display">\begin{bmatrix}
\alpha\\
\beta
 \end{bmatrix}
 =\left(\begin{bmatrix}
  1 & x_1^T\\
  1 & x_2^T\\
  \vdots & \vdots\\
  1 & x_n^T
 \end{bmatrix}^T
  \begin{bmatrix}
  1 & x_1^T\\
  1 & x_2^T\\
  \vdots & \vdots\\
  1 & x_n^T
 \end{bmatrix}\right)^{-1}
  \begin{bmatrix}
  1 & x_1^T\\
  1 & x_2^T\\
  \vdots & \vdots\\
  1 & x_n^T
 \end{bmatrix}^T
  \begin{bmatrix}
 y_1\\y_2\\ \vdots \\ y_n
 \end{bmatrix}</script><p>可以看出通过正规方程求解线性回归模型就转化为如何构造$X$矩阵，只要$X$矩阵构造出来后剩下的就是交给计算机做矩阵乘法运算就可以了。</p>
<h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><h3 id="k-means算法的损失函数"><a href="#k-means算法的损失函数" class="headerlink" title="k-means算法的损失函数"></a>k-means算法的损失函数</h3><p>假设输入空间 $X \in R^n$ 为$n$维向量的集合，$X=\{x^{(1)} ,x^{(2)},\cdots,x^{(m)} \}$，$\mathcal  C$为输入空间$X$的一个划分，不妨令$\mathcal C=\{ \mathbb C_1,\mathbb C_2,\cdots,\mathbb C_K \}$，因此可以定义$k-means$算法的损失函数为</p>
<script type="math/tex; mode=display">
J(\mathcal C)=\sum\limits_{k=1}^K\sum\limits_{x^{(i)}\in \mathbb C_k}\Vert x^{(i)}-\mu^{(k)} \Vert_2^2</script><p>其中$\mu^{(k)}=\frac{1}{\vert \mathbb C_k \vert}\sum\limits_{x^{(i)}\in\mathbb C_k}x^{(i)}$是簇$\mathbb C_k$的聚类中心。</p>
<h3 id="优化损失函数"><a href="#优化损失函数" class="headerlink" title="优化损失函数"></a>优化损失函数</h3><p>$k\text{-}means$算法的损失函数$J(\mathcal C)$描述了簇类样本围绕簇聚类中心的紧密程度，其值越小，则簇内样本的相似度越高。故$k\text{-}means$算法的优化目标为最小化损失函数</p>
<script type="math/tex; mode=display">argmin_{c} J(\mathcal C)=\sum\limits_{k=1}^K\sum\limits_{x^{(i)}\in \mathbb C_k}\Vert x^{(i)}-\mu^{(k)} \Vert_2^2</script><p>如果要优化该损失函数就需要考虑输入空间$\mathcal X$的所有划分，这是一个$NP\text{-}hard$问题，实际上是采取贪心的策略通过迭代优化来近似求解，该过程等价于<a href="https://zhuanlan.zhihu.com/p/39490840" target="_blank" rel="noopener">$EM$算法</a>。</p>
<ol>
<li>首先随机初始化$K$个聚类中心，$\mu^{(1)},\mu^{(2)},\cdots,\mu^{(K)}$；</li>
<li>然后根据这$K$个聚类中心给出输入空间$\mathcal X$的一个划分，$\mathbb C_1,\mathbb C_2,\cdots,\mathbb C_K$；<ul>
<li>样本离哪个簇的聚类中心最近，则该样本就划归到那个簇<script type="math/tex; mode=display">\mathop{\arg\min}_{k}\ \Vert x^{(i)}-\mu^{(k)} \Vert_2^2</script></li>
</ul>
</li>
<li>再根据这个划分来更新这$K$个聚类中心<script type="math/tex; mode=display">
 \mu^{(k)}=\frac{1}{\vert \mathbb C_k \vert}\sum\limits_{x^{(i)}\in\mathbb C_k}x^{(i)}</script></li>
<li>重复2、3步骤直至收敛<ul>
<li>即$K$个聚类中心不再变化</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>linux</title>
    <url>/2019/10/25/linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>更多命令参考<br><a href="https://zhuanlan.zhihu.com/p/36093355" target="_blank" rel="noopener">Linux常用命令总结</a></p>
<ul>
<li>ps：查看当前进程<ol>
<li>ps -ef (system v 输出)</li>
<li>ps -aux bsd 格式输出</li>
<li>ps -ef | grep pid</li>
</ol>
</li>
<li>ln：软连接，快捷方式；硬链接：同步更改。</li>
<li>chmod abc file a,b,c：分别表示User、Group、及Other的权限。若要rwx属性则4+2+1=7</li>
<li>vi 文件名编辑 cat file | more | less<ol>
<li>more 分页</li>
<li>less 分页可回翻</li>
<li>tail 尾部</li>
<li>head 头部</li>
</ol>
</li>
</ul>
<a id="more"></a>
<ul>
<li>wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。</li>
<li>grep [string] filename grep <sup><a href="#fn_string" id="reffn_string">string</a></sup> filename```</li>
<li>nohup sh **.sh &amp; 后台运行 job -l fg bg</li>
<li>kill -9 pid</li>
<li><ol>
<li>find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</li>
<li>whereis 加参数与文件名</li>
<li>locate 只加文件名</li>
</ol>
</li>
<li>history ,who am i,</li>
<li>df -hl 磁盘使用</li>
<li>hash：记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。</li>
<li>let 可以进行整型数的数学运算</li>
</ul>
<hr>
<h2 id="一、man-page"><a href="#一、man-page" class="headerlink" title="一、man_page"></a>一、man_page</h2><ol>
<li>内部命令：echo<br>查看内部命令帮助：help echo 或者 man echo</li>
<li>外部命令：ls<br>查看外部命令帮助：ls —help 或者 man ls 或者 info ls</li>
<li>快捷键：<br>ctrl + c：停止进程<br>ctrl + l：清屏<br>ctrl + r：搜索历史命令<br>ctrl + q：退出<br>4.善于用tab键：文件名补全</li>
</ol>
<h2 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h2><ol>
<li>进入到用户根目录<br>cd ~ 或 cd</li>
<li>查看当前所在目录<br>pwd</li>
<li>进入到itcast用户根目录<br>cd ~itcast</li>
<li>返回到原来目录<br>cd -</li>
<li>返回到上一级目录<br>cd ..</li>
<li>查看itcast用户根目录下的所有文件<br>ls -la</li>
<li>在根目录下创建一个itcast的文件夹<br>mkdir /itcast</li>
<li>查看/itcast目录下面的所有文件<br>ls -la</li>
<li>在/itcast目录下面创建一个test.txt文件,同时写入内容”this is test”<br>echo “this is test” &gt; test.txt</li>
<li>查看一下test.txt的内容<br>cat test.txt<br>more test.txt<br>less test.txt</li>
<li>向README文件追加写入”please read me first”<br>echo “please read me first” &gt;&gt; README</li>
<li>将test.txt的内容追加到README文件中<br>cat test.txt &gt;&gt; README</li>
<li>拷贝/itcast目录下的所有文件到/itcast-bak<br>cp -r /itcast /itcast-bak</li>
<li>进入到/itcast-bak目录，将test.txt移动到src目录下，并修改文件名为Student.java<br>mv test.txt src/Student.java</li>
<li>在src目录下创建一个struts.xml<blockquote>
<p>struts.xml</p>
</blockquote>
</li>
<li>删除所有的xml类型的文件<br>rm -rf *.xml</li>
<li>删除/itcast-bak目录和下面的所有文件<br>rm -rf /itcast-bak</li>
<li>返回到/itcast目录，查看一下README文件有多单词，多少个少行<br>wc -w README<br>wc -l README</li>
<li>返回到根目录，将/itcast目录先打包，再用gzip压缩<br>分步完成：tar -cvf itcast.tar itcast    gzip itcast.tar<br>一步完成：tar -zcvf itcast.tar.gz itcast</li>
<li>将其解压缩，再取消打包<br>分步完成：gzip -d itcast.tar.gz 或 gunzip itcast.tar.gz<br>一步完成：tar -zxvf itcast.tar.gz<br>将/itcast目录先打包，同时用bzip2压缩，并保存到/tmp目录下<br>tar -jcvf /tmp/itcast.tar.bz2 itcast<br>将/tmp/itcast.tar.bz2解压到/usr目录下面<br>tar -jxvf itcast.tar.bz2 -C /usr/</li>
</ol>
<p>三、文件相关命令</p>
<ol>
<li>进入到用户根目录<br>cd ~ 或者 cd<br>cd ~hadoop<br>回到原来路径<br>cd -</li>
<li>查看文件详情<br>stat a.txt</li>
<li>移动<br>mv a.txt /ect/<br>改名<br>mv b.txt a.txt<br>移动并改名<br>mv a.txt ../b.txt</li>
<li>拷贝并改名<br>cp a.txt /etc/b.txt</li>
<li>vi撤销修改<br>ctrl + u (undo)<br>恢复<br>ctrl + r (redo)</li>
<li>名令设置别名(重启后无效)<br>alias ll=”ls -l”<br>取消<br>unalias ll</li>
<li>如果想让别名重启后仍然有效需要修改<br>vi ~/.bashrc</li>
<li>添加用户<br>useradd hadoop<br>passwd hadoop</li>
<li>创建多个文件<br>touch a.txt b.txt<br>touch /home/{a.txt,b.txt}</li>
<li>将一个文件的内容复制到里另一个文件中<br>cat a.txt &gt; b.txt<br>追加内容<br>cat a.txt &gt;&gt; b.txt</li>
<li>将a.txt 与b.txt设为其拥有者和其所属同一个组者可写入，但其他以外的人则不可写入:<br>chmod ug+w,o-w a.txt b.txt<br>chmod a=wx c.txt</li>
<li>将当前目录下的所有文件与子目录皆设为任何人可读取:<br>chmod -R a+r *</li>
<li>将a.txt的用户拥有者设为users,组的拥有者设为jessie:<br>chown users:jessie a.txt</li>
<li>将当前目录下的所有文件与子目录的用户的使用者为lamport,组拥有者皆设为users<br>chown -R lamport:users *</li>
<li>将所有的java语言程式拷贝至finished子目录中:<br>cp *.java finished</li>
<li>将目前目录及其子目录下所有扩展名是java的文件列出来。<br>find -name “<em>.java”<br>查找当前目录下扩展名是java 的文件<br>find -name </em>.java</li>
<li>删除当前目录下扩展名是java的文件<br>rm -f *.java</li>
</ol>
<h2 id="四、系统命令"><a href="#四、系统命令" class="headerlink" title="四、系统命令"></a>四、系统命令</h2><ol>
<li>查看主机名<br>hostname</li>
<li>修改主机名(重启后无效)<br>hostname hadoop</li>
<li>修改主机名(重启后永久生效)<br>vi /ect/sysconfig/network</li>
<li>修改IP(重启后无效)<br>ifconfig eth0 192.168.12.22</li>
<li>修改IP(重启后永久生效)<br>vi /etc/sysconfig/network-scripts/ifcfg-eth0</li>
<li>查看系统信息<br>uname -a<br>uname -r</li>
<li>查看ID命令<br>id -u<br>id -g</li>
<li>日期<br>date<br>date +%Y-%m-%d<br>date +%T<br>date +%Y-%m-%d” “%T</li>
<li>日历<br>cal 2012</li>
<li>查看文件信息<br>file filename</li>
<li>挂载硬盘<br>mount<br>umount<br>加载windows共享<br>mount -t cifs //192.168.1.100/tools /mnt</li>
<li>查看文件大小<br>du -h<br>du -ah</li>
<li>查看分区<br>df -h</li>
<li>ssh<br>ssh hadoop@192.168.1.1</li>
<li>关机<br>shutdown -h now /init 0<br>shutdown -r now /reboot</li>
</ol>
<h2 id="五、用户和组"><a href="#五、用户和组" class="headerlink" title="五、用户和组"></a>五、用户和组</h2><ol>
<li><p>添加一个tom用户，设置它属于users组，并添加注释信息<br>分步完成：useradd tom</p>
<pre><code>   usermod -g users tom
   usermod -c &quot;hr tom&quot; tom
</code></pre><p>一步完成：useradd -g users -c “hr tom” tom</p>
</li>
<li><p>设置tom用户的密码<br>passwd tom</p>
</li>
<li>修改tom用户的登陆名为tomcat<br>usermod -l tomcat tom</li>
<li>将tomcat添加到sys和root组中<br>usermod -G sys,root tomcat</li>
<li>查看tomcat的组信息<br>groups tomcat</li>
<li>添加一个jerry用户并设置密码<br>useradd jerry<br>passwd jerry</li>
<li>添加一个交america的组<br>groupadd america</li>
<li>将jerry添加到america组中<br>usermod -g america jerry</li>
<li>将tomcat用户从root组和sys组删除<br>gpasswd -d tomcat root<br>gpasswd -d tomcat sys</li>
<li>将america组名修改为am<br>groupmod -n am america</li>
</ol>
<h2 id="六、权限"><a href="#六、权限" class="headerlink" title="六、权限"></a>六、权限</h2><p>创建a.txt和b.txt文件，将他们设为其拥有者和所在组可写入，但其他以外的人则不可写入:<br>chmod ug+w,o-w a.txt b.txt</p>
<p>创建c.txt文件所有人都可以写和执行<br>chmod a=wx c.txt 或chmod 666 c.txt</p>
<p>将/itcast目录下的所有文件与子目录皆设为任何人可读取<br>chmod -R a+r /itcast</p>
<p>将/itcast目录下的所有文件与子目录的拥有者设为root，用户拥有组为users<br>chown -R root:users /itcast</p>
<p>将当前目录下的所有文件与子目录的用户皆设为itcast，组设为users<br>chown -R itcast:users *</p>
<h2 id="七、文件夹属性"><a href="#七、文件夹属性" class="headerlink" title="七、文件夹属性"></a>七、文件夹属性</h2><ol>
<li><p>查看文件夹属性<br>ls -ld test</p>
</li>
<li><p>文件夹的rwx<br>—x:可以cd进去\<br>r-x:可以cd进去并ls\<br>-wx:可以cd进去并touch，rm自己的文件，并且可以vi其他用户的文件\<br>-wt:可以cd进去并touch，rm自己的文件\<br>ls -ld /tmp\<br>drwxrwxrwt的权限值是1777(sticky)\</p>
</li>
</ol>
<h2 id="八、vim"><a href="#八、vim" class="headerlink" title="八、vim"></a>八、vim</h2><ul>
<li>i   插入编辑操作</li>
<li>a/A</li>
<li>o/O</li>
<li>r + ?替换</li>
<li>0:文件当前行的开头</li>
<li>$:文件当前行的末尾</li>
<li>G:文件的最后一行开头</li>
<li>1 + G到第一行</li>
<li>9 + G到第九行 = :9</li>
<li>dd:删除一行</li>
<li>3dd：删除3行</li>
<li>yy:复制一行</li>
<li>3yy:复制3行</li>
<li>p:粘贴</li>
<li>u:undo</li>
<li>ctrl + r:redo</li>
<li>“a剪切板a</li>
<li>“b剪切板b</li>
<li>“ap粘贴剪切板a的内容</li>
<li>每次进入vi就有行号</li>
<li>vi ~/.vimrc</li>
<li>set nu</li>
<li>:w a.txt另存为</li>
<li>:w &gt;&gt; a.txt内容追加到a.txt</li>
<li>:e!恢复到最初状态</li>
<li>:1,$s/hadoop/root/g 将第一行到追后一行的hadoop替换为root</li>
<li>:1,$s/hadoop/root/c 将第一行到追后一行的hadoop替换为root(有提示)</li>
</ul>
<h2 id="九、查找"><a href="#九、查找" class="headerlink" title="九、查找"></a>九、查找</h2><ol>
<li>查找可执行的命令：<br>which ls</li>
<li>查找可执行的命令和帮助的位置：<br>whereis ls</li>
<li>查找文件(需要更新库:updatedb)<br>locate hadoop.txt</li>
<li>从某个文件夹开始查找<br>find / -name “hadooop<em>“<br>find / -name “hadooop</em>“ -ls</li>
<li>查找并删除<br>find / -name “hadooop<em>“ -ok rm {} \;<br>find / -name “hadooop</em>“ -exec rm {} \;</li>
<li>查找用户为hadoop的文件<br>find /usr -user hadoop -ls</li>
<li>查找用户为hadoop并且(-a)拥有组为root的文件<br>find /usr -user hadoop -a -group root -ls</li>
<li>查找用户为hadoop或者(-o)拥有组为root并且是文件夹类型的文件<br>find /usr -user hadoop -o -group root -a -type d</li>
<li>查找权限为777的文件<br>find / -perm -777 -type d -ls</li>
<li>显示命令历史<br>history</li>
<li>grep<br>grep hadoop /etc/password</li>
</ol>
<h2 id="十、打包与压缩"><a href="#十、打包与压缩" class="headerlink" title="十、打包与压缩"></a>十、打包与压缩</h2><ol>
<li>gzip压缩<br>gzip a.txt</li>
<li>解压<br>gunzip a.txt.gz<br>gzip -d a.txt.gz</li>
<li>bzip2压缩<br>bzip2 a</li>
<li>解压<br>bunzip2 a.bz2<br>bzip2 -d a.bz2</li>
<li>将当前目录的文件打包<br>tar -cvf bak.tar .<br>将/etc/password追加文件到bak.tar中(r)<br>tar -rvf bak.tar /etc/password</li>
<li>解压<br>tar -xvf bak.tar</li>
<li>打包并压缩gzip<br>tar -zcvf a.tar.gz</li>
<li>解压缩<br>tar -zxvf a.tar.gz<br>解压到/usr/下<br>tar -zxvf a.tar.gz -C /usr</li>
<li>查看压缩包内容<br>tar -ztvf a.tar.gz<br>zip/unzip</li>
<li>打包并压缩成bz2<br>tar -jcvf a.tar.bz2</li>
<li>解压bz2<br>tar -jxvf a.tar.bz2</li>
</ol>
<h2 id="十一、正则表达式"><a href="#十一、正则表达式" class="headerlink" title="十一、正则表达式"></a>十一、正则表达式</h2><ol>
<li>cut截取以:分割保留第七段<br>grep hadoop /etc/passwd | cut -d: -f7</li>
<li>排序<br>du | sort -n</li>
<li>查询不包含hadoop的<br>grep -v hadoop /etc/passwd</li>
<li>正则表达包含hadoop<br>grep ‘hadoop’ /etc/passwd</li>
<li>正则表达(点代表任意一个字符)<br>grep ‘h.*p’ /etc/passwd</li>
<li>正则表达以hadoop开头<br>grep ‘^hadoop’ /etc/passwd</li>
<li>正则表达以hadoop结尾<br>grep ‘hadoop$’ /etc/passwd</li>
</ol>
<figure class="highlight plain"><figcaption><span>: 任意一个字符```</span></figcaption><table><tr><td class="code"><pre><span class="line">```a* : 任意多个a(零个或多个a)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>: 零个或一个a```</span></figcaption><table><tr><td class="code"><pre><span class="line">```a+ : 一个或多个a</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>: 任意多个任意字符```</span></figcaption><table><tr><td class="code"><pre><span class="line">查找不是以#开头的行\</span><br><span class="line">```grep -v &apos;^#&apos; a.txt | grep -v &apos;^$&apos;</span><br></pre></td></tr></table></figure>
<p>以h或r开头的\<br><figure class="highlight plain"><figcaption><span>'^[hr]'</span><a href="/etc/passwd```">link</a></figcaption><table><tr><td class="code"><pre><span class="line">不是以h和r开头的\</span><br><span class="line">```grep &apos;^[^hr]&apos; /etc/passwd</span><br></pre></td></tr></table></figure><br>不是以h到r开头的\<br><code>grep &#39;^[^h-r]&#39; /etc/passwd</code></p>
<h2 id="十二、进程控制"><a href="#十二、进程控制" class="headerlink" title="十二、进程控制"></a>十二、进程控制</h2><ol>
<li>查看用户最近登录情况<br>last<br>lastlog</li>
<li>查看硬盘使用情况<br>df</li>
<li>查看文件大小<br>du</li>
<li>查看内存使用情况<br>free</li>
<li>查看文件系统<br>/proc</li>
<li>查看日志<br>ls /var/log/</li>
<li>查看系统报错日志<br>tail /var/log/messages</li>
<li>查看进程<br>top</li>
<li>结束进程<br>kill 1234<br>kill -9 4333</li>
</ol>
<h2 id="十三、linux的命令操作"><a href="#十三、linux的命令操作" class="headerlink" title="十三、linux的命令操作"></a>十三、linux的命令操作</h2><p>用vi文本编辑器来编辑生成文件<br><strong>**</strong>最基本用法<br>vi  somefile.4</p>
<ol>
<li>首先会进入“一般模式”，此模式只接受各种快捷键，不能编辑文件内容</li>
<li>按i键，就会从一般模式进入编辑模式，此模式下，敲入的都是文件内容</li>
<li>编辑完成之后，按Esc键退出编辑模式，回到一般模式；</li>
<li>再按：，进入“底行命令模式”，输入wq命令，回车即可</li>
</ol>
<h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat    somefile    一次性将文件内容全部输出（控制台）\<br>more  somefile    可以翻页查看, 下翻一页(空格)    上翻一页（b）  退出（q）\<br>less  somefile      可以翻页查看,下翻一页(空格)    上翻一页（b），上翻一行(↑)  下翻一行（↓）  可以搜索关键字（/keyword）</p>
<p>tail -10  install.log  查看文件尾部的10行\<br>tail -f install.log    小f跟踪文件的唯一inode号，就算文件改名后，还是跟踪原来这个inode表示的文件\<br>tail -F install.log    大F按照文件名来跟踪\<br>head -10  install.log  查看文件头部的10行</p>
<p>文件内容查阅\<br>head -10 a.log 取前10行\<br>tail -10 a.log 取后10行\<br>tail -f a.log 实时检测日志更新\<br>tail -f30 a.log 实时监测该日志的后30行\<br>tab：代码补全，文件名补全\<br>文件类型权限 drwxrwx user，group / 4,2,1打分\<br>查看日志var/log\</p>
<h3 id="3、文件权限的操作"><a href="#3、文件权限的操作" class="headerlink" title="3、文件权限的操作"></a>3、文件权限的操作</h3><p>drwxr-xr-x      （也可以用二进制表示  111 101 101  —&gt;  755）<br>d：标识节点类型（d：文件夹  -：文件  l:链接）\<br>r：可读  w：可写    x：可执行 \<br>第一组rwx：  表示这个文件的拥有者对它的权限：可读可写可执行\<br>第二组r-x：  表示这个文件的所属组对它的权限：可读，不可写，可执行\<br>第三组r-x：  表示这个文件的其他用户（相对于上面两类用户）对它的权限：可读，不可写，可执行</p>
<p>chmod g-rw haha.dat    表示将haha.dat对所属组的rw权限取消\<br>chmod o-rw haha.dat    表示将haha.dat对其他人的rw权限取消\<br>chmod u+x haha.dat      表示将haha.dat对所属用户的权限增加x</p>
<p>也可以用数字的方式来修改权限\<br>chmod 664 haha.dat  \<br>就会修改成  rw-rw-r—</p>
<p>如果要将一个文件夹的所有内容权限统一修改，则可以-R参数\<br>chmod -R 770 aaa/\<br>chown angela:angela aaa/    &lt;只有root能执行&gt;</p>
<p>4、基本的用户管理<br>useradd  angela<br>要修改密码才能登陆<br>passwd angela  按提示输入密码即可</p>
<p>**为用户配置sudo权限<br>用root编辑 vi /etc/sudoers<br>在文件的如下位置，为hadoop添加一行即可<br>root    ALL=(ALL)      ALL    \<br>hadoop  ALL=(ALL)      ALL</p>
<p>然后，hadoop用户就可以用sudo来执行系统级别的指令<br>[hadoop@shizhan ~]$ sudo useradd huangxiaoming</p>
<p>5、系统管理操作</p>
<ul>
<li>查看主机名<br>hostname</li>
<li>修改主机名(重启后无效)<br>hostname hadoop</li>
<li>修改主机名(重启后永久生效)<br>vi /ect/sysconfig/network</li>
<li><p>修改IP(重启后无效)<br>ifconfig eth0 192.168.12.22</p>
</li>
<li><p>修改IP(重启后永久生效)<br>vi /etc/sysconfig/network-scripts/ifcfg-eth0</p>
</li>
</ul>
<p>mkdir  /mnt/cdrom      创建一个目录，用来挂载\<br>mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom/    将设备/dev/cdrom挂载到 挂载点 ：  /mnt/cdrom中</p>
<ul>
<li><p>umount<br>umount /mnt/cdrom</p>
</li>
<li><p>统计文件或文件夹的大小<br>du -sh  /mnt/cdrom/Packages\<br>df -h    查看磁盘的空间</p>
</li>
<li>关机<br>halt</li>
<li>重启<br>reboot</li>
</ul>
<p><strong>**</strong>配置主机之间的免密ssh登陆\<br>假如 A  要登陆  B\<br>在A上操作：\<br>%%首先生成密钥对\<br>ssh-keygen  (提示时，直接回车即可)\<br>%%再将A自己的公钥拷贝并追加到B的授权列表文件authorized_keys中\<br>ssh-copy-id  B</p>
<p><strong>**</strong>后台服务管理<br>service network status  查看指定服务的状态\<br>service network stop    停止指定服务\<br>service network start    启动指定服务\<br>service network restart  重启指定服务\<br>service —status-all  查看系统中所有的后台服务</p>
<p>设置后台服务的自启配置\<br>chkconfig  查看所有服务器自启配置\<br>chkconfig iptables off  关掉指定服务的自动启动\<br>chkconfig iptables on  开启指定服务的自动启动</p>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>各种算法优缺点</title>
    <url>/2019/10/25/%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="各种机器学习算法优缺点总结"><a href="#各种机器学习算法优缺点总结" class="headerlink" title="各种机器学习算法优缺点总结"></a>各种机器学习算法优缺点总结</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><blockquote>
<blockquote>
<p>可回归，可分类</p>
</blockquote>
</blockquote>
<h3 id="决策树优点"><a href="#决策树优点" class="headerlink" title="决策树优点"></a>决策树优点</h3><ol>
<li>决策树易于理解和解释，可以可视化分析，容易提取出规则。</li>
<li>可以同时处理标称型和数值型数据。</li>
<li>测试数据集时，运行速度比较快。</li>
<li>决策树可以很好的扩展到大型数据库中，同时它的大小独立于数据库大小。</li>
</ol>
<h3 id="决策树缺点"><a href="#决策树缺点" class="headerlink" title="决策树缺点"></a>决策树缺点</h3><ol>
<li>对缺失数据处理比较困难。</li>
<li>容易出现过拟合问题。</li>
<li>忽略数据集中属性的相互关联。</li>
<li>ID3算法计算信息增益时结果偏向数值比较多的特征。</li>
</ol>
<h3 id="改进措施"><a href="#改进措施" class="headerlink" title="改进措施"></a>改进措施</h3><p>剪枝，采用交叉验证法，加入正则化；bagging算法，randomforest算法，可以解决过拟合的问题。<br><a id="more"></a></p>
<h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p>C4.5算法核心思想是ID3算法的改进，改进方面有：</p>
<ol>
<li>用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；</li>
<li>在树构造过程中进行剪枝；</li>
<li>能处理非离散的数据；</li>
<li>能处理不完整的数据。<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4>产生的分类规则易于理解，准确率较高。<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li>
<li>在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效；</li>
<li>C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。</li>
</ol>
<h3 id="CART分类与回归树"><a href="#CART分类与回归树" class="headerlink" title="CART分类与回归树"></a>CART分类与回归树</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>非常灵活，可以允许有部分错分成本，还可指定先验概率分布，可使用自动的成本复杂性剪枝来得到归纳性更强的树。</li>
<li>在面对诸如存在缺失值、变量数多等问题时CART 显得非常稳健。<h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3></li>
</ol>
<ul>
<li>优点：不易过拟合，并行化更快；降方差；鲁棒性更强；适用大规模数据和不相关特征</li>
<li>准确度可能不够；噪声较大的问题上会过拟合；内部级别较多的特征对模型影响更大，此时权值不可信；</li>
</ul>
<h2 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K-Means聚类"></a>K-Means聚类</h2><ul>
<li>优点：复杂度O(N*K*T)，N样本数，K类别数，T迭代数</li>
<li>缺点：对噪声孤立点敏感；K的定义trick。</li>
</ul>
<h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><ul>
<li>优点：含隐变量弥补极大似然缺陷；</li>
<li>缺点：迭代收敛慢，依赖初始化参数假设</li>
</ul>
<h2 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h2><ul>
<li>优点：计算小，存储低；</li>
<li>缺点：欠拟合，精度不高；</li>
</ul>
<h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2><blockquote>
<blockquote>
<p>使用先验知识，得到后验概率，条件独立性假设前提下，期望风险最小化得到后验概率最大化。</p>
<ul>
<li>优点：小规模数据效果好，可以多分类；支持增量式运算。即可以实时的对新增的样本进行训练；可解释性强；</li>
<li>缺点：条件独立性假设，性能不一定高；</li>
</ul>
</blockquote>
</blockquote>
<h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><ul>
<li>优点：小样本下，可实现非线性分类，用于分类与回归，泛化能力强；无局部极小值问题，可以很好的处理高维数据集。</li>
<li>缺点：对核函数和参数敏感；对于核函数的高维映射解释力不强，尤其是径向基函数；对缺失数据敏感。</li>
</ul>
<h2 id="集成算法（AdaBoost算法）"><a href="#集成算法（AdaBoost算法）" class="headerlink" title="集成算法（AdaBoost算法）"></a>集成算法（AdaBoost算法）</h2><h3 id="AdaBoost算法优点"><a href="#AdaBoost算法优点" class="headerlink" title="AdaBoost算法优点"></a>AdaBoost算法优点</h3><ol>
<li>很好的利用了弱分类器进行级联。</li>
<li>可以将不同的分类算法作为弱分类器。</li>
<li>AdaBoost具有很高的精度。</li>
<li>相对于bagging算法和Random Forest算法，AdaBoost充分考虑的每个分类器的权重。</li>
</ol>
<h3 id="Adaboost算法缺点"><a href="#Adaboost算法缺点" class="headerlink" title="Adaboost算法缺点"></a>Adaboost算法缺点</h3><ol>
<li>AdaBoost迭代次数也就是弱分类器数目不太好设定，可以使用交叉验证来进行确定。</li>
<li>数据不平衡导致分类精度下降。</li>
<li>训练比较耗时，每次重新选择当前分类器最好切分点。</li>
</ol>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><ul>
<li>优点：非线性拟合能力强；鲁棒性强；并行性好；</li>
<li>缺点：可解释性差，初值敏感；</li>
</ul>
<h2 id="隐马尔可夫HMM"><a href="#隐马尔可夫HMM" class="headerlink" title="隐马尔可夫HMM"></a>隐马尔可夫HMM</h2><ul>
<li>优点：解决标注问题；</li>
<li>缺点：齐次马尔科夫假设与观测孤立性假设，可能出现标记偏置。</li>
</ul>
<h2 id="CRF条件随机场"><a href="#CRF条件随机场" class="headerlink" title="CRF条件随机场"></a>CRF条件随机场</h2><ul>
<li>优点：全局范围最优解；解决MEMM标注偏置；没有条件独立性假设；计算整个标记序列的联合概率分布；</li>
<li>缺点：训练代价大，复杂度高。</li>
</ul>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统</title>
    <url>/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><p>目标主要包括：用户满意性，多样性，新颖性，惊喜度，实时性，推荐透明度，覆盖率。<br>热门、人工、相关、个性化推荐</p>
<h2 id="推荐系统简介"><a href="#推荐系统简介" class="headerlink" title="推荐系统简介"></a>推荐系统简介</h2><p>$U$表示所有用户(user)的集合,用$I$表示所有项目(item)的集合。在实际系统中，$U$和$I$具有非常大的规模。定义一个效用函数$s$，用来计算项目$i$对用户$u$的推荐度,即$s$:</p>
<script type="math/tex; mode=display">U×I→R</script><p>，其中$R$是一个全序集合(在一定范围内非负的整数或实数)，推荐算法的研究问题就是通过计算推荐度为每一个用户$u \in U$找到其最感兴趣的项目$i’ \in I$,如下:</p>
<script type="math/tex; mode=display">\forall u \in U,i'_u =\argmax _{i \in I} s(u，i)</script><p>推荐系统中的用户和项目都可以通过一组不同的属性或特征来进行表示。关键问题是效用函数$s$通常定义在$U×I$的一个子空间上，推荐算法必须将$s$外推到整个$U×I$空间。【也就是模型的训练与预测过程，外推的效果对应着泛化能力】</p>
<h2 id="传统推荐方法"><a href="#传统推荐方法" class="headerlink" title="传统推荐方法"></a>传统推荐方法</h2><ul>
<li>基于内容的推荐</li>
<li>协同过滤推荐</li>
<li>混合推荐</li>
</ul>
<h3 id="协同过滤的两种主要方式"><a href="#协同过滤的两种主要方式" class="headerlink" title="协同过滤的两种主要方式"></a>协同过滤的两种主要方式</h3><ul>
<li>近邻模型<ol>
<li>面向用户：计算用户之间的关联；</li>
<li>面向物品的方法：计算待推荐物品与该用户已评级过的物品之间的关联。</li>
<li>用余弦值表示上述用户关联，该值就是皮尔逊相关系数。</li>
</ol>
</li>
<li>隐变量模型<ol>
<li>隐变量描述用户对物品的评级。物品（类型，流派）；用户（评分，评级等）</li>
<li>神经网络，矩阵分解实现隐变量表示。</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h3 id="embedding在推荐中的应用"><a href="#embedding在推荐中的应用" class="headerlink" title="embedding在推荐中的应用"></a>embedding在推荐中的应用</h3><p><a href="https://lumingdong.cn/application-practice-of-embedding-in-recommendation-system.html" target="_blank" rel="noopener">embedding在推荐系统的应用</a></p>
<blockquote>
<blockquote>
<p>基于内容的推荐：理解内容（挖掘内容属性）去挖掘用户兴趣点构建推荐模型。对用户行为去挖掘内容。以物品的共现性，作为自然语言的上下文关系，构建神经网络学习物品在隐空间的向量表示。</p>
</blockquote>
</blockquote>
<p>Embedding通过给定关联（时序上下文，共现集合）信息，使用极大似然估计方式计算这些关系发生概率最大时的参数，再借助参数赋予个体抽象的隐含属性，对隐含属性编码赋值，最后用编码表征或者代替个体。通过隐含属性编码方式。</p>
<h4 id="embedding质量评估"><a href="#embedding质量评估" class="headerlink" title="embedding质量评估"></a>embedding质量评估</h4><p>单词的评估一般比较相似度距离；推荐系统中没有一定完美的方案，以具体任务的实际收益作为评价标准。</p>
<h5 id="word-embedding"><a href="#word-embedding" class="headerlink" title="word embedding"></a>word embedding</h5><ul>
<li>相似度</li>
<li>king-queue=man-woman</li>
<li>类别分类</li>
<li>聚类</li>
</ul>
<h5 id="item-embedding"><a href="#item-embedding" class="headerlink" title="item embedding"></a>item embedding</h5><ul>
<li>TOP N的相似度</li>
<li>随机抽取，人工判别</li>
<li>聚类</li>
<li>上线AB</li>
</ul>
<h2 id="CTR预估算法比较"><a href="#CTR预估算法比较" class="headerlink" title="CTR预估算法比较"></a>CTR预估算法比较</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>介绍</th>
<th>不足</th>
</tr>
</thead>
<tbody>
<tr>
<td>LR</td>
<td>$\sigma(x)$将函数值映射到0~1；大数据下易并行化</td>
<td>线性模型学习有限 ，人工特征与特征较差补充非线性，耗费人力</td>
<td></td>
</tr>
<tr>
<td>Kernel函数法</td>
<td>低维映射到高维</td>
<td>复杂度太高不易实现</td>
</tr>
<tr>
<td>树模型</td>
<td>GBDT+LR解决特征组合</td>
<td>对历史行为，旧规则的记忆，新规则缺乏推广性</td>
</tr>
<tr>
<td>FM模型</td>
<td>自动学习高阶属性，解放人工挖掘特征</td>
<td>只能拟合特定的非线性，二阶</td>
</tr>
<tr>
<td>DNN</td>
<td>NN拟合非线性，能力足够强</td>
<td>适合业务数据，具备推广性的网络结构，端到端规模化</td>
</tr>
</tbody>
</table>
</div>
<h2 id="推荐系统比较"><a href="#推荐系统比较" class="headerlink" title="推荐系统比较"></a>推荐系统比较</h2><ul>
<li>LR：大规模离散特征</li>
<li>LR + GBDT：GBDT叶子节点编码离散化连续值特征，同时实现特征交叉</li>
<li>FM：特征交叉权重矩阵分解，交叉结果属于向量维度的交叉</li>
<li>FFM：隐向量分filed，不同field 特征交叉时使用对应field的向量</li>
<li>FNN：FM + concat + MLP 预训练FM，Embedding向量高阶交叉</li>
<li>PNN：FM + vector product + MLP 层之后，加product 层做交叉（f个Embedding向量两两内积）</li>
<li>NFM：FM + bi-interact + MLP bi-interation即Embedding向量element-wise product得到f(f-1)/2个向量 ，sum</li>
<li>AFM：FM + bi-interact + attention + MLP</li>
<li>Wide&amp;Deep： LR + Embeding + MLP， 低阶交叉保留记忆能力，deep 高阶交叉提升泛化能力（element-wise 高阶交叉）</li>
<li>DeepFM： LR + FM +Embeding + deep，fm交叉vector-wise二阶特征交叉， Dnn高阶element-wise 特征交叉</li>
<li>Deep&amp;Cross： cross + deep，element-wise多项式交叉，element-wise 高阶特征交叉</li>
</ul>
<p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/com.jpg" alt="avatar"></p>
<h2 id="推荐系统的评估"><a href="#推荐系统的评估" class="headerlink" title="推荐系统的评估"></a>推荐系统的评估</h2><p>A/B测试：流量分发（随机，uid%100∈[0,20%]）</p>
<h3 id="95-置信区间是什么意思"><a href="#95-置信区间是什么意思" class="headerlink" title="95%置信区间是什么意思"></a>95%置信区间是什么意思</h3><p><strong>置信区间是指试验用户的优化指标vs所有用户下指标均值的区间估计</strong>展现的是指标的真实值与试验用户指标的相似度。95%是置信度，置信度越高，置信区间就越大。<br>分位数1.96处对应的阴影部分的面积(概率)为0.025，中间概率就为0.95.</p>
<script type="math/tex; mode=display">P(\mu - 1.96 \frac{\sigma}{\sqrt{n}} < M < \mu + 1.96 \frac{\sigma}{\sqrt{n}} ) = 0.95</script><p>10%流量实验每一小时计算一次实验结果的置信区间，最后所有置信区间中有95%的置信区间包含了总体均值，则说明实验结果置信。</p>
<p><strong>小流量的用户行为统计在流量放宽后关键指标数据可能会发生变化。故由小到大逐步增加流量分配，同时实时监控关键指标的数据走势</strong></p>
<p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/zhixindu.gif" alt="avatar"></p>
<h3 id="冷启动过程"><a href="#冷启动过程" class="headerlink" title="冷启动过程"></a>冷启动过程</h3><h4 id="用户冷启动"><a href="#用户冷启动" class="headerlink" title="用户冷启动"></a>用户冷启动</h4><ol>
<li>手机用户特征；</li>
<li>粗粒度选项引导填写；</li>
<li>热点，保量<h4 id="物品冷启动"><a href="#物品冷启动" class="headerlink" title="物品冷启动"></a>物品冷启动</h4></li>
<li>保量</li>
</ol>
<h3 id="多目标排序"><a href="#多目标排序" class="headerlink" title="多目标排序"></a>多目标排序</h3><script type="math/tex; mode=display">score=CTR*(\alpha+CVR) * (\beta+price) * staya * rule \_weight *</script><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ol>
<li>目标重要性难以量化；</li>
<li>超参难以学习；</li>
<li>在线服务计算量大；</li>
</ol>
<h2 id="推荐系统架构"><a href="#推荐系统架构" class="headerlink" title="推荐系统架构"></a>推荐系统架构</h2><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/rec_sys.png" alt="avatar"></p>
<h3 id="online部分架构"><a href="#online部分架构" class="headerlink" title="online部分架构"></a>online部分架构</h3><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/rec_sys_online.png" alt="avatar"></p>
<h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>推荐引擎，推荐系统核心，包括online逻辑，召回、过滤、特征计算、排序、 多样化等处理过程。</p>
<h4 id="数据路径"><a href="#数据路径" class="headerlink" title="数据路径"></a>数据路径</h4><ol>
<li><p>请求的刷新从gateway，经过流量分配模块，传到业务gateway，业务gateway支持http，tcp（使用thirtf协议或者protobuf 协议）等多种类型接口；</p>
</li>
<li><p>用户行为数据，从gateway到Flume agent，然后到kafka，为后面online，realtime userprofile部分的提供实时数据，也为offline部分的数据存储系统提供数据。</p>
</li>
</ol>
<h3 id="offline部分架构"><a href="#offline部分架构" class="headerlink" title="offline部分架构"></a>offline部分架构</h3><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/rec_sys_offline.png" alt="avatar"><br>从框架的角度看，推荐系统基本可以分为数据层、召回层、排序层。</p>
<ul>
<li>sessionlog：对原始数据进行清洗合并，sessionlog一般就是清洗合并后的数据，后续的算法和统计都是根据sessionlog进行再加工。</li>
<li>userprofile：对用户属性和行为等信息进行采集和统计，为后续算法提供特征支持。</li>
<li>itemDoc：对视频、商品等属性、曝光、点击等字段进行统计， 为后续算法提供特征支持。<br>召回层主要是从用户的历史行为、实时行为等角度利用各种触发策略产生推荐的候选集，对不同的策略和算法产生的候选集进行融合并按照产品规则进行过滤，一般融合和过滤后的候选集还是比较多的，一次线上请求过来之后线上系统无法对那么多的候选集进行排序，所以在召回层一般还会有粗排序，对融合的候选集进行一次粗排序，过滤掉粗排分数较低的候选集。</li>
</ul>
<h2 id="YouTubeDNN"><a href="#YouTubeDNN" class="headerlink" title="YouTubeDNN"></a>YouTubeDNN</h2><ul>
<li>1.召回TopN：生成倒排，近似搜索；</li>
<li>2.新视频：用该视频最近生成日志的时间example age；初始化训练时为0；就是说越短越可能为正样本（训练的trick）</li>
<li>3.测试集作为最近一次观看行为</li>
<li>4.优化目标非CTR，播放率而是曝光后预期播放时间</li>
<li>5.目标函数的设定应该是一个算法模型的根本性问题</li>
<li>6.对某些特征开方x，x，x^2处理后输入在线上serving中使用$e^{Wx+b}$做预测可以直接得到expected watch time的近似。</li>
<li>7.Weighted LR的特点是，正样本权重w的加入会让正样本发生的几率变成原来的w倍，也就是说样本i的Odds变成了下面的式子：<br><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/equation1.svg" alt="avatar"><br>由于在视频推荐场景中，用户打开一个视频的概率p往往是一个很小的值，因此上式可以继续简化：<img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/equation2.svg" alt="avatar"><br>因此，Model Serving过程中[公式] 计算的正是观看时长的期望。</li>
</ul>
<h3 id="候选集生成"><a href="#候选集生成" class="headerlink" title="候选集生成"></a>候选集生成</h3><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/houxuan.jpg" alt="avatar"></p>
<h3 id="精排"><a href="#精排" class="headerlink" title="精排"></a>精排</h3><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/youtube.jpg" alt="avatar"></p>
<h2 id="MMR-PostRank控制多样性"><a href="#MMR-PostRank控制多样性" class="headerlink" title="MMR(PostRank控制多样性)"></a>MMR(PostRank控制多样性)</h2><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/mmr.png" alt="avatar"><br>lambad 越大，准确性越大；<br>lambda 越小，多样性越好。</p>
<h2 id="Wide-amp-Depp与DeepFM"><a href="#Wide-amp-Depp与DeepFM" class="headerlink" title="Wide&amp;Depp与DeepFM"></a>Wide&amp;Depp与DeepFM</h2><h3 id="wide——LR、FM"><a href="#wide——LR、FM" class="headerlink" title="wide——LR、FM"></a>wide——LR、FM</h3><p>wide部分主要使用LR或者FM；<br>特征方面：one-hot稀疏特征，基础特征，交叉特征；通过加入宽泛类特征实现一定泛化能力，受限训练数据，wide模型无法实现未曾出现的泛化</p>
<h3 id="deep——DNN"><a href="#deep——DNN" class="headerlink" title="deep——DNN"></a>deep——DNN</h3><p>前馈神经网络，特征首先转换为低维稠密向量，<strong>维度O(10)~O(100)</strong>，向量随机初始化，经过最小化损失函数训练，中间激活用relu。<br>DNN学习低维稠密特征实现模型泛化能力，包括未出现内容，有泛化推荐的能力<br>手机型号，年龄等这类实体特征，几百类或几十类，最后映射为低维稠密特征</p>
<h3 id="Wide-amp-Deep"><a href="#Wide-amp-Deep" class="headerlink" title="Wide&amp;Deep"></a>Wide&amp;Deep</h3><ul>
<li>Wide模型利用交叉特征高效的实现记忆能力，实现精准推荐</li>
<li>Embedding类的模型通过学习到的低维稠密向量，实现模型的泛化推荐（未见过的内容）</li>
</ul>
<p>平衡Wide模型和Deep模型的Memorization 与 Generalization(记忆与泛化)</p>
<script type="math/tex; mode=display">P\left ( Y=1\mid \mathbf{x} \right )=\sigma \left ( \mathbf{w}_{wide}^T\left [ \mathbf{x},\phi \left ( \mathbf{x} \right ) \right ] + \mathbf{w}_{deep}^Ta^{\left ( l_f \right )}+b \right )</script><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/w&amp;d.png" alt="avatar"></p>
<h3 id="DeepFM"><a href="#DeepFM" class="headerlink" title="DeepFM"></a>DeepFM</h3><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/fm.jpg" alt="avatar"><br>黑色线表示带有权重的连接，红色线表示权重为1的连接，蓝色线表示one-hot映射到对应的embedding。<br>Field表示一个特征类别,每个field用one-hot表示，构成最下面的Sparse -Features。</p>
<ul>
<li>稀疏特征有两部分输出，一部分是加权求和得到FM Layer中的第一个节点，另一部分索引对应的embedding得到Dense Embeddings。</li>
<li>FM：LR的权重为一阶权重，组合特征权重为高阶权重。</li>
<li>Dense Embeddings：有两部分输出，一部分是两两做点积输出到FM Layer，另外一部分是拼接起来作为Hidden Layer的输入</li>
</ul>
<h4 id="wide-amp-deep和deepFM区别"><a href="#wide-amp-deep和deepFM区别" class="headerlink" title="wide&amp;deep和deepFM区别"></a>wide&amp;deep和deepFM区别</h4><ul>
<li>wide模型部分由LR替换为FM,FM模型学习交叉特征的能力</li>
<li>共享原始输入特征。DeepFM模型的原始特征将作为FM和Deep模型部分的共同输入，保证模型特征的准确与一致。</li>
<li>DeepFM模型包含FM和DNN两部分，FM模型可以抽取低阶特征，DNN可以抽取高阶特征。</li>
<li>由于输入仅为原始特征，而且FM和DNN共享输入向量特征，DeepFM模型训练速度很快。</li>
</ul>
<h2 id="热点feed流postrank"><a href="#热点feed流postrank" class="headerlink" title="热点feed流postrank"></a>热点feed流postrank</h2><h3 id="精排得到40个，为什么还要对12个重排序？"><a href="#精排得到40个，为什么还要对12个重排序？" class="headerlink" title="精排得到40个，为什么还要对12个重排序？"></a>精排得到40个，为什么还要对12个重排序？</h3><ol>
<li>ctr预估，集中在预估单个item的ctr，和真实场景有一定的gap；</li>
<li>广告位设置，多样性实验</li>
<li>在真实的list顺序下，item被选中的概率与预测兴趣有差别</li>
<li>多个item作为序列联合排序，整体提升排在前面被点击的概率，用户更多的关注前几个。</li>
</ol>
<h2 id="序列评估与生成框架"><a href="#序列评估与生成框架" class="headerlink" title="序列评估与生成框架"></a>序列评估与生成框架</h2><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>总收益函数：<img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/e1.png" alt="avatar"></p>
<p>模型$f_θ$拟合：<img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/e2.png" alt="avatar"></p>
<p>优化函数1：<img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/e3.png" alt="avatar"></p>
<p>最终优化函数2：<img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/e4.png" alt="avatar"></p>
<ul>
<li>两层Transformer，4个head；最后得到某个位置item的概率。最后计算总体收益。</li>
<li>focal loss：更多关注错分的样本；a调节权重；</li>
</ul>
<h3 id="Transformer-DNN"><a href="#Transformer-DNN" class="headerlink" title="Transformer+DNN"></a>Transformer+DNN</h3><p>1、偏差较大：精排得分，确定下限；<br>2、测试机较差时怀疑过拟合，dropout后测试集效果好于训练评估；<br>3、测试集不够具有全天代表性，扩充；<br>4、最终保证测试与训练相差不大。</p>
<h3 id="Focal-Loss-发掘困难样本"><a href="#Focal-Loss-发掘困难样本" class="headerlink" title="Focal Loss 发掘困难样本"></a>Focal Loss 发掘困难样本</h3><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/focal.png" alt="avatar"></p>
<p>例如$\gamma$为2</p>
<ul>
<li>对于正类样本而言，预测结果为0.95肯定是简单样本，所以（1-0.95）的gamma次方就会很小，这时损失函数值就变得更小。而预测概率为0.3的样本其损失相对很大;</li>
<li>对于负类样本而言同样，预测0.1的结果应当远比预测0.7的样本损失值要小得多。对于预测概率为0.5时，损失只减少了0.25倍，所以更加关注于这种难以区分的样本。</li>
</ul>
<p>这样减少了简单样本的影响，大量预测概率很小的正样本叠加起来后的效应才可能比较有效。此外，加入平衡因子alpha，用来平衡正负样本本身的比例不均：文中alpha取0.25，即正样本要比负样本占比小，这是因为负例易分。</p>
<h3 id="pointwise，pairwise，listwise"><a href="#pointwise，pairwise，listwise" class="headerlink" title="pointwise，pairwise，listwise"></a>pointwise，pairwise，listwise</h3><p>更多参考<br><a href="https://zhuanlan.zhihu.com/p/114459818" target="_blank" rel="noopener">排序学习</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Pointwise、Pairwise和Listwise的本质区别是训练过程中优化的目标或者损失函数不同。Pointwise优化的目标是单条样本与用户（查询词）之间的相关性（或者是否会点），即回归的目标是label。比如对于广告排序场景，优化目标是样本是否点击这个事情，这就是Pointwise。但对于如RankNet的Pairwise方法，优化的目标是正例与负例之间的序。而对于Listwise，优化的是一个序的好坏，比如用NDCG来评价。</p>
<h4 id="pointwise"><a href="#pointwise" class="headerlink" title="pointwise"></a>pointwise</h4><blockquote>
<blockquote>
<p>将排序问题当作二分类</p>
</blockquote>
</blockquote>
<p>训练样本</p>
<script type="math/tex; mode=display">pointwise=(q_i,c_{i,j},y_{i,j})</script><p>$q_i$为第i个query，$c_{i,j}$为第i个query中第j个候选集，$y_{i,j}$为对该候选样本真实的概率<br>预测阶段二分类模型$h_\theta$排序每个候选句子，得到$\hat{y_{i,j}}$，选取top-ranked句自作为正确答案。目标函数为：</p>
<script type="math/tex; mode=display">argmax_{c_{i,j}} h_{\theta}(q_i,c_{i,j})</script><h4 id="pairwise"><a href="#pairwise" class="headerlink" title="pairwise"></a>pairwise</h4><blockquote>
<blockquote>
<p>让正确答案比错误答案得分高</p>
</blockquote>
</blockquote>
<p>训练样本</p>
<script type="math/tex; mode=display">pairwise=(q_i,c^+_i,c^-_i)</script><p>给一个提问$q_i$，pairwise给定一对候选回答学习并预测最佳回答。$c^+$为正确回答，损失函数为合页函数</p>
<script type="math/tex; mode=display">L=max\{0,m-(h_\theta(q_i,c^+_i)-h_\theta(q_i,c^-_i))\}</script><ul>
<li>对（正样本预测值-负样本预测值）&gt; m时则判断正确，损失为0；</li>
<li>对（正样本预测值-负样本预测值）&lt; m时则判断错误，有损失。</li>
</ul>
<h5 id="合页损失函数"><a href="#合页损失函数" class="headerlink" title="合页损失函数"></a>合页损失函数</h5><p>促使正确答案的得分比错误答案的得分大于$m$。最后和pairwise类似，在预测阶段得分最高的候选答案被当作正确的答案。</p>
<h4 id="listwise"><a href="#listwise" class="headerlink" title="listwise"></a>listwise</h4><p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/listwise.jpg" alt></p>
<p>g设想成最优评分函数,对查询Q1来说：文档A得6分,文档B得4分,文档C得3分<br>找到一个函数,使得其对Q1的搜索结果打分顺序尽可能的接近标准函数g.其中函数f和h就是实际的评分函数,通过比较两个概率之间的KL距离,发现f比h更接近假想的最优函数g.故选择函数f为搜索的评分函数.</p>
<blockquote>
<blockquote>
<p>q拟合p的分布</p>
<script type="math/tex; mode=display">D_{KL}(p||q)=\sum_{x}p(x)\log \frac{p(x)}{q(x)}=-\sum_x p(x)\log q(x)-(-\sum_x p(x)\log p(x))</script></blockquote>
</blockquote>
<h2 id="NavBoost"><a href="#NavBoost" class="headerlink" title="NavBoost"></a>NavBoost</h2><ol>
<li>取30天的数据ctx_id和rec_id之间的展点数据，impression必须大某个阈值（1W）</li>
<li>计算ctx_id和rec_id之间的coec值</li>
<li>计算最大的ctr，归一化所有的ctr；计算新鲜度值$=1.5 - \frac{1}{1 + \exp(-\frac{age}{100})}$</li>
<li>计算最终得分，ctrScore <em> 0.8 + ageScore </em> 0.2</li>
</ol>
<p><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/28.png" alt="avatar"></p>
<h3 id="COEC"><a href="#COEC" class="headerlink" title="COEC"></a>COEC</h3><p>解决item在页面上位置的不同造成CTR的差异性</p>
<hr>
<p>用户注意力一般集中在左上，因此每次 impression 能导致的 click 是与位置相关的。变现有效 impression 的方式是通过每个位置的平均 CTR（reference CTR）来处理，这样将每次 impression 乘以对应位置的 reference CTR 就获得了所谓的 EC（expected click），这样消除了 position bias 的 EC 就变成可加的了。观测到的 click 数目从统计上来看应该是分布在 EC 附近，也就是说 COEC（clicks over expected clicks）的期望应该是 1。</p>
<p>使用 COEC 而不是 CTR 作为每个 item 的 relevance 的反应是一个不错的选择，但是实际操作中与 CTR 类似都面临着 data sparsity 的问题。一般我们也会使用 Laplace smoothing 解决 0 观测。</p>
<h4 id="拉普拉斯平滑"><a href="#拉普拉斯平滑" class="headerlink" title="拉普拉斯平滑"></a>拉普拉斯平滑</h4><p>分子+1；分母+可取值范围大小<br><img src="/2019/10/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/36.png" alt="avatar"></p>
]]></content>
      <categories>
        <category>rec</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2019/10/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul>
<li>进程：一个程序在一个数据集合上的一次运行过程。</li>
<li>线程：线程是进程的一个实体，是被系统独立调度和执行的基本单位。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>进程是程序的一次执行，线程理解为进程中执行的一个程序片段；<br>进程间是独立的，表现在内存空间、上下文环境上；线程运行在进程空间内；<br>进程间无法存取存储空间；线程在进程空间中，同一进程所产生的线程共享同一内存空间。<br>线程属于进程，进程退出时进程产生的线程都会被强制退出并清除；<br>进程间可以IPC通信，线程不可以</p>
<a id="more"></a>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>信号，信号量，消息队列，共享内存</p>
<p>本地之间：文件映射、共享内存、匿名管道、剪切板<br>跨服务器：命名管道、socket、邮件槽</p>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>全局变量、自定义消息响应</p>
<h2 id="多线程并行和并发的区别"><a href="#多线程并行和并发的区别" class="headerlink" title="多线程并行和并发的区别"></a>多线程并行和并发的区别</h2><p>并行：多个处理器或者多核处理器同时执行多个不同的任务。<br>并发：一个处理器处理多个任务。</p>
<h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>在互斥的基础上，通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源</p>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>数学基础</title>
    <url>/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="导数、偏导数与方向导数"><a href="#导数、偏导数与方向导数" class="headerlink" title="导数、偏导数与方向导数"></a>导数、偏导数与方向导数</h2><p><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/37.png" alt="avatar"></p>
<p>首先明确，导数是一个值，代表切线的斜率，而梯度是一个向量。<strong>最大方向导数的方向就是梯度代表的方向。</strong><br>梯度是$f(x)$对各个自变量$ x = [x_1, x_2, …, x_m]^\top$每一维分别求偏导数得到的向量。<br>从式（5）和（6）中我们也可以知道，当$d = \frac{\nabla f(x)}{|\nabla f(x)|}$方向导数最大。 <strong>最大方向导数的方向就是梯度的方向，最大的方向导数就是梯度的欧几里德范数。</strong></p>
<a id="more"></a>
<h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><h3 id="极大似然与概率"><a href="#极大似然与概率" class="headerlink" title="极大似然与概率"></a>极大似然与概率</h3><ul>
<li>1&gt; 多个时间概率相乘得到似然表达式，值的大小意味着这组样本值都发生的可能性的大小；</li>
<li>2&gt; 对似然表达式求导，必要时进行预处理，比如取对数（逻辑回归需要），令其导数为0，得到似然方程。</li>
<li>3&gt; 求解似然方程，得到的参数解即为极大似然估计的解。<blockquote>
<blockquote>
<p>何为极大似然：“模型已定，参数未知”。通过若干次试验，观察其结果，反推得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。<strong>利用已知的样本结果，反推取得所有样本最大概率的参数值。</strong></p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h3><p><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/bern.png" alt="avatar"><br><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/er.png" alt="avatar"><br><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/gauss.png" alt="avatar"><br><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/junyun.png" alt="avatar"></p>
<h3 id="条件概率与链式法则"><a href="#条件概率与链式法则" class="headerlink" title="条件概率与链式法则"></a>条件概率与链式法则</h3><ol>
<li>协方差矩阵<script type="math/tex; mode=display">cov(X,Y)= E\{(X_i-E(X))(Y_i-E(Y)\},i=1,2,……n;j=i,2,……n</script></li>
<li>全概率公式<script type="math/tex; mode=display">P(X=x)=\sum_{k=1}^{K}P(X=x|Y=c_k)P(Y=c_k)</script></li>
<li>朴素贝叶斯=贝叶斯公式+条件独立性假设<ol>
<li>贝叶斯公式<script type="math/tex; mode=display">y=argmax_{c_k}\frac{P(Y=c_k)P(X=x|Y=c_k)}{\displaystyle\sum_{k}^KP(Y=c_k)P(X=x|Y=c_k)}</script></li>
<li>条件独立性假设<script type="math/tex; mode=display">P(X=x|Y=c_k)=\prod_{j=1}^nP(X_j=x_j|Y=c_k)P(Y=c_k)</script></li>
</ol>
</li>
</ol>
<blockquote>
<blockquote>
<p>计算后验概率分布，将后验概率最大的x的类别作为输出，使用贝叶斯定理计算最大后验概率。另：贝叶斯公式=条件概率公式+全概率公式。</p>
</blockquote>
</blockquote>
<h4 id="拉普拉斯平滑"><a href="#拉普拉斯平滑" class="headerlink" title="拉普拉斯平滑"></a>拉普拉斯平滑</h4><p> 如果$P(x_i|y=c_k)$中的某一项为0，则其联合概率的乘积也为0.如果是k类分母+k，分子+1；分母加k的原因是使之满足全概率公式。</p>
<h3 id="置信度与置信区间"><a href="#置信度与置信区间" class="headerlink" title="置信度与置信区间"></a>置信度与置信区间</h3><p>置信度：95%，置信区间(u-a,u+a)样本数目不变的情况下，做100次试验，有95个置信区间包含了总体真值(虚线)。</p>
<script type="math/tex; mode=display">P(\mu - 1.96 \frac{\sigma}{\sqrt{n}} < M < \mu + 1.96 \frac{\sigma}{\sqrt{n}} ) = 0.95</script><p>样本均值为整体均值的一个点估计。<strong>置信水平95%表示，有100个样本，每个样本会计算出一个置信区间。其中有95个置信区间包含了总体均值。也就是包含总体平均值的概率为95%。样本估计总体—核心思想</strong><br><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/zhixindu.gif" alt="avatar"></p>
<h3 id="各种熵"><a href="#各种熵" class="headerlink" title="各种熵"></a>各种熵</h3><ul>
<li><p>信息熵：</p>
<script type="math/tex; mode=display">H(D)=-\sum_{y=k}^{K}p_k·log(p_k)</script></li>
<li><p>联合熵：</p>
<script type="math/tex; mode=display">H(X,Y)=-\sum_{x,y}p(x,y)\log p(x,y)</script></li>
<li><p>条件熵：条件熵=联合熵-熵</p>
<script type="math/tex; mode=display">H(Y|X)=H(X,Y)-H(X)</script><script type="math/tex; mode=display">H(D|f)=\sum_{v\epsilon V_f}\frac{|D_v|}{|D|}H(D_v)</script></li>
<li>信息增益：<script type="math/tex; mode=display">Gain(D,f)=H(D)-H(D|f)</script></li>
<li>交叉熵：<script type="math/tex; mode=display">H(p,q)=-\sum_x p(x)\log q(x)</script></li>
<li>KL散度（相对熵）=交叉熵-熵<script type="math/tex; mode=display">D_{KL}(p||q)=H(p,q)-H(p)</script><blockquote>
<blockquote>
<p>p对q的相对熵,q拟合p的分布情况</p>
<script type="math/tex; mode=display">D_{KL}(p||q)=\sum_{x}p(x)\log \frac{p(x)}{q(x)}=-\sum_x p(x)\log q(x)-(-\sum_x p(x)\log p(x))</script><p>相对熵可以用来衡量两个概率分布之间的差异，上面公式的意义就是求 p 与 q 之间的对数差在 p 上的期望值。</p>
</blockquote>
</blockquote>
</li>
</ul>
<h2 id="矩阵论"><a href="#矩阵论" class="headerlink" title="矩阵论"></a>矩阵论</h2><p><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/Matrix.png" alt="avatar"><br><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/Matrix2.png" alt="avatar"><br><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/Matrix3.png" alt="avatar"><br><img src="/2019/10/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/Matrix4.png" alt="avatar"></p>
<h3 id="向量与矩阵求导"><a href="#向量与矩阵求导" class="headerlink" title="向量与矩阵求导"></a>向量与矩阵求导</h3><ul>
<li>包含元素x的求导就是元素x对矩阵的各元素a求导,或者矩阵各元素a对元素x的求导。</li>
<li><p>向量对向量求导</p>
<ol>
<li>行向量m对列向量n：行的每一个元素对列向量求导，导数矩阵：n*m;</li>
<li>列向量m对行向量n：列的每一个元素对行向量求导，导数矩阵：m*n;</li>
<li>行向量m对行向量n：一行m*n列</li>
<li>列向量m对列向量n：一列m*n行</li>
</ol>
</li>
<li><p>矩阵对向量求导</p>
<ol>
<li>矩阵看做列向量，对行向量求导：<strong>矩阵</strong>对各个元素求导，横向拼接</li>
<li>矩阵看做列向量，对列向量求导：<strong>各个元素</strong>对列向量求导，整体拼接</li>
</ol>
</li>
<li><p>向量对矩阵求导</p>
<ol>
<li>行向量对矩阵求导：行向量对矩阵的<strong>各个元素</strong>求导，然后拼接</li>
<li>列向量对矩阵求导：列向量的<strong>各个元素</strong>对矩阵求导，然后拼接</li>
</ol>
</li>
<li><p>矩阵Y对矩阵X求导</p>
<ol>
<li>Y看做列向量，X看做行向量：Y的列向量对X的行向量逐一求导</li>
</ol>
</li>
</ul>
<h3 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h3><h4 id="2-1-矩阵分解为特征值与特征向量"><a href="#2-1-矩阵分解为特征值与特征向量" class="headerlink" title="2.1 矩阵分解为特征值与特征向量"></a>2.1 矩阵分解为特征值与特征向量</h4><script type="math/tex; mode=display">Av=\lambda v</script><p>$V=[v_1,v_2,v_3,,,,v_n]$,$\Lambda=[\lambda_1,\lambda_2,\lambda_3,,,]$则有</p>
<blockquote>
<blockquote>
<p>$\lambda$降序排列</p>
<script type="math/tex; mode=display">A=V * diag(\lambda)*V^{-1}</script><p>正定矩阵的转置就是正定矩阵的逆</p>
<script type="math/tex; mode=display">A=Q \Lambda Q^{T}</script><p>Q是正交矩阵，将A看作沿方向$v^i$延展$\lambda ^i$倍的空间。所有的特征值都是正数则正定，非负数半正定。<strong>但是仅对于方阵才行</strong></p>
</blockquote>
</blockquote>
<h4 id="矩阵分解为奇异值与奇异向量SVD"><a href="#矩阵分解为奇异值与奇异向量SVD" class="headerlink" title="矩阵分解为奇异值与奇异向量SVD"></a>矩阵分解为奇异值与奇异向量SVD</h4><script type="math/tex; mode=display">A_{m,n}=U_{m,m}D_{m,n}V^T_{n,n}</script><p>U,V正交矩阵，D对角矩阵，对角线元素为为奇异值，U,V列向量为奇异向量<br>U是$AA^T$的特征向量；V是$A^TA$的特征向量。$AA^T$特征值的平方根就是D的非0奇异值<strong>只有非方阵，才行</strong></p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础</title>
    <url>/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h1><p><a href="https://www.cnblogs.com/wuliytTaotao/p/10513371.html" target="_blank" rel="noopener">机器学习之数学01</a></p>
<p><a href="https://www.cnblogs.com/wuliytTaotao/p/10603576.html" target="_blank" rel="noopener">机器学习之数学02</a></p>
<h2 id="机器学习和深度学习的区别"><a href="#机器学习和深度学习的区别" class="headerlink" title="机器学习和深度学习的区别"></a>机器学习和深度学习的区别</h2><ul>
<li>特征工程：机器学习中专家识别，业务数据人工编码，性能取决于特征提取准确程度；深度学习尝试提取低层次特征，自动化</li>
<li>深度学习的可解释性较差，机器学习的决策树算法规则清晰</li>
<li>深度学习是端到端</li>
<li>数据相关性：深度学习需要的更多</li>
<li>硬件依赖性：深度学习依赖高端机器</li>
<li>执行时间深度学习更长</li>
</ul>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><h3 id="生成式模型"><a href="#生成式模型" class="headerlink" title="生成式模型"></a>生成式模型</h3><p>由数据学到联合概率分布$P(X,Y)$,然后求出条件概率分布$P(Y|X)$作为预测模型。给定输入$X$产生输出$Y$的生成关系。<strong>收敛更快，隐变量时仍然能用</strong></p>
<script type="math/tex; mode=display">P(Y|X)=\frac{P(X,Y)}{P(X)}</script><blockquote>
<blockquote>
<p>朴素贝叶斯、隐马尔科夫模型（HMM）。</p>
</blockquote>
</blockquote>
<h3 id="判别式模型"><a href="#判别式模型" class="headerlink" title="判别式模型"></a>判别式模型</h3><p>由数据学习到决策函数$f(X)$或者条件概率模型$P(Y|X)$作为预测的模型。给定输入$X$，预测什么样的输出$Y$。<strong>更为准确，隐变量失效，定义和使用特征</strong></p>
<blockquote>
<blockquote>
<p>KNN、感知机、逻辑斯蒂回归（Logistic Regression）、最大熵、支持向量机（SVM）、条件随机场（CRF）、决策树。</p>
</blockquote>
</blockquote>
<a id="more"></a>
<h3 id="模型的泛化能力-泛化误差上界"><a href="#模型的泛化能力-泛化误差上界" class="headerlink" title="模型的泛化能力-泛化误差上界"></a>模型的泛化能力-泛化误差上界</h3><p>对任意函数f，至少以概率$1-\delta$使得不等式成立</p>
<script type="math/tex; mode=display">\delta=d*\exp(-2N\epsilon^2)</script><script type="math/tex; mode=display">\epsilon(d,N,\delta)=\sqrt{\frac{1}{2N}(\log d+\log \frac{1}{\delta})}</script><script type="math/tex; mode=display">R(f_N)<R_{f_N}^{train}+\epsilon(d,N,\delta)</script><ol>
<li>训练误差越小，则泛化误差越小；</li>
<li>样本容量N越大，则训练误差与泛化误差越接近；</li>
<li>假设空间中包含的函数越多，则泛化误差上界越大。</li>
</ol>
<h3 id="模型融合"><a href="#模型融合" class="headerlink" title="模型融合"></a>模型融合</h3><ol>
<li>平均法</li>
<li>投票法</li>
<li>bagging</li>
<li>boosting</li>
<li>stacking 精排得分入重排序</li>
</ol>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><script type="math/tex; mode=display">\theta^*=argmin_{\theta}\frac{1}{N}\sum_{i=1}^{N}L(y_i,f(x_i;\theta))+\lambda\Omega(\theta)</script><hr>
<h3 id="Loss-损失函数"><a href="#Loss-损失函数" class="headerlink" title="Loss 损失函数"></a>Loss 损失函数</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ol>
<li><p>对数损失-交叉熵取均值</p>
<ol>
<li><script type="math/tex; mode=display">J(\theta)=-\frac{1}{N}\sum_{i=1}^{N}[y_{i}log(h_{\theta}(x_i))+(1-y_{i})log(1-h_{\theta}(x_i))]</script></li>
<li><script type="math/tex; mode=display">CrossEntropy(\theta)=-\sum_{i=1}^{N}[y_{i}log(h_{\theta}(x_i))+(1-y_{i})log(1-h_{\theta}(x_i))]</script></li>
</ol>
</li>
<li><p>指数损失-Adaboost</p>
<script type="math/tex; mode=display">L(y,f(x))=\frac{1}{N}\sum_{i=1}^{N}e^{-y_if(x_i)}</script></li>
<li><p>合页损失-SVM</p>
<script type="math/tex; mode=display">L(y·(w*x+b))=\sum_{i=1}^{N}[1-y(w*x+b)]_++\lambda||w||^2</script></li>
<li><p>决策树</p>
<script type="math/tex; mode=display">C_\alpha(T)=\sum_{t=1}^{T}N_tH_t(T)+\alpha|T|</script></li>
<li><p>focal loss- 推荐挖掘困难样本</p>
<script type="math/tex; mode=display">L_{fl}=-\alpha(1-p)^\gamma \log(p); p=1</script><script type="math/tex; mode=display">L_{fl}=-(1-\alpha)p^\gamma \log(1-p); p=0</script></li>
<li><p>多分类交叉熵损失</p>
</li>
<li>KL散度</li>
</ol>
<h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><ol>
<li><p>平方损失-回归</p>
<script type="math/tex; mode=display">MSE=\frac{1}{N}\sum_{i=1}^{N}(y_i^{pred}-y_i^{true})^2</script></li>
<li><p>绝对误差损失</p>
<script type="math/tex; mode=display">MAE=\sum_{i=1}^{n}|y-f(x)|</script></li>
<li><p>Huber损失<br>Huber损失结合了MSE和MAE的最佳特性。对于较小的误差，它是二次的，否则是线性的(对于其梯度也是如此)。Huber损失需要确定δ参数：</p>
</li>
</ol>
<p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/640.webp" alt></p>
<h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><blockquote>
<blockquote>
<p>准确率，精确率，召回率，均方根误差</p>
</blockquote>
</blockquote>
<ul>
<li>准确率：正负样本不均衡时，大类别特别影响准确率；</li>
<li>精确率：$Precision=\frac{TP}{TP+FP}$</li>
<li>召回率：$Recall=\frac{TP}{TP+FN}$</li>
</ul>
<blockquote>
<blockquote>
<p>由此得到P-R曲线越右上角越好；且$F_1=\frac{2pr}{p+r}$</p>
</blockquote>
</blockquote>
<ul>
<li>均方根误差：异常点影响大<script type="math/tex; mode=display">RMSE=\sqrt{\frac{1}{N}\sum_{i=1}^{N}(y_i^{pred}-y_i^{true})^2}</script></li>
<li>MAPE：平均绝对百分比误差，每个点误差进行归一化<script type="math/tex; mode=display">MAPE=\sum_{i=1}^{N}|\frac{y_i^{true}-y_i^{pred}}{y_i^{true}}|*\frac{100}{N}</script></li>
</ul>
<h3 id="3、ROC曲线"><a href="#3、ROC曲线" class="headerlink" title="3、ROC曲线"></a>3、ROC曲线</h3><ul>
<li>优点：不受类分布的影响，适合与评估、比较类分布不平衡的数据集。</li>
<li>缺点：ROC和AUC仅适合于两类问题 ,对多类问题 ,无法直接应用。</li>
</ul>
<p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/AUC.gif" alt></p>
<h4 id="3-1、AUC"><a href="#3-1、AUC" class="headerlink" title="3.1、AUC"></a>3.1、AUC</h4><p>定义：AUC值为ROC曲线所覆盖的区域面积，显然，AUC越大，分类器分类效果越好。</p>
<ul>
<li>AUC = 1，是完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。</li>
<li>0.5 &lt; AUC &lt; 1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。</li>
<li>AUC = 0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。</li>
<li>AUC &lt; 0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测。</li>
</ul>
<h4 id="3-2、AUC值的物理意义"><a href="#3-2、AUC值的物理意义" class="headerlink" title="3.2、AUC值的物理意义"></a>3.2、AUC值的物理意义</h4><p>假设分类器的输出是样本属于正类的socre（置信度），<strong>AUC的物理意义为：任取一对（正、负）样本，正样本的score大于负样本的score的概率。</strong></p>
<h4 id="3-3、AUC值的计算"><a href="#3-3、AUC值的计算" class="headerlink" title="3.3、AUC值的计算"></a>3.3、AUC值的计算</h4><ul>
<li>第一种方法：AUC为ROC曲线下的面积，那我们直接计算面积可得。面积为一个个小的梯形面积之和，计算的精度与阈值的精度有关。</li>
<li>第二种方法：根据AUC的物理意义，我们计算正样本score大于负样本的score的概率。取N*M（M为正样本数，N为负样本数）个二元组，比较score，最后得到AUC。时间复杂度为O(N*M)。</li>
<li><strong>第三种方法</strong>：<a href="https://www.cnblogs.com/van19/p/5494908.html" target="_blank" rel="noopener">AUC计算</a>首先对score从大到小排序，然后令最大score对应的sample的rank值为n，第二大score对应sample的rank值为n-1，以此类推从n到1。然后把所有的正类样本的rank相加，再减去正类样本的score为最小的那M个值的情况。得到的结果就是有多少对正类样本的score值大于负类样本的score值，最后再除以M×N即可。值得注意的是，当存在score相等的时候，对于score相等的样本，需要赋予相同的rank值(无论这个相等的score是出现在同类样本还是不同类的样本之间，都需要这样处理)。\</li>
</ul>
<p>(正类与分数低者比较次数，正类与正类比较的次数)\<br>(n,m),\<br>(n-1,m-1),\<br>(n-2,m-2),\<br>,,,\<br>(n-(m-1),1)<br>左求和，右求和再相减即为下式</p>
<script type="math/tex; mode=display">AUC=\frac{\sum_{i \in posClass}rank_i - \frac{M(M+1)}{2}}{M*N}</script><p>时间复杂度为O(N+M)。</p>
<h4 id="3-4、ROC与P-R曲线对比"><a href="#3-4、ROC与P-R曲线对比" class="headerlink" title="3.4、ROC与P-R曲线对比"></a>3.4、ROC与P-R曲线对比</h4><p>ROC明显降低不同测试集带来的干扰，困难样本下，ROC更加稳定反应模型的排序效果。</p>
<h3 id="4、排序指标"><a href="#4、排序指标" class="headerlink" title="4、排序指标"></a>4、排序指标</h3><h4 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h4><p>对用户u的返回结果I（item的顺序1,2,,,10）的平均准确率（AP）</p>
<script type="math/tex; mode=display">AP_u = \frac{1}{|I_u|}\sum_{i \in I_u}\frac{\sum_{j \in I_u}\delta(p_{uj} < p_{ui}) + 1}{p_{ui}}</script><p>MAP(Mean Average Precision)即为所有用户取AP的均值有：</p>
<script type="math/tex; mode=display">MAP = \frac{\sum_{u \in U}AP_u}{|{U}|}</script><h4 id="举个列子"><a href="#举个列子" class="headerlink" title="举个列子"></a>举个列子</h4><p>$命中的pos对应precision=\frac{pos及以上的命中个数}{pos}$，没命中的为0</p>
<p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/AP.png" alt><br>在对所有用户求均值</p>
<h4 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h4><p>计算该位置和item的相关性得分；</p>
<script type="math/tex; mode=display">累计收益：CG_k = \sum_{i=1}^k rel_i</script><p>没有考虑不同位置，靠后得分应该低；故增加pos的罚项对排名靠后的收益打折：</p>
<script type="math/tex; mode=display">贴现累计收益：DCG_k = \sum_{i=1}^k \frac{2^{rel_i}-1}{\log_2 (i+1)}</script><p>不同用户的推荐列表进行评估，需要以最好的收益IDCG为base进行归一化</p>
<script type="math/tex; mode=display">归一化贴现累计收益：NDCG_u@k = \frac{DCG_u@k}{IDCG_u} ，k=list.size</script><h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h2><p>梯度下降、牛顿法</p>
<hr>
<h3 id="1、机器学习中的梯度下降"><a href="#1、机器学习中的梯度下降" class="headerlink" title="1、机器学习中的梯度下降"></a>1、机器学习中的梯度下降</h3><p>梯度下降首先需要明确损失函数Loss function（一个样本损失）和代价函数Cost function（统计平均意义下的损失）。</p>
<script type="math/tex; mode=display">w^{(k+1)} = w^{(k)} - \alpha \cdot  \nabla C(w^{(k)})</script><p>f(x,y)=x²+y²<br><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/tidu1.png" alt="avatar"><br>将f(x,y)=x²+y²看做<strong>二维等高图</strong><br><strong>对于二维曲面来说，切线的方向有上有下描述的是函数值的方向；梯度代表使函数值增大时，各个自变量的变化方向；梯度下降就是梯度反方向更新各个自变量可以使得函数值减小。梯度方向与切线方向垂直。</strong></p>
<p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/tidu2.png" alt="avatar"><br><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/futidu.jpeg" alt="avatar"></p>
<h4 id="1-1、批梯度下降比较"><a href="#1-1、批梯度下降比较" class="headerlink" title="1.1、批梯度下降比较"></a>1.1、批梯度下降比较</h4><ol>
<li>批梯度下降会获得全局最优解，缺点是在更新每个参数的时候需要遍历所有的数据，计算量会很大，并且会有很多的冗余计算，导致的结果是当数据量大的时候，每个参数的更新都会很慢。</li>
<li>随机梯度下降是以高方差频繁更新，优点是使得sgd会跳到新的和潜在更好的局部最优解，缺点是使得收敛到局部最优解的过程更加的复杂。</li>
<li>小批量梯度下降结合了sgd和batch gd的优点，每次更新的时候使用n个样本。减少了参数更新的次数，可以达到更加稳定收敛结果，一般在深度学习当中我们采用这种方法。</li>
</ol>
<blockquote>
<blockquote>
<p><strong>全局最优</strong>&lt;=&gt;通过梯度下降得到的最小值在全局Loss中也是最小值&lt;=&gt;Loss函数是否是凸的&lt;=&gt;<strong>二阶导(海森矩阵)判断是否正定</strong></p>
</blockquote>
</blockquote>
<h4 id="1-2、最速下降"><a href="#1-2、最速下降" class="headerlink" title="1.2、最速下降"></a>1.2、最速下降</h4><p>最速下降法（Steepest descent）是梯度下降法的一种更具体实现形式，其理念为在每次迭代中选择合适的步长$\alpha_k$使得目标函数值能够得到最大程度的减少。<br>每一次迭代，沿梯度的反方向，我们总可以找到一个</p>
<script type="math/tex; mode=display">w^{(k+1)} = w^{(k)} - \alpha_k \cdot  \nabla C(w^{(k)})</script><p>使得在这个方向上$f(x^{(k+1)})$取最小值。</p>
<script type="math/tex; mode=display">\alpha_k = \mathop{\arg\min}_{\alpha \ge 0} f(x^{(k)} - \alpha \nabla f(x^{(k)}))</script><p>有意思的是，最速下降法每次更新的轨迹都和上一次垂直。而且只要梯度$\nabla f(x^{(k)}) \not = 0$则$f(x^{(k+1)}) &lt; f(x^{(k)})$<br>（即梯度不等于 0 时，肯定会下降。）</p>
<h4 id="1-3、多分类梯度下降"><a href="#1-3、多分类梯度下降" class="headerlink" title="1.3、多分类梯度下降"></a>1.3、多分类梯度下降</h4><p>softmax 函数的表达式为:</p>
<script type="math/tex; mode=display">y_i = \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}}</script><script type="math/tex; mode=display">\frac{\partial y_i}{\partial z_j}
= \frac{\partial \frac{e^{z_i}}{\sum_{t = 1}^m e^{z_t}}}{\partial z_j}
\tag{2}</script><p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/38.jpg" alt="avatar"><br><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/39.jpg" alt="avatar"></p>
<h3 id="2、牛顿法"><a href="#2、牛顿法" class="headerlink" title="2、牛顿法"></a>2、牛顿法</h3><p>在确定搜索方向时，<strong>梯度下降和最速下降只用到了目标函数的一阶导数（梯度），而牛顿法（Newton’s method）用到了二阶（偏）导数。</strong><br>牛顿法的基本思路是在每次迭代中，利用二次型函数来局部近似目标函数f，并求解近似函数的极小点作为下一个迭代点，牛顿法自变量x的更新公式为：</p>
<script type="math/tex; mode=display">x^{(k+1)} = x^{(k)} - F(x^{(k)})^{-1}\nabla f( x^{(k)})</script><p>当前点离min点较近趋势可能不会错，但较远时会带偏。</p>
<h3 id="3-Levenberg-Marquardt修正"><a href="#3-Levenberg-Marquardt修正" class="headerlink" title="3.Levenberg-Marquardt修正"></a>3.Levenberg-Marquardt修正</h3><ul>
<li>牛顿法引入二阶导数拟合f，依据f的变化趋势去梯度下降，收敛更快，迭代次数更少。但同时会引入问题，拟合会有误差，当前离min点较远时，趋势可能不对。</li>
<li>多元函数的Hessian矩阵就类似一元函数的二阶导。多元函数Hessian矩阵半正定就相当于一元函数二阶导非负，半负定就相当于一元函数二阶导非正</li>
</ul>
<p>如果黑塞矩阵$F(x^{(k)})$不正定，那么搜索方向$ d^{(k)} = - F( x^{(k)})^{-1}\nabla f( x^{(k)})$可能不会是下降方向。 牛顿法的 Levenberg-Marquardt 修正可以解决这个问题：</p>
<script type="math/tex; mode=display">x^{(k+1)} = x^{(k)} - \alpha_k(F( x^{(k)})  + \mu_k I)^{-1}\nabla f(x^{(k)})</script><p>其中，$\mu_k \ge 0$，I为单位矩阵。在该修正中，$F( x^{(k)})$可以不正定，但是$ G = F( x^{(k)}) + \mu_k , I$需要是正定的，所以，取适当的$\mu_k$使得$ G$正定即可。（矩阵正定，当前仅当所有特征值大于 0。）</p>
<h4 id="牛顿法-vs-梯度下降"><a href="#牛顿法-vs-梯度下降" class="headerlink" title="牛顿法 vs 梯度下降"></a>牛顿法 vs 梯度下降</h4><ul>
<li>牛顿法是二阶收敛，梯度下降法是一阶收敛，所以牛顿法就更快。</li>
<li>更通俗地，梯度下降法只从当前位置选择一个坡度最大的方向走一步，而牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑走了一步后，坡度是否会变得更大。</li>
<li>从几何上说，牛顿法就是用一个二次曲面去拟合当前位置的的局部曲面，而梯度下降法用的是一个平面去拟合，通常情况下，二次曲面的拟合会比平面更好，所以牛顿法选择的下降路径会更符合真实的最优下降路径。</li>
</ul>
<h3 id="4-拟牛顿法-牛顿法hessian矩阵的优化求解"><a href="#4-拟牛顿法-牛顿法hessian矩阵的优化求解" class="headerlink" title="4.拟牛顿法-牛顿法hessian矩阵的优化求解"></a>4.拟牛顿法-牛顿法hessian矩阵的优化求解</h3><p>在每次迭代的时候计算一个矩阵，其逼近海塞矩阵的逆。最重要的是，该逼近值只是使用损失函数的一阶偏导来计算求出$  H_{k+1}$给出 $  H_{k}$，梯度$f(  x^{(k)})$，$  d^{(k)}$，$\alpha_k$找到 $  H_{k+1}$的递推式，那么在迭代过程中就不需要涉及到黑塞矩阵也不会求逆。</p>
<script type="math/tex; mode=display">\boldsymbol{H}_{k+1}=\boldsymbol{H}_{k}+\frac{\left(\Delta \boldsymbol{x}^{(k)}-\boldsymbol{H}_{k} \Delta \boldsymbol{g}^{(k)}\right)\left(\Delta \boldsymbol{x}^{(k)}-\boldsymbol{H}_{k} \Delta \boldsymbol{g}^{(k)}\right)^{\top}}{\Delta \boldsymbol{g}^{(k) \top}\left(\Delta \boldsymbol{x}^{(k)}-\boldsymbol{H}_{k} \Delta \boldsymbol{g}^{(k)}\right)}</script><p>$\Delta x^{(k)}=\alpha_{k} d^{(k)}$，$\Delta \boldsymbol{g}^{(k)}=\boldsymbol{g}^{(k+1)}-\boldsymbol{g}^{(k)}$<br>$  H_0$可以取任一对称正定实矩阵。</p>
<h2 id="四、偏差与方差"><a href="#四、偏差与方差" class="headerlink" title="四、偏差与方差"></a>四、偏差与方差</h2><p><a href="http://liuchengxu.org/blog-cn/posts/bias-variance/" target="_blank" rel="noopener">参考链接</a></p>
<ol>
<li>泛化误差：以回归任务为例, 学习算法的平方预测误差期望为:<script type="math/tex; mode=display">Err(\mathbf{x}) = E\left[\left( y - f(\mathbf{x}; D) \right)^2\right]</script></li>
<li>方差：在一个训练集 D上模型 f 对测试样本 x 的预测输出为 f(x;D), 那么学习算法 f 对测试样本 x 的 期望预测和使用样本数相同的不同训练集产生的方差为:<script type="math/tex; mode=display">\overline{f}(\mathbf{x}) = E_D\left[f\left(\mathbf{x}; D\right)\right]</script><script type="math/tex; mode=display">var(\mathbf{x}) = E_D\left[\left( f(\mathbf{x}; D) - \overline{f}(\mathbf{x}) \right)^2\right]</script></li>
<li>偏差：期望预测与真实标记的误差称为偏差(bias), 为了方便起见, 我们直接取偏差的平方:<script type="math/tex; mode=display">bias^2(\mathbf{x}) = \left( \overline{f}(\mathbf{x}) - y \right)^2</script></li>
<li>噪声：噪声为真实标记与数据集中的实际标记间的偏差:<script type="math/tex; mode=display">\epsilon^2 = E_D\left[ (y_D - y)^2 \right]</script></li>
</ol>
<h3 id="4-1、方差与偏差推导"><a href="#4-1、方差与偏差推导" class="headerlink" title="4.1、方差与偏差推导"></a>4.1、方差与偏差推导</h3><p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/38.png" alt="avatar"><br><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/39.png" alt="avatar"></p>
<ul>
<li>偏差度量了学习算法的期望预测与真实结果的偏离程序, 即 刻画了学习算法本身的拟合能力 .</li>
<li>方差度量了同样大小的训练集的变动所导致的学习性能的变化, 即 刻画了数据扰动所造成的影响 .</li>
<li>噪声表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界, 即 刻画了学习问题本身的难度.</li>
</ul>
<p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/40.png" alt="avatar"></p>
<h2 id="五、L1和L2正则"><a href="#五、L1和L2正则" class="headerlink" title="五、L1和L2正则"></a>五、L1和L2正则</h2><ul>
<li>L1大部分特征的权重降为0，变稀疏矩阵，只保留少量特征。目标函数等高线与L1正则的解空间决定，“棱”状更能碰撞出稀疏值。类似减少特征的方式解决过拟合</li>
<li>L2少量降为0，大部分权重减小。降低所有特征的权重。整体减小所有特征权重，来解决过拟合</li>
</ul>
<p>L0范数指向量中非零元素的个数</p>
<script type="math/tex; mode=display">\|w\|_0=\sum_{w_i!=0}^{W}{|w_i|}</script><p>L1范数：向量中每个元素绝对值的和</p>
<script type="math/tex; mode=display">\|w\|_1=\sum_{i=1}^{N}{|w_i|}</script><p>L2范数：向量元素绝对值的平方和再开平方</p>
<script type="math/tex; mode=display">\|w\|_2=\sqrt{\sum_{i=1}^{N}{w_i^2}}</script><p>L1正则公式</p>
<script type="math/tex; mode=display">L=L_{0}+\lambda\sum_j|w_j|</script><p>L2正则公式</p>
<script type="math/tex; mode=display">L=L_{0}+\lambda\sum_jw_j^2</script><h3 id="解的稀疏性"><a href="#解的稀疏性" class="headerlink" title="解的稀疏性"></a>解的稀疏性</h3><p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/l1l2.png" alt="avatar"></p>
<h2 id="六、优化过拟合和欠拟合"><a href="#六、优化过拟合和欠拟合" class="headerlink" title="六、优化过拟合和欠拟合"></a>六、优化过拟合和欠拟合</h2><h3 id="降低过拟合"><a href="#降低过拟合" class="headerlink" title="降低过拟合"></a>降低过拟合</h3><ol>
<li>更多的数据；</li>
<li>降低模型复杂度；</li>
<li>正则化方法；</li>
<li>bagging 多个模型集成在一起，降低单一模型过拟合风险；</li>
<li>减少特征：PCA等<h3 id="降低欠拟合"><a href="#降低欠拟合" class="headerlink" title="降低欠拟合"></a>降低欠拟合</h3></li>
<li>添加新特征（深度学习提供稠密特征，因子分解机）</li>
<li>增加模型复杂度；</li>
<li>减少正则化系数</li>
</ol>
<h2 id="七、拉格朗日乘法"><a href="#七、拉格朗日乘法" class="headerlink" title="七、拉格朗日乘法"></a>七、拉格朗日乘法</h2><script type="math/tex; mode=display">\begin{aligned}
&{}\max f(x, y), \\
&{}\text{s.t. } g(x, y) = c.
\end{aligned}</script><script type="math/tex; mode=display">\mathcal{L}(x, y, \lambda) \overset{\text{def}}{=}f(x, y) + \lambda\cdot g(x, y).</script><script type="math/tex; mode=display">\begin{cases}
\frac{\partial \mathcal{L}}{\partial x} = 0, \\
\frac{\partial \mathcal{L}}{\partial y} = 0, \\
\frac{\partial \mathcal{L}}{\partial \lambda} = 0.
\end{cases}</script><p>函数 f(x,y)=x²+y² 是曲面<strong>特别地，对于序列 {d1,d2,…} 来说，f(x,y)=dk 形成了一系列的曲线。若将 dk 理解为高度，则这一系列的曲线即是函数 f(x,y) 的等高线组。</strong> 同样，对于约束 g(x,y)=x²-y=C 来说它也是一条曲线，我们称之为约束曲线。对g曲线求导得到法向量，对f也如此；故有下式成立</p>
<script type="math/tex; mode=display">\Bigl(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\Bigr) = \lambda\Bigl(\frac{\partial g}{\partial x}, \frac{\partial g}{\partial y}\Bigr)</script><p>函数曲线相切，意味着两个函数的法线在切点重合，也就是两个函数的法向量相差一个系数 λ，这也就是说两个函数在切点的梯度向量相差一个系数 λ</p>
<h3 id="7-1、KKT条件"><a href="#7-1、KKT条件" class="headerlink" title="7.1、KKT条件"></a>7.1、KKT条件</h3><p><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/kkt.jpeg" alt="avatar"><br><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/lglr.jpg" alt="avatar"><br>因此我们说，拉格朗日乘数法有很直观的物理意义。<br>对于h(x)&gt;=0的设定如下<br><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/hx1.jpg" alt="avatar"><br><img src="/2019/10/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/hx2.jpg" alt="avatar"></p>
<h2 id="八、特征选择"><a href="#八、特征选择" class="headerlink" title="八、特征选择"></a>八、特征选择</h2><p>特征选取包含一些特征处理的操作：</p>
<ul>
<li>特征清洗（缺失，异常，样本比例权重）</li>
<li><strong>标准化</strong>和归一化）</li>
</ul>
<h3 id="为何标准化和归一化"><a href="#为何标准化和归一化" class="headerlink" title="为何标准化和归一化"></a>为何标准化和归一化</h3><h4 id="模型求解需要"><a href="#模型求解需要" class="headerlink" title="模型求解需要"></a>模型求解需要</h4><ol>
<li>归一化后加速学习，不同特征方向上收敛同步；</li>
<li>距离求解<h4 id="无量纲化"><a href="#无量纲化" class="headerlink" title="无量纲化"></a>无量纲化</h4></li>
<li>不同特征没有量纲不具有比较意义<h4 id="避免数值bias"><a href="#避免数值bias" class="headerlink" title="避免数值bias"></a>避免数值bias</h4></li>
</ol>
<h3 id="标准化：更好保持样本间距；符合统计假设"><a href="#标准化：更好保持样本间距；符合统计假设" class="headerlink" title="标准化：更好保持样本间距；符合统计假设"></a>标准化：更好保持样本间距；符合统计假设</h3><h4 id="什么时候需要标准化"><a href="#什么时候需要标准化" class="headerlink" title="什么时候需要标准化"></a>什么时候需要标准化</h4><p><strong>正则一定标准化</strong>.$w$的大小与特征数值范围有关；此外标准化w大小可以反映不同特征对样本的贡献度。<strong>与测试集分开标准化</strong></p>
<h3 id="归一化-广义上也可以指标准化"><a href="#归一化-广义上也可以指标准化" class="headerlink" title="归一化-广义上也可以指标准化"></a>归一化-广义上也可以指标准化</h3><p>把数据归一化到[min,max]之间</p>
<h3 id="何时归一化，何时标准化"><a href="#何时归一化，何时标准化" class="headerlink" title="何时归一化，何时标准化"></a>何时归一化，何时标准化</h3><ul>
<li>优先标准化：数据分布有先验假设；</li>
<li>距离度量，PCA降维时用Z标准化；其他不涉及分布的时候可以区间归一化</li>
</ul>
<h3 id="特征选取方法-理论"><a href="#特征选取方法-理论" class="headerlink" title="特征选取方法-理论"></a>特征选取方法-理论</h3><ol>
<li>过滤：按照发散性对特征评分，比如特征的方差过小可以考虑过滤掉；<strong>覆盖率，皮尔逊，fisher得分，假设检验，互信息，相关特征选择</strong>；</li>
<li>包装：根据目标函数，去掉特征观察效果；<strong>完全搜索，启发式搜索</strong></li>
<li>嵌入法：树模型（组合，特征重要性）；DNN；业务相关统计特征（线性与非线性特征转换）</li>
</ol>
<h3 id="特征离散化优点"><a href="#特征离散化优点" class="headerlink" title="特征离散化优点"></a>特征离散化优点</h3><ol>
<li>离散特征的增加和减少都很容易，易于模型的快速迭代；</li>
<li>稀疏向量计算快，<strong>特征易存储和扩展</strong></li>
<li><strong>对异常数据有很强的鲁棒性，更稳定</strong></li>
<li><strong>单变量离散化为多个后引入非线性，加大拟合</strong></li>
<li><strong>离散化后可以进行特征交叉</strong>，由M+N个变量变为M*N个变量，进一步引入非线性，提升表达能力</li>
<li><strong>简化模型降低过拟合</strong></li>
</ol>
<h2 id="数据不平衡"><a href="#数据不平衡" class="headerlink" title="数据不平衡"></a>数据不平衡</h2><ul>
<li>采样，对小样本加噪声采样，对大样本进行下采样</li>
<li>进行特殊的加权，如在Adaboost中或者SVM中</li>
<li>采用对不平衡数据集不敏感的算法</li>
<li>改变评价标准：用AUC/ROC来进行评价</li>
<li>采用Bagging/Boosting/ensemble等方法</li>
<li>考虑数据的先验分布</li>
</ul>
<h2 id="九、模型训练"><a href="#九、模型训练" class="headerlink" title="九、模型训练"></a>九、模型训练</h2><p><a href="https://mp.weixin.qq.com/s/v2Pnqvt1TT9Kk5ee0-Opxg" target="_blank" rel="noopener">学习率和batchsize选择</a></p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>树模型与集成学习</title>
    <url>/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="树模型与集成学习"><a href="#树模型与集成学习" class="headerlink" title="树模型与集成学习"></a>树模型与集成学习</h1><h2 id="决策树ID3-C4-5-CART树"><a href="#决策树ID3-C4-5-CART树" class="headerlink" title="决策树ID3,C4.5,CART树"></a>决策树ID3,C4.5,CART树</h2><p><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/1.png" alt="avatar"><br>特征枚举：根据规则选择特征<br>划分节点：根据特征进一步分裂叶子节点<br><strong>根据样本训练出GBDT树，对于每个叶子节点，回溯到根节点都可以得到一组组合特征，所以用叶子节点的标号可以代表一个新的组合特征</strong><br><a id="more"></a></p>
<h3 id="ID3算法——信息增益"><a href="#ID3算法——信息增益" class="headerlink" title="ID3算法——信息增益"></a>ID3算法——信息增益</h3><p>D为样本集合；$D_v$是特征f取v时的样本集。Gain信息增益=信息熵-条件熵</p>
<ul>
<li>信息熵：<script type="math/tex; mode=display">H(D)=-\sum_{y=k}^{K}p_k·log(p_k)</script></li>
<li>条件熵：<script type="math/tex; mode=display">H(D|f)=-\sum_{v\epsilon V_f}\frac{|D_v|}{|D|}H(D_v)</script></li>
<li>信息增益：<script type="math/tex; mode=display">Gain(D,f)=H(D)-H(D|f)</script></li>
<li>缺点：<strong>信息增益准则倾向于选取多值特征！</strong>假如把“编号”也作为一个候选划分属性，因为每一个样本的编号都是不同的（由于编号独特唯一，条件熵为0，每一个结点中只有一类，纯度非常高），也就是说，来了一个预测样本，你只要告诉我编号，其它特征就没有用了，这样生成的决策树显然不具有泛化能力。</li>
</ul>
<h3 id="C4-5算法——信息增益比"><a href="#C4-5算法——信息增益比" class="headerlink" title="C4.5算法——信息增益比"></a>C4.5算法——信息增益比</h3><p>信息增益比：</p>
<script type="math/tex; mode=display">Gain\_ratio(D,f)=\frac{Gain(D,f)}{IV(f)}</script><script type="math/tex; mode=display">IV(f)=-\sum_{y=k}^{K}p_{k,f}·log(p_{k,f})</script><p>IV(f)表明：某属性分成的K类别数越大，IV(f)就越大；是对多值属性的罚项，描述该特征下类别的离散程度。C4.5算法不直接选择增益率最大的候选划分属性，候选划分属性中找出信息增益高于平均水平的属性（这样保证了大部分好的的特征），再从中选择增益率最高的（又保证了不会出现编号特征这种极端的情况）</p>
<ul>
<li>优点<ol>
<li>可处理连续特征，排序取中间值。</li>
</ol>
</li>
</ul>
<h3 id="CART树——Gini系数"><a href="#CART树——Gini系数" class="headerlink" title="CART树——Gini系数"></a>CART树——Gini系数</h3><ul>
<li>总体样本的Gini系数：<script type="math/tex; mode=display">Gini(D)=1-\sum_{y=k}^{K}(\frac{D_k}{D})^2</script></li>
<li>特征f下的Gini系数<script type="math/tex; mode=display">Gini(D|f)=1-\sum_{v\epsilon V_f}\frac{D_v}{D}Gini(D_v)</script><strong>无论是回归还是分类问题，无论特征是离散的还是连续的，无论特征取值有多个还是两个，CART树内部节点只能根据属性值进行二分</strong></li>
<li>作为回归树：使用最小化MSE来选择特征并进行划分。遍历特征以及取值尝试划分，每一个叶子节点给出的预测值，是该叶子节点中所有样本的均值，计算最小平方误差。回归树生成使用平方误差最小化准则。</li>
<li>作为分类树：使用Gini指数最小化准则来选择特征并进行划分。Gini指数表示集合的不确定性，或者是不纯度。基尼指数越大，集合不确定性越高，不纯度也越大。这一点和熵类似。另一种理解基尼指数的思路是，基尼指数是为了最小化误分类的概率。</li>
</ul>
<h4 id="CART树，ID3，C4-5对比"><a href="#CART树，ID3，C4-5对比" class="headerlink" title="CART树，ID3，C4.5对比"></a>CART树，ID3，C4.5对比</h4><div class="table-container">
<table>
<thead>
<tr>
<th>算法</th>
<th>树</th>
<th>准则</th>
<th>多分类</th>
<th>回归</th>
<th>特征</th>
<th>缺失值</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID3</td>
<td>多叉树</td>
<td>信息增益</td>
<td>仅二分类</td>
<td>不能</td>
<td>仅离散</td>
<td>敏感</td>
<td>倾向多值特征    </td>
</tr>
<tr>
<td>C4.5</td>
<td>多叉树</td>
<td>信息增益比</td>
<td>仅二分类</td>
<td>不能</td>
<td>离散/连续</td>
<td>可处理</td>
<td>偏向少值特征。实际信息增益+信息增益比    </td>
</tr>
<tr>
<td>CART</td>
<td>仅二叉树</td>
<td>Gini系数</td>
<td>多分类</td>
<td>能</td>
<td>离散/连续</td>
<td>可处理</td>
<td>不需对数运算，更偏向于连续属性    </td>
</tr>
</tbody>
</table>
</div>
<h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>集成学习——bagging与boosting<br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/4.png" alt="avatar"><br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/3.png" alt="avatar"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>集成学习</th>
<th>基学习器</th>
<th>依赖关系</th>
<th>串/并行</th>
<th>复杂度</th>
<th>关注点</th>
<th>应用</th>
<th>预测结果</th>
<th>数据使用</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>bagging|强|弱|并行|基学习器同阶|降方差|可回归，可分类|投票/平均|有放回抽取<br>boosting|弱|强|串行|基学习器叠加|降偏差|可回归，可分类|累加/阈值|原数据样本权重会改变    </p>
<h3 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h3><p>多棵决策树，随机样本，随即特征进行划分。<br>分类：投票；回归：平均。<br>样本随机：63.2%（1-1/e）数据会被选区，<strong>36.8%(1/e)未被用到称为OOB样本，包外估计</strong>。<br>特征随机：从该节点特征集随机抽取K个，然后选择最优属性。<br>容易做成并行化方法</p>
<h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><p><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/9.png" alt="avatar"></p>
<ol>
<li>初始化第一棵树；</li>
<li>计算损失对前面k-1棵树的负梯度；</li>
<li>训练拟合得到第k棵树；</li>
<li>最小化损失获得步长η；将新的树添加到模型Fk</li>
</ol>
<ul>
<li>函数空间的梯度下降，函数拟合的是负梯度；最终函数等于每次迭代的增量的累加和。</li>
<li>参数空间的梯度下降，参数更新方向为负梯度方向；最终参数等于每次迭代的增量累加和。</li>
</ul>
<p>新的一棵树拟合的是模型的整体损失对前面k-1棵树的负梯度。</p>
<h4 id="GBDT多分类以及训练过程"><a href="#GBDT多分类以及训练过程" class="headerlink" title="GBDT多分类以及训练过程"></a>GBDT多分类以及训练过程</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[];label=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">(X,0) -&gt; t1;#得到预测值f1(X)</span><br><span class="line">(X,1) -&gt; t2;#得到预测值f2(X)</span><br><span class="line">(X,0) -&gt; t3;#得到预测值f3(X)</span><br><span class="line">对f1(x),f2(x),f3(x)进行softmax产生概率。得到残差：</span><br><span class="line">类别<span class="number">1</span>：y11(x)=<span class="number">0</span>−p1(x);</span><br><span class="line">类别<span class="number">2</span>：y22(x)=<span class="number">1</span>−p2(x);</span><br><span class="line">类别<span class="number">3</span>：y33(x)=<span class="number">0</span>−p3(x);</span><br><span class="line">-------------------------------</span><br><span class="line">(X,y11) -&gt; t11;#得到预测值f11(X)</span><br><span class="line">(X,y22) -&gt; t22;#得到预测值f22(X)</span><br><span class="line">(X,y33) -&gt; t33;#得到预测值f33(X)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h4 id="求解树复杂度"><a href="#求解树复杂度" class="headerlink" title="求解树复杂度"></a>求解树复杂度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">树深度K:</span><br><span class="line">    枚举所有特征d:</span><br><span class="line">        该特征下值排序 nlogn</span><br><span class="line">        线性扫描决定最佳分裂点</span><br><span class="line">        计算分裂后MSE或者Gini系数选择最优分裂点</span><br></pre></td></tr></table></figure>
<p>总体复杂度：<strong>K <em> d </em> nlogn。</strong></p>
<h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><p>xgb与gbdt的算法对比<br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/7.png" alt="avatar"><br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/11.jpg" alt="avatar"><br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/5.png" alt="avatar"></p>
<ul>
<li><p>GBDT：<br>GBDT构造新的一棵树，对损失近似到一阶导，拟合负梯度；属于函数空间中利用梯度下降法进行优化</p>
</li>
<li><p>XGBoost：<br>XGBoost构造新的一棵树，对损失近似到二阶导，拟合负一阶导/二阶导(+正则项)；属于函数空间中的牛顿法进行优化</p>
</li>
</ul>
<h4 id="GBDT-vs-XGB"><a href="#GBDT-vs-XGB" class="headerlink" title="GBDT vs XGB"></a>GBDT vs XGB</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>GBDT</th>
<th>XGB</th>
</tr>
</thead>
<tbody>
<tr>
<td>基分类器</td>
<td>树模型</td>
<td>树模型+LR回归</td>
</tr>
</tbody>
</table>
</div>
<p>树拟合|负梯度|负梯度/二阶导<br>方差-偏差权衡||目标函数+正则（叶子节点数，节点权重）<br>分割准则|回归：MSE；分类：基尼系数|最大化损失增益<br>分割方法||分位数法列举候选分割，求Gain最佳<br>缺失值处理||指定学习缺失值分类方向；忽略缺失值<br>|||列抽样，数据集抽样<br>|||并行化：特征值排序找出候选点，保存为列块结构，各个特征增益计算并行运算<br><a href="https://mp.weixin.qq.com/s/a4v9n_hUgxNyKSQ3RgDMLA" target="_blank" rel="noopener">XGB面试精选</a></p>
<h2 id="FM算法"><a href="#FM算法" class="headerlink" title="FM算法"></a>FM算法</h2><ul>
<li>优点： 减少特征交叉的选择工作，特征参数学习更加充分，提升参数学习效率和模型预估能力。</li>
<li>缺点：两两交叉，相比于DNN，GBDT更多特征的交叉</li>
</ul>
<h3 id="FM的计算"><a href="#FM的计算" class="headerlink" title="FM的计算"></a>FM的计算</h3><p><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/fm.png" alt><br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/fm.webp" alt></p>
<h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/m1.png" alt="avatar"><br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/m2.png" alt="avatar"><br><img src="/2019/10/25/%E6%A0%91%E6%A8%A1%E5%9E%8B/m3.png" alt="avatar"></p>
<h2 id="GBDT-FM"><a href="#GBDT-FM" class="headerlink" title="GBDT+FM"></a>GBDT+FM</h2><p>GBDT一棵树的叶子节点one-hot构成组合特征，该颗树特征对应一个K维向量作为该特$v_i$，进FM时两棵树的组合就是$v_i$和$v_j$的点成得到$w_{ij}$实际上是更多低阶特征的组合离散特征学习低维dense特征；</p>
<ol>
<li>提取统计类特征使用gbdt模型快速拿到收益;</li>
<li>加入海量离散类特征（个性化），使用LR/FM模型进一步提升效果。</li>
<li>至于原有的统计类特征可以通过gbdt叶子节点转换成离散特征一并加入到LR/FM中。</li>
</ol>
<h3 id="稀疏特征进FM"><a href="#稀疏特征进FM" class="headerlink" title="稀疏特征进FM"></a>稀疏特征进FM</h3><p>高维稀疏特征适合线性模型；LR+L2正则可以使得权重降低，不容易对稀疏特征过拟合。</p>
<h3 id="连续特征进GBDT"><a href="#连续特征进GBDT" class="headerlink" title="连续特征进GBDT"></a>连续特征进GBDT</h3><p><strong>统计特征，低维稠密特征适合树模型</strong>；一般统计特征具有总体的特征效果或全局性的因素</p>
<p>离散特征进GBDT时根据0，1划分节点偶然性太大，很容易过拟合；特征太多，树模型不易训练</p>
<h3 id="DNN的应用"><a href="#DNN的应用" class="headerlink" title="DNN的应用"></a>DNN的应用</h3><p>解决FM特征交叉能力受限的问题。<strong>DNN较容易学习到高阶非线性特征</strong></p>
<h3 id="GBDT-FM为什么不是RF-FM"><a href="#GBDT-FM为什么不是RF-FM" class="headerlink" title="GBDT+FM为什么不是RF+FM"></a>GBDT+FM为什么不是RF+FM</h3><ul>
<li>GBDT前面的树侧重对多数样本有区分度的特征；后面的树针对经过前面的树仍然残差大的少数样本</li>
<li>从bias and variance角度，RF降低variance而不改变bias, 而LR线性模型的variance足够低，需要更多的组合特征降低bias</li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><h3 id="非参考，仅推荐"><a href="#非参考，仅推荐" class="headerlink" title="非参考，仅推荐"></a>非参考，仅推荐</h3><p><a href="https://blog.csdn.net/program_developer/article/details/102763481" target="_blank" rel="noopener">深入理解GBDT算法</a><br><a href="https://blog.csdn.net/program_developer/article/details/102539034" target="_blank" rel="noopener">梯度提升树</a><br><a href="https://mp.weixin.qq.com/s/7n1nzGL7r789P9sv0GEkDA" target="_blank" rel="noopener">XGB详细推导</a></p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/2019/10/25/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h1><h2 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h2><p>K-means就是使得下列表达式最小</p>
<script type="math/tex; mode=display">J=\sum_{i=1}^{k}\sum_{x \in S_i}(x-\mu_i)^2</script><p>复杂度：$O(k <em> n </em> t)$<br><a id="more"></a></p>
<h2 id="基于层次的聚类："><a href="#基于层次的聚类：" class="headerlink" title="基于层次的聚类："></a>基于层次的聚类：</h2><ol>
<li>自底向上的凝聚方法，比如AGNES。</li>
<li>自上向下的分裂方法，比如DIANA。</li>
</ol>
<h2 id="基于密度的聚类："><a href="#基于密度的聚类：" class="headerlink" title="基于密度的聚类："></a>基于密度的聚类：</h2><p>DBSACN,OPTICS,BIRCH(CF-Tree),CURE.</p>
<h2 id="基于网格的方法："><a href="#基于网格的方法：" class="headerlink" title="基于网格的方法："></a>基于网格的方法：</h2><p>STING, WaveCluster.</p>
<h2 id="基于模型的聚类："><a href="#基于模型的聚类：" class="headerlink" title="基于模型的聚类："></a>基于模型的聚类：</h2><p>EM,SOM,COBWEB.</p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/2019/10/25/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p><a href="https://www.cnblogs.com/ModifyRong/p/7739955.html" target="_blank" rel="noopener">逻辑回归面试整理</a></p>
<p>逻辑回归假设数据服从<strong>伯努利</strong>分布,通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的</p>
<p>求解过程：按照<strong>极大似然估计求解</strong>或者<strong>交叉熵损失求解</strong>殊途同归</p>
<p>何为极大似然：“模型已定，参数未知”；<strong>利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。</strong></p>
<hr>
<a id="more"></a>
<h2 id="逻辑回归的假设"><a href="#逻辑回归的假设" class="headerlink" title="逻辑回归的假设"></a>逻辑回归的假设</h2><p>逻辑回归的第一个基本假设是假设数据服从伯努利分布</p>
<script type="math/tex; mode=display">h_\theta\left(x;\theta \right )=\frac{1}{1+e^{-\theta^{T} x}}</script><h2 id="逻辑回归的损失函数"><a href="#逻辑回归的损失函数" class="headerlink" title="逻辑回归的损失函数"></a>逻辑回归的损失函数</h2><blockquote>
<blockquote>
<p>样本总体的后验概率</p>
</blockquote>
</blockquote>
<script type="math/tex; mode=display">L_\theta\left(x\right )= \prod _{i=1}^{m}h_\theta(x_{i};\theta )^{y_{i}}*(1-h_\theta(x_{i};\theta))^{1-y_{i}}</script><blockquote>
<blockquote>
<p>损失函数为负对数损失时求和</p>
</blockquote>
</blockquote>
<script type="math/tex; mode=display">J(\theta)=-\frac{1}{N}\sum_{i=1}^{N}[y_{i}log(h_{\theta}(x_i))+(1-y_{i})log(1-h_{\theta}(x_i))]</script><p>交叉熵损失用于回归任务，label[0~1]，y<0.5时0处loss最小；y约>0.5时1处loss最小。</0.5时0处loss最小；y约></p>
<h2 id="逻辑回归的求解方法"><a href="#逻辑回归的求解方法" class="headerlink" title="逻辑回归的求解方法"></a>逻辑回归的求解方法</h2><p>对应着三种优化方法：随机梯度下降，批梯度下降，small batch 梯度下降三种方式：</p>
<ol>
<li>批梯度下降：会获得全局最优解，缺点是在更新每个参数的时候需要遍历所有的数据，当数据量大的时候，每个参数的更新都会很慢。</li>
<li>随机梯度下降：以高方差频繁更新，优点是使得sgd会跳到新的和潜在更好的局部最优解，缺点是使得收敛到局部最优解的过程更加的复杂。</li>
<li>小批量梯度下降：结合了sgd和batch gd的优点，每次更新的时候使用n个样本。减少了参数更新的次数，可以达到更加稳定收敛结果。</li>
</ol>
<h2 id="逻辑回归如何分类"><a href="#逻辑回归如何分类" class="headerlink" title="逻辑回归如何分类"></a>逻辑回归如何分类</h2><p>逻辑回归的划定一个阈值，y值大于这个阈值的是一类，y值小于这个阈值的是另外一类。阈值具体如何调整根据实际情况选择。一般会选择0.5做为阈值来划分。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="平方损失与交叉熵损失"><a href="#平方损失与交叉熵损失" class="headerlink" title="平方损失与交叉熵损失"></a>平方损失与交叉熵损失</h3><ul>
<li>平方损失函数是线性回归假设样本误差服从高斯分布，利用极大似然估计推导而得；交叉熵损失函数是逻辑回归假设样本服从二项分布，利用极大似然估计推导而得。这是<strong>由于模型优化目标不同而推导得到不同的损失函数</strong>。</li>
<li>$\theta _j=\theta _j-\left ( y^{i} -h_\theta (x^{i};\theta ) \right )\ast x^{i}_j$交叉熵损失，误差较大时训练速度较快且稳定，平方损失梯度&lt;=0.25.</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>模型效果，工程上可接受。一般用作baseline</li>
<li>形式简单，模型的可解释性非常好。从特征的权重可以看到不同的特征对最后结果的影响，</li>
<li>训练速度较快。分类的时候，计算量仅仅只和特征的数目相关。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>准确率并不是很高。因为形式非常的简单(非常类似线性模型)，很难去拟合数据的真实分布。</li>
<li>处理非线性数据较麻烦。逻辑回归在不引入其他方法的情况下，只能处理线性可分的数据，或者进一步说，处理二分类的问题 。</li>
<li>逻辑回归本身无法筛选特征。有时候，我们会用gbdt来筛选特征，然后再上逻辑回归。</li>
</ol>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2019/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>物理层,数据链路层,网络层,传输层,会话层,表示层和应用层。<br><a id="more"></a></p>
<hr>
<h2 id="七层OSI"><a href="#七层OSI" class="headerlink" title="七层OSI"></a>七层OSI</h2><ul>
<li>应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li>
<li>表示层：解决用户信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li>
<li>会话层：在会话层及以上的高层次中，数据传送的单位不再另外命名，统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。</li>
<li>传输层 ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。<ol>
<li>传输控制协议 TCP，面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li>
<li>用户数据报协议 UDP，无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
</ol>
</li>
<li>网络层 ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li>
<li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/2019/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.png" alt="avatar"></p>
<h4 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h4><p><img src="/2019/10/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.png" alt="avatar"></p>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据面试基础</title>
    <url>/2019/10/25/bd/</url>
    <content><![CDATA[<h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><p>整理大数据的面试相关内容，主要包括namenode，hdfs读写数据，部署job流程等。<br><a id="more"></a> </p>
<hr>
<h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><ul>
<li>collect: Spark的collect方法，是Action类型的一个算子，收集一个弹性分布式数据集的所有元素到一个数组中。从远程集群拉取数据到driver端将大量数据汇集到一个driver节点上，将数据用数组存放，占用jvm堆内存容易造成内存溢出，只用作小型数据收集。</li>
<li>persist:读取数据转为多个RDD时暂存；提高效率，没必要重复多次读取</li>
</ul>
<h3 id="Shuffle的操作"><a href="#Shuffle的操作" class="headerlink" title="Shuffle的操作"></a>Shuffle的操作</h3><p>由于 Shuffle 操作对性能的影响比较大，所以需要特别注意使用，以下操作都会导致 Shuffle：</p>
<ul>
<li>涉及到重新分区操作： 如 repartition 和 coalesce；</li>
<li>所有涉及到 ByKey 的操作：如 groupByKey 和 reduceByKey，但 countByKey 除外；</li>
<li>联结操作：如 cogroup 和 join。</li>
</ul>
<h3 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h3><p>每个Task任务的闭包都会持有自由变量的副本，如果变量很大且 Task 任务很多的情况下，这必然会对网络 IO 造成压力，为了解决这个情况，Spark 提供了广播变量。<strong>广播变量后不把副本变量分发到每个 Task 中，而是将其分发到每个 Executor，Executor 中的所有 Task 共享一个副本变量。</strong></p>
<h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><ul>
<li><strong>全局变量应用在rdd中运算为副本运算，变量并不改变；rdd中定义变量可改变。</strong></li>
<li>一个RDD由多个分区（Partitions）组成。<strong>对于RDD的每个分区会被一个计算任务所处理，用户可以在创建 RDD 时指定其分区个数，如果没有指定，则默认采用程序所分配到的 CPU 的核心数；</strong> RDD的每次转换都会生成一个新的依赖关系，如果分区数据丢失后，可以通过依赖关系重新计算对RDD的所有分区进行重新计算；</li>
<li>Key-Value 型的 RDD 还拥有 Partitioner(分区器)，用于决定数据被存储在哪个分区中，目前 Spark 中支持 HashPartitioner(按照哈希分区) 和 RangeParationer(按照范围进行分区)；</li>
<li><p>Spark进行任务调度会尽可能的将计算任务分配到其所要处理数据块的存储位置。</p>
</li>
<li><p>RDD 支持两种类型的操作：transformations（转换，从现有数据集创建新数据集）和 actions（在数据集上运行计算后将值返回到驱动程序）。</p>
</li>
<li>RDD 中的所有转换操作都是惰性的，它们只是记住这些转换操作，但不会立即执行，只有遇到 action 操作后才会真正的进行计算，这类似于函数式编程中的惰性求值</li>
</ul>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>mvn clean compile  编译<br>mvn clean test 测试<br><strong>mvn clean package 打包</strong><br>mvn clean install 把生成的jar/war包复制到本地repository(就是~/.m2/repository下面)<br>mvn clean deploy 把生成的jar/war包发送到远程repository（建议配置了私服，那就是往私服发送了）<br>mvn cargo:run 通过cargo插件，把生成的war包部署到本地服务器，并启动。（注意要先运行 mvn clean package 打包）<br>mvn cargo:redeploy 通过cargo插件，把生成的war包部署到远程服务器：如果已经有了，就先undeploy再deploy，如果没有直接deploy（注意要先运行 mvn clean package 打包，并且远程服务器是启动的）</p>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p>org.apache.等外公司名下的包在集群上有相关容器提供，故scope为provide然后提交；<br>私服内公司名下的工程下的包集群上是没有容器提供的，故scope不可以添加provide默认compile，然后提交；<br>本地运行测试时，在应用中勾选“include dependencies with Provided scope”，后成功运行。</p>
<h2 id="IDEA的快捷键"><a href="#IDEA的快捷键" class="headerlink" title="IDEA的快捷键"></a>IDEA的快捷键</h2><p>⌘P 显示方法的参数信息<br>⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）<br>⌘⌥｜切换列编辑<br>⌥↩ 显示意向动作和快速修复代码<br>⌃⌥O 优化import<br>^⌥B 重命名变量<br>⌘+ / ⌘- 展开 / 折叠代码块<br>⌃R 运行<br>⌃D 调试<br>⌘L 在当前文件跳转到某一行的指定处</p>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir -p /a/b/c</td>
<td>父目录不存在时会创建，不会报错</td>
</tr>
<tr>
<td>hadoop fs -germerge -nl /hdfs_dir  /local_dir/</td>
<td>同名则会覆盖；nl在不同文件之间会空一行</td>
</tr>
<tr>
<td>hadoop fs -du -s -h /hdfs_dir</td>
<td>文件夹下数据大小</td>
</tr>
<tr>
<td>hadoop fs -test -e：</td>
<td>如果路径存在，则返回 0;-s：如果路径不为空，则返回 0。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup command aaa.sh &gt;&gt; yu.out &amp;</span><br><span class="line">jobs -l</span><br><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure>
<h3 id="SecondaryNamenode"><a href="#SecondaryNamenode" class="headerlink" title="SecondaryNamenode"></a>SecondaryNamenode</h3><p>SecondaryNameNode：周期性保存NameNode的元数据，在namenode失效时恢复出namenode上的元数据。</p>
<h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>包括文件镜像数据FSImage和编辑日志EditLog。FSImage相当于HDFS的检查点，namenode启动时候会读取FSImage的内容到内存，并将其与EditLog日志中的所有修改信息合并生成新的FSImage；在namenode运行过程中，所有关于HDFS的修改都将写入EditLog。这样，如果namenode失效，可以通过SecondaryNameNode中保存的FSImage和EditLog数据恢复出namenode最近的状态。</p>
<h3 id="HDFS读写流程"><a href="#HDFS读写流程" class="headerlink" title="HDFS读写流程"></a>HDFS读写流程</h3><ol>
<li>向HDFS写数据<br><img src="/2019/10/25/bd/write.png" alt></li>
<li>从HDFS读数据<br><img src="/2019/10/25/bd/read.png" alt></li>
</ol>
<h3 id="提交job应用流程"><a href="#提交job应用流程" class="headerlink" title="提交job应用流程"></a>提交job应用流程</h3><p>提交job的全过程：提交job给YARN，执行MapReduce、HDFS读数据，HDFS写数据。<br>提交job给YARN的过程：提交job，job的初始化，任务分配，任务运行，作业完成<br>作业换队列：<code>yarn application -movetoqueue application_1563931265452_2009268 -queue root.a.b</code></p>
<hr>
<p><img src="/2019/10/25/bd/job.png" alt></p>
<p>1、客户端向Resource Manager申请一个job_id和job资源的提交路径；提交后向Resource manager申请运行 MRAppMaster。</p>
<p>2、Resource Manager将job分配给某一个空闲的NodeManager，创建容器得到MRAppmaster，再把客户端提交的资源下载到本地。</p>
<p>3、MRAppMaster向Resource Manager申请运行多个mapTask任务资源。Resource Manager将mapTask分配给其他NodeManager。</p>
<p>4、Resource Manager向NodeManager发送脚本启动map任务，等所有map任务运行完毕后，向Resource Manager申请容器，运行 reduce任务，运行完后向Resource Manager申请注销。</p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>详解shuffle过程：<br>map-&gt;buff环形缓存区-&gt;溢出合并与归并排序-&gt;按分区号将不同的mapTask数据合并到reduceTask-&gt;同一reduceTask归并排序-&gt;对reduceTask中的value计算</p>
<hr>
<p>从文件中获取block<br><img src="/2019/10/25/bd/spark.png" alt></p>
<ul>
<li>本文件内若干个Block合并成一个输入分片split；不能跨越文件；</li>
<li>一个split对应一个Task；</li>
<li>一个Task执行结果对应RDD的partition<strong>增大分区数，增大task数，增大并行度</strong></li>
<li>一个Executor数目包含多个core；</li>
</ul>
<p><img src="/2019/10/25/bd/mr.jpg" alt="avatar"></p>
<p>map task读取文件写入环形缓冲区（100M），一次溢出后按照key进行hash分区，多次溢出的文件按照分区合并(归并排序)；对多个map task的相同分区内的key进行归并排序，然后传给reduce task。</p>
<h3 id="详解shuffle过程"><a href="#详解shuffle过程" class="headerlink" title="详解shuffle过程"></a>详解shuffle过程</h3><p><img src="/2019/10/25/bd/shuffle1.png" alt><br><img src="/2019/10/25/bd/shuffle2.png" alt></p>
<p>上面的流程是整个mapreduce最全工作流程，但是shuffle过程只是从第7步开始到第16步结束，具体shuffle过程详解，如下：</p>
<ol>
<li>maptask收集我们的map()方法输出的kv对，放到内存缓冲区中</li>
<li>从内存缓冲区不断溢出本地磁盘文件，可能会溢出多个文件</li>
<li>多个溢出文件会被合并成大的溢出文件</li>
<li>在溢出过程中，及合并的过程中，都要调用partitoner进行分组和针对key进行排序</li>
<li>reducetask根据自己的分区号，去各个maptask机器上取相应的结果分区数据</li>
<li>reducetask会取到同一个分区的来自不同maptask的结果文件，reducetask会将这些文件再进行合并（归并排序）</li>
<li>合并成大文件后，shuffle的过程也就结束了，后面进入reducetask的逻辑运算过程（从文件中取出一个一个的键值对group，调用用户自定义的reduce()方法）</li>
</ol>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><ul>
<li>Shuffle中的缓冲区大小会影响到mapreduce程序的执行效率，原则上说，缓冲区越大，磁盘io的次数越少，执行速度就越快。</li>
<li>缓冲区的大小可以通过参数调整，参数：io.sort.mb  默认100M</li>
</ul>
<p><img src="/2019/10/25/bd/mr.png" alt="avatar"></p>
<h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>map端输出(k,v)对key取hash值实现分区负载均衡算法</p>
<h3 id="Combiner"><a href="#Combiner" class="headerlink" title="Combiner"></a>Combiner</h3><p>每一个map都可能会产生大量的本地输出，Combiner的作用就是对<strong>本地的map端的输出先做一次合并</strong>key下value以list形式存储，<strong>大大减少在map和reduce节点之间的数据传输量，以提高网络IO性能</strong>是MapReduce的一种优化手段之一。就在part下对相同的key提前合并一下</p>
<ul>
<li>combiner是MR程序中Mapper和Reducer之外的一种组件</li>
<li>combiner组件的父类就是Reducer</li>
<li>combiner和reducer的区别在于运行的位置：Combiner是在每一个maptask所在的节点运行，Reducer是接收全局所有Mapper的输出结果；</li>
<li>combiner的意义就是对每一个maptask的输出进行局部汇总，以减小网络传输量</li>
<li>combiner能够应用的前提是不能影响最终的业务逻辑，而且，combiner的输出kv应该跟reducer的输入kv类型要对应起来</li>
</ul>
<h3 id="二次排序"><a href="#二次排序" class="headerlink" title="二次排序"></a>二次排序</h3><p>如何做到在Reduce阶段，先对Key排序，再对Value排序<br>该问题通常称为”二次排序“，最常用的方法是将Value放到Key中，实现一个组合Key，然后自定义Key排序规则（为Key实现一个WritableComparable）</p>
<h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><ul>
<li>行键：是hbase表自带的，每个行键对应一条数据。</li>
<li>列族：是创建表时指定的，为列的集合，每个列族作为一个文件单独存储，存储的数据都是字节数组，其中数据可以有很多，通过时间戳来区分。</li>
<li>物理模型：整个hbase表会拆分成多个region，每个region记录着行键的起始点保存在不同的节点上，查询时就是对各个节点的并行查询，当region很大时使用.META表存储各个region的起始点，-ROOT又可以存储.META的起始点。</li>
</ul>
<ol>
<li>Rowkey的设计原则：各个列族数据平衡，长度原则、相邻原则，创建表的时候设置表放入regionserver缓存中，避免自动增长和时间，使用字节数组代替string，最大长度64kb，最好16字节以内，按天分表，两个字节散列，四个字节存储时分毫秒。</li>
<li>列族的设计原则：尽可能少(按照列族进行存储，按照region进行读取，不必要的io操作)，经常和不经常使用的两类数据放入不同列族中，列族名字尽可能短</li>
</ol>
<h3 id="hbase-shell"><a href="#hbase-shell" class="headerlink" title="hbase shell"></a>hbase shell</h3><p>hbase扫的是key，非视频id，哈希后的数据对应的key<br><figure class="highlight plain"><figcaption><span>'hbasehhhhh','000005020000'```</span></figcaption><table><tr><td class="code"><pre><span class="line">```scan &apos;hbasehhhhh&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以某字符连接字段</span></span><br><span class="line">concat_ws：<span class="keyword">SELECT</span> <span class="keyword">CONCAT_WS</span>(<span class="string">'_'</span>,<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">AS</span> con_ws <span class="keyword">FROM</span> info;</span><br><span class="line"><span class="comment">#对字段A分组，队字段B降序且取字段B的top3</span></span><br><span class="line">row_number：<span class="keyword">select</span> <span class="keyword">id</span>,age,<span class="keyword">name</span>,sex <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span>,age,<span class="keyword">name</span>,sex,row_number() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> sex <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>) <span class="keyword">as</span> rownumber <span class="keyword">from</span> rownumber) temp <span class="keyword">where</span> rownumber&lt;<span class="number">3</span> </span><br><span class="line"><span class="comment">#条件真值与假值</span></span><br><span class="line">case..when：<span class="keyword">case</span> tb1.os <span class="keyword">when</span> <span class="string">'android'</span> <span class="keyword">then</span> <span class="string">'android'</span> <span class="keyword">when</span> <span class="string">'ios'</span> <span class="keyword">then</span> <span class="string">'iPhone'</span> <span class="keyword">else</span> <span class="string">'PC'</span> <span class="keyword">end</span> <span class="keyword">as</span> os</span><br><span class="line"><span class="comment">##[&#123;"name":"王二狗","sex":"男","age":"25"&#125;,&#123;"name":"李狗嗨","sex":"男","age":"47"&#125;]</span></span><br><span class="line">get_json_object：</span><br><span class="line"><span class="number">1.</span><span class="keyword">SELECT</span> get_json_object(xjson,<span class="string">"$.[0]"</span>) <span class="keyword">FROM</span> person;</span><br><span class="line">2.SELECT get_json_object(xjson,"$.[0].age") FROM person;</span><br></pre></td></tr></table></figure>
<h2 id="hive表"><a href="#hive表" class="headerlink" title="hive表"></a>hive表</h2><h3 id="内部表与外部表"><a href="#内部表与外部表" class="headerlink" title="内部表与外部表"></a>内部表与外部表</h3><ol>
<li>一般为内部表，<strong>删除内部表时相应数据也会删除</strong></li>
<li>内部表数据由Hive自身管理，外部表数据由HDFS管理。</li>
<li>内部表数据存储在hive.metastore.warehouse.dir【默认:/user/hive/warehouse】，外部表数据存储位置由用户自己决定。</li>
<li>加载内部表数据后会把数据源删除，很像”剪切/移动”。<strong>删除内部表会直接删除元数据【metadata】及存储数据</strong></li>
<li>加载外部表没有mv到数据仓库目录，只是关联上数据格式和数据位置，Hive就能直接访问外部数据。<strong>删除外部表仅仅删除元数据，HDFS上的文件不会被删除。</strong></li>
</ol>
<h3 id="加载与删除分区"><a href="#加载与删除分区" class="headerlink" title="加载与删除分区"></a>加载与删除分区</h3><ul>
<li>外部分区表删除分区，只会删除元数据，相应的目录和文件并不会删除；</li>
<li>内部表删除分区，既会删除元数据，也会删除相应的目录和数据文件；</li>
</ul>
<h3 id="hive命令"><a href="#hive命令" class="headerlink" title="hive命令"></a>hive命令</h3><h2 id="hive"><a href="#hive" class="headerlink" title="hive"></a>hive</h2><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use qiyu_feature;</span><br><span class="line">create table update_user_mobile_brand_day(</span><br><span class="line">uid string comment &apos;uid&apos;,</span><br><span class="line">ctiy_id string comment &apos;城市&apos;,</span><br><span class="line">brand string comment &apos;手机品牌&apos;,</span><br><span class="line">mkey string comment &apos;渠道mkey&apos;)</span><br><span class="line">partitioned by (dt string) row format delimited fields terminated by &apos;\t&apos; stored as textfile;</span><br></pre></td></tr></table></figure>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><ol>
<li>添加字段 <code>alter table table add columns(mkey string);</code></li>
<li>修改表名 <code>alter table table_name rename ti new_table_name;</code></li>
<li>修改列名 <code>alter table table_name change old_name new_name data_type first col1 after col2;</code></li>
<li>增加分区 <code>alter table table_name add if not exists partition (dt=&#39;2019-12-01&#39;) location &#39;/data/a/b/2019-12-01&#39;;</code></li>
<li>删除分区 <code>alter table table_name drop if exists partition (dt=&#39;2019-12-01&#39;);</code></li>
</ol>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>func</th>
</tr>
</thead>
<tbody>
<tr>
<td>percentile_approxc</td>
<td><code>percentile_approx(cast(playtime as int),0.5) as mwt</code></td>
</tr>
<tr>
<td>cast(col as int) as res</td>
<td>列做类型转换</td>
</tr>
<tr>
<td>round</td>
<td>四舍五入</td>
</tr>
<tr>
<td>ceil</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor</td>
<td>向下取整</td>
</tr>
<tr>
<td>lower：转成小写</td>
<td><code>select lower(&#39;Hive&#39;);</code> —hive</td>
</tr>
<tr>
<td>upper：转成大写</td>
<td><code>select lower(&#39;Hive&#39;);</code> —HIVE</td>
</tr>
<tr>
<td>length：长度</td>
<td><code>select length(&#39;Hive&#39;);</code> —4</td>
</tr>
<tr>
<td>concat：拼接字符串</td>
<td><code>select concat(&#39;hello&#39;,&#39;Hive&#39;);</code> —helloHive</td>
</tr>
<tr>
<td>substr：求子串</td>
<td><code>select substr(&#39;hive&#39;,2);</code> —ive <code>select substr(&#39;hive&#39;,2,1);</code> —i</td>
</tr>
<tr>
<td>trim：去掉前后的空格</td>
<td><code>select trim(&#39;  hive   &#39;);</code> -hive</td>
</tr>
<tr>
<td>lpad：左填充</td>
<td><code>select lpad(&#39;hive&#39;,10,&#39;#&#39;);</code> —######hive</td>
</tr>
<tr>
<td>rpad：右填充</td>
<td><code>select rpad(&#39;hive&#39;,10,&#39;#&#39;);</code> —hive######</td>
</tr>
<tr>
<td>to_date</td>
<td><code>select to_date(&#39;2015-05-22 15:34:23&#39;);</code> —2015-05-22</td>
</tr>
<tr>
<td>year</td>
<td><code>select year(&#39;2015-05-22 15:34:23&#39;);</code> —2015</td>
</tr>
<tr>
<td>month</td>
<td><code>select month(&#39;2015-05-22 15:34:23&#39;);</code> —5</td>
</tr>
<tr>
<td>day</td>
<td><code>select day(&#39;2015-05-22 15:34:23&#39;);</code> —22</td>
</tr>
<tr>
<td>weekofyear</td>
<td><code>select weekofyear(&#39;2015-05-22 15:34:23&#39;);</code> —21</td>
</tr>
<tr>
<td>datediff</td>
<td><code>select datediff(&#39;2015-05-22 15:34:23&#39;,&#39;2015-05-29 15:34:23&#39;);</code> —[-7]</td>
</tr>
<tr>
<td>date_add</td>
<td><code>select date_add(&#39;2015-05-22 15:34:23&#39;,2);</code> —2015-05-24</td>
</tr>
<tr>
<td>date_sub</td>
<td><code>select date_sub(&#39;2015-05-22 15:34:23&#39;,2);</code> —2015-05-20</td>
</tr>
<tr>
<td>case……when</td>
<td><code>select ename,job,sal,case job when &#39;president&#39; then sal+100 when &#39;manager&#39; then sal+800 else sal+400 end from emp;</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Hive与SQL"><a href="#Hive与SQL" class="headerlink" title="Hive与SQL"></a>Hive与SQL</h3><ul>
<li>数据存储位置不同：hive是把数据存储在hdfs上，mysql数据是存储在自己的系统中</li>
<li>数据格式：hive数据格式用户可以自定义，mysql有自己的系统定义格式</li>
<li>数据更新：hive不支持数据更新，只可以读，不可以写，而sql支持数据更新</li>
<li>索引：hive没有索引，因此查询数据的时候是通过mapreduce很暴力的把数据都查询一遍，也造成了hive查询数据速度很慢的原因，而mysql有索引；</li>
<li>延迟性：hive延迟性高，原因就是上边一点所说的，而mysql延迟性低；</li>
<li>数据规模：hive存储的数据量超级大，而mysql只是存储一些少量的业务数据；</li>
<li>底层执行原理：hive底层是用的mapreduce，而mysql是excutor执行器</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>消息是kafka主要处理的对象，在某个主题之下，生产者向主题发布新消息，消费者从主题订阅新消息。<br>异步处理、应用解耦、流量缓冲、日志采集</p>
<ul>
<li>消息队列实现订单系统与库存系统的解耦，到应用层的解耦，防止短时间压垮应用；</li>
<li>负责日志数据接收存储与转发</li>
</ul>
<h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><h3 id="流处理与批处理"><a href="#流处理与批处理" class="headerlink" title="流处理与批处理"></a>流处理与批处理</h3><ol>
<li>流处理系统：一条数据被处理完成后，序列化到缓存中，通过网络传输到下一个节点，由下一个节点继续处理。</li>
<li>批处理系统：一条数据被处理完成后，序列化到缓存中，并不会立刻通过网络传输到下一个节点，当缓存写满，就持久化到本地硬盘上，当所有数据都被处理完成后，才数据通过网络传输到下一个节点。</li>
</ol>
<ul>
<li>数据传输的两个极端：流处理系统对低延迟；批处理系统对高吞吐量。</li>
<li><strong>Flink是两个极端的折中，以固定缓存块为单位传输，且缓存块超时值是可调的</strong>。如果缓存块为0，则是低延迟的流处理系统；如果缓存块的超时值为无限大，则是高吞吐量的批处理系统。</li>
</ul>
<h4 id="Flink容错性高，快照恢复"><a href="#Flink容错性高，快照恢复" class="headerlink" title="Flink容错性高，快照恢复"></a>Flink容错性高，快照恢复</h4><p>Flink基于分布式快照与可部分重发的数据源实现了容错。用户可自定义对整个Job进行快照的时间间隔，当任务失败时，Flink会将整个Job恢复到最近一次快照，并从数据源重发快照之后的数据。</p>
<h2 id="Scala基础"><a href="#Scala基础" class="headerlink" title="Scala基础"></a>Scala基础</h2><ul>
<li>case class：自动生成常用方法(equals&amp;hashCode,toString,copy)；自动生成伴生对象；实现了 apply 方法让你不需要通过 new 来创建类实例</li>
<li>宽依赖，窄依赖：窄依赖：map和filter，一个父RDD对应一个子RDD；宽依赖：一个父RDD对应非全部的子RDD；</li>
<li>Transformation与Action：Transformation 操作是延迟计算的，也就是说从一个RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算（map, filter）；Action是count之类的算子出发计算；</li>
<li>存在shuffle的spark算子：distinct、groupByKey，reduceByKey、repartition，coalesce、interection，join；</li>
</ul>
<h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><h3 id="Spark-job资源分配"><a href="#Spark-job资源分配" class="headerlink" title="Spark job资源分配"></a>Spark job资源分配</h3><div class="table-container">
<table>
<thead>
<tr>
<th>config</th>
<th>num</th>
<th>annotation</th>
</tr>
</thead>
<tbody>
<tr>
<td>driver-memory</td>
<td>4g</td>
<td>driver使用的内存，不可超过单机的 core 总数。</td>
</tr>
<tr>
<td>num-executors</td>
<td>2</td>
<td>创建多少个 executor。</td>
</tr>
<tr>
<td>executor-memory</td>
<td>2g</td>
<td>各个 executor使用的最大内存，不可超过单机的最大可使用内存。</td>
</tr>
<tr>
<td>executor-cores</td>
<td>2</td>
<td>各个 executor 使用的并发线程数目，也即每个 executor 最大可并发执行的 Task 数目。</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2019/10/25/bd/cluster.jpg" alt="avatar"></p>
<ul>
<li>数据倾斜：某个key下value过多，reduce_task处理任务过重导致运行特别慢。shuffle出现在期间。造成后果：有得任务执行完毕，某个任务执行很慢而且可能出现OOM错误；一般增大执行器与核数，并行数，自定义partition</li>
<li>尽量减少spark任务的空间占用，同时加速spark任务运行速度</li>
</ul>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql</title>
    <url>/2019/10/25/Sql/</url>
    <content><![CDATA[<h1 id="SQL基础"><a href="#SQL基础" class="headerlink" title="SQL基础"></a>SQL基础</h1><p>简要sql语法基础，包括添加外部脚本，基本的增删改查<br><a id="more"></a></p>
<hr>
<h2 id="调用Python脚本"><a href="#调用Python脚本" class="headerlink" title="调用Python脚本"></a>调用Python脚本</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ADD FILE $curdir/user_doc_generator_filter_session.py;</span><br><span class="line">FROM(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        eventid,</span><br><span class="line">        uid,</span><br><span class="line">        fid,</span><br><span class="line">        weight_info</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        engine_with_pingback</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        dt = <span class="string">'$common_cur_dt'</span></span><br><span class="line">        <span class="keyword">AND</span> <span class="keyword">hour</span>=<span class="string">'$common_cur_hour'</span></span><br><span class="line">        <span class="keyword">AND</span> method=<span class="string">'baseline'</span></span><br><span class="line">        cluster <span class="keyword">by</span> eventid</span><br><span class="line">        ) b</span><br><span class="line">    <span class="keyword">INSERT</span> OVERWRITE <span class="keyword">DIRECTORY</span> <span class="string">'$cur_hdata_path'</span></span><br><span class="line">    <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\t'</span></span><br><span class="line">    REDUCE</span><br><span class="line">        eventid, uid, fid,weight_info</span><br><span class="line">    <span class="keyword">USING</span></span><br><span class="line">        <span class="string">'python user_doc_generator_filter_session.py user_doc_analyzer_reducer'</span></span><br><span class="line">    <span class="keyword">AS</span></span><br><span class="line">        uid, eventid, fid, weight_info</span><br></pre></td></tr></table></figure>
<h2 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h2><ol>
<li>创建索引；避免索引上引用计算；预编译查询；临时表暂存（减少阻塞提高并发性能）；避免使用having（分组后过滤，开销很大）</li>
<li>分区dt,strategy统计，用样本估计整体；</li>
<li>常用列建立索引，但不是越多越好。</li>
</ol>
<h2 id="SQL关键字"><a href="#SQL关键字" class="headerlink" title="SQL关键字"></a>SQL关键字</h2><ul>
<li>+：多个列或者不同表的多个列的值相加；后跟as</li>
<li>between 66 and 68：选择范围</li>
<li>like：’_9’,’%9%’正则匹配单个和多个任意字符，比如姓王的人’王%’</li>
<li>top……order by……desc：降序后取前5；默认升序</li>
<li>distinct：去重</li>
<li>group by：查询的内容必须存在groupby内；</li>
<li>not null：查询不为空的信息，值判断不等&lt;&gt;</li>
<li>concat_ws(‘,’,c1,c2)：格式化连接多个字段</li>
<li>ltrim(rtrim(name))as name：左右去掉多余空格</li>
<li>round(c1,-1)：c1字段四舍五入，-1处为小数位数</li>
<li>substring(c1,1,3)：位置处取子串</li>
<li>stuff(c1,2,2,20170901)as new_number：在c1列插入新的数字</li>
<li>(len(s1)-len(replace(s2,p,’’)))/len(p)：用字符串p换为空，得到缺失长度/p的长度，计算p字符串出现的次数</li>
<li>upper，lower大小写转换</li>
<li>replace(s,p,q)：对字符串s的p字串替换为q</li>
<li>row_number() over (partition by id order by salary desc) rank</li>
<li><p>```sql<br>case c1</p>
<pre><code>when condition1 then result1
when condition2 then result2
when condition3 then result3
</code></pre><p>else </p>
<pre><code>result0
</code></pre><p>end new_column_name;</p>
</li>
<li><p>sum,avg,min,max</p>
</li>
<li>count(distinct(c1))as type：去重后计算种类</li>
<li>```sql<br>select id,name,sum(a,b,c,d)as grade from student group by id name order by grade desc;</li>
<li>avg,sum(coalesce(c1,0))：无参数时则非空后的记录进行操作；有参数则空行换数后取平均或者和</li>
<li>Group by ROLLUP(A, B, C)：首先会对(A、B、C)进行GROUP BY，然后对(A、B)进行GROUP BY，然后是(A)进行GROUP BY，最后对全表进行GROUP BY操作。递进式分组聚合</li>
<li>GROUP BY CUBE(A, B, C)，首先会对(A、B、C)进行GROUP BY，然后依次是(A、B)，(A、C)，(A)，(B、C)，(B)，(C)，最后对全表进行GROUP BY操作。交叉式分组聚合</li>
<li>having：分组聚合后进行选择</li>
<li>asc：递增</li>
<li>where c1 in (v1,v2,v3)：c1列中是v1,v2,v3的一种即可</li>
<li>select * into newTable：插入新表</li>
<li>unique：创建表时保证某个字段不可重</li>
<li>primary key：值唯一，非NULL</li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul>
<li>where型：内层查询结果当作外层查询的比较条件<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> goods_id,goods_name,shop_price <span class="keyword">FROM</span> goods <span class="keyword">WHERE</span> goods_id = (<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(goods_id) <span class="keyword">FROM</span> goods);</span><br><span class="line">- from型：内层查询结果作为临时表，供外层sql再此查询，临时表名</span><br><span class="line">- ```sql</span><br><span class="line">  <span class="keyword">SELECT</span> goods_id,goods_name,cat_id,shop_price <span class="keyword">FROM</span>(<span class="keyword">SELECT</span> goods_id,goods_name,cat_id,shop_price <span class="keyword">FROM</span> goods <span class="keyword">ORDER</span> <span class="keyword">BY</span> cat_id <span class="keyword">ASC</span>,goods_id <span class="keyword">DESC</span>) <span class="keyword">AS</span> tmp <span class="keyword">GROUP</span> <span class="keyword">BY</span> cat_id;</span><br><span class="line">- exists型：把外层取出来拿到内层sql测试，成立则该行取出</span><br><span class="line">- ```sql</span><br><span class="line">  <span class="keyword">SELECT</span> c.cat_id,c.cat_name <span class="keyword">FROM</span> <span class="keyword">category</span> c <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> goods g <span class="keyword">WHERE</span> g.cat_id = c.cat_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## join</span></span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line"><span class="keyword">SELECT</span> dname,<span class="keyword">sum</span>(salary)<span class="keyword">as</span> s <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> a.*, b.salary <span class="keyword">from</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> n.id,n.name,d.dname <span class="keyword">from</span> </span><br><span class="line">            ntable n ,dtable d </span><br><span class="line">            <span class="keyword">where</span> n.dpid = d.did</span><br><span class="line">        )a,stable b </span><br><span class="line">        <span class="keyword">where</span> a.id = b.id</span><br><span class="line">    )c <span class="keyword">GROUP</span> <span class="keyword">BY</span> dname <span class="keyword">ORDER</span> <span class="keyword">BY</span> s <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">##插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Websites (<span class="keyword">name</span>, <span class="keyword">url</span>, country) <span class="keyword">VALUES</span> (<span class="string">'stackoverflow'</span>, <span class="string">'http://stackoverflow.com/'</span>, <span class="string">'IND'</span>);</span><br><span class="line"><span class="comment">##更新（对全表）</span></span><br><span class="line"><span class="keyword">UPDATE</span> Websites <span class="keyword">SET</span> alexa=<span class="string">'5000'</span>, country=<span class="string">'USA'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'菜鸟教程'</span>;</span><br><span class="line"><span class="comment">##添加删除修改列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> column_name datatype</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br><span class="line"><span class="comment">##删除（不删除表）</span></span><br><span class="line"><span class="keyword">DELETE</span> * <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Websites <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'百度'</span> <span class="keyword">AND</span> country=<span class="string">'CN'</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java</title>
    <url>/2019/10/25/Java/</url>
    <content><![CDATA[<h1 id="Java面试基础"><a href="#Java面试基础" class="headerlink" title="Java面试基础"></a>Java面试基础</h1><p>大数据岗会问一些Java基础和计算机基础，主要包括GC，JVM，线程进程，同步互斥等<br><img src="/2019/10/25/Java/jvm.jpg" alt="JVM"><br><a id="more"></a></p>
<hr>
<h2 id="JVM与GC"><a href="#JVM与GC" class="headerlink" title="JVM与GC"></a>JVM与GC</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>程序计数器—与每个线程线程执行字节码行号有关—线程私有</li>
<li>虚拟机栈—与Java方法有关创建栈帧—线程私有</li>
<li>本地方法栈—与Java的native方法有关—线程私有</li>
<li>Java堆—与Java对象实例有关/垃圾收集器管理的主要区域—GC堆</li>
<li>Java方法区——线程共享；存储被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。</li>
</ol>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><ul>
<li>引用计数：对象被引用时，计数器加1，引用失效时减1，当计数器值为0时则回收；但难以解决对象之间相互循环引用的问题；</li>
<li>可达性分析：GC_Roots起始点向下通过引用链搜索，当一个对象到GC_Roots没有任何引用时，则对象是不可用的。第一次回收触发finalize方法，如果不在引用则回收；如果不回收，第二次触发finalize方法时肯定回收。</li>
</ul>
<h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p>标记需要回收的对象，标记后统一回收。</p>
<ul>
<li>缺点：效率低，会产生不连续内存碎片，无法分配大对象的内存</li>
</ul>
<h4 id="复制算法——适用于新生代"><a href="#复制算法——适用于新生代" class="headerlink" title="复制算法——适用于新生代"></a>复制算法——适用于新生代</h4><p>可用内存分为A、B两块；使用其中一块，用完了A以后将存活的对象复制到B，然后对A进行清理，如此每次都对整个半区进行内存回收，不用考虑内存碎片，只需移动堆顶指针按顺序分配内存即可。</p>
<h4 id="标记-整理——适用于老年代"><a href="#标记-整理——适用于老年代" class="headerlink" title="标记-整理——适用于老年代"></a>标记-整理——适用于老年代</h4><p>标记后不清理，而是让所有存活对象向一端移动，然后清理端外界以外的内存。</p>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>将Java堆分为新生代（大批对象死去，少量存活）、老年代（对象存活率高，没有额外空间分配担保）。</p>
<ul>
<li>新生代：复制算法；</li>
<li>老年代：标记-整理算法。</li>
</ul>
<h3 id="关于内存分配与回收原则"><a href="#关于内存分配与回收原则" class="headerlink" title="关于内存分配与回收原则"></a>关于内存分配与回收原则</h3><p>对于Java堆中对所有对象的内存分配，首先在Eden中分配；然后大的对象直接老年代;在survivor中存活时间过长也进入老年代；新生代的对象满足老年代连续空间则进入老年代,否则对老年代Full_GC。在给对象分配内存区域的时候，也时刻进行着判断内存回收，对新生代Minor_GC(复制算法)，对老年代Full_GC(标记-整理算法)。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol>
<li>集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。</li>
<li>指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种相互等待的现象，若无外力作用，他们将无法推进下去。</li>
</ol>
<p>产生锁的资源：线程池、网络连接池、通知事件，磁盘、带宽</p>
<h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ol>
<li>资源互斥条件：进程对于所分配到的资源具有排他性，一个资源只能由一个进程占用，知道该进程释放该资源。</li>
<li>不可剥夺条件：进程无法剥夺其他进程的资源，知道其他进程释放资源后才可能请求到。</li>
<li>请求保持条件：进程会请求所有需要的资源，如果过程中因为缺少资源而阻塞，已请求到的资源不会释放。</li>
<li>循环等待条件：死锁发生时，一定有两个或以上的进程形成环路，在等待下一个进程的某些资源，导致永久阻塞。</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ol>
<li>以确定顺序获得锁\<br>hashCode排序，顺序获得；多进程时使用银行家算法试探是否安全。<br><strong>银行家算法</strong>：当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</li>
<li>超时放弃<br>按照固定时长等待锁，超时以后<strong>主动释放之前已经获得的所有的锁</strong>。</li>
</ol>
<h3 id="案例与解决办法"><a href="#案例与解决办法" class="headerlink" title="案例与解决办法"></a>案例与解决办法</h3><ol>
<li>线程池死锁：扩大线程池线程数 or 使任务结果之间不再互相依赖。</li>
<li>两个线程A和B，两个数据库连接池N1和N2，A先N1后N2;B先N2后N1；且两个线程在完成执行之前都不释放自己已经持有的链接，因此也造成了死锁。</li>
</ol>
]]></content>
      <categories>
        <category>BD</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
